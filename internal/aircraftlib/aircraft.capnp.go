// Code generated by capnpc-go. DO NOT EDIT.

package aircraftlib

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	math "math"
	strconv "strconv"
)

// Constants defined in aircraft.capnp.
const (
	ConstEnum = Airport_jfk
)

// Constants defined in aircraft.capnp.
var (
	ConstDate = Zdate{Struct: capnp.MustUnmarshalRoot(x_832bcc6686a26d56[0:24]).Struct()}
	ConstList = Zdate_List{List: capnp.MustUnmarshalRoot(x_832bcc6686a26d56[24:64]).List()}
)

type Zdate struct{ capnp.Struct }

// Zdate_TypeID is the unique identifier for the type Zdate.
const Zdate_TypeID = 0xde50aebbad57549d

func NewZdate(s *capnp.Segment) (Zdate, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Zdate{st}, err
}

func NewRootZdate(s *capnp.Segment) (Zdate, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Zdate{st}, err
}

func ReadRootZdate(msg *capnp.Message) (Zdate, error) {
	root, err := msg.Root()
	return Zdate{root.Struct()}, err
}

func (s Zdate) String() string {
	str, _ := text.Marshal(0xde50aebbad57549d, s.Struct)
	return str
}

func (s Zdate) Year() int16 {
	return int16(s.Struct.Uint16(0))
}

func (s Zdate) SetYear(v int16) {
	s.Struct.SetUint16(0, uint16(v))
}

func (s Zdate) Month() uint8 {
	return s.Struct.Uint8(2)
}

func (s Zdate) SetMonth(v uint8) {
	s.Struct.SetUint8(2, v)
}

func (s Zdate) Day() uint8 {
	return s.Struct.Uint8(3)
}

func (s Zdate) SetDay(v uint8) {
	s.Struct.SetUint8(3, v)
}

// Zdate_List is a list of Zdate.
type Zdate_List = capnp.StructList[Zdate]

// NewZdate creates a new list of Zdate.
func NewZdate_List(s *capnp.Segment, sz int32) (Zdate_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Zdate]{List: l}, err
}

// Zdate_Future is a wrapper for a Zdate promised by a client call.
type Zdate_Future struct{ *capnp.Future }

func (p Zdate_Future) Struct() (Zdate, error) {
	s, err := p.Future.Struct()
	return Zdate{s}, err
}

type Zdata struct{ capnp.Struct }

// Zdata_TypeID is the unique identifier for the type Zdata.
const Zdata_TypeID = 0xc7da65f9a2f20ba2

func NewZdata(s *capnp.Segment) (Zdata, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Zdata{st}, err
}

func NewRootZdata(s *capnp.Segment) (Zdata, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Zdata{st}, err
}

func ReadRootZdata(msg *capnp.Message) (Zdata, error) {
	root, err := msg.Root()
	return Zdata{root.Struct()}, err
}

func (s Zdata) String() string {
	str, _ := text.Marshal(0xc7da65f9a2f20ba2, s.Struct)
	return str
}

func (s Zdata) Data() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s Zdata) HasData() bool {
	return s.Struct.HasPtr(0)
}

func (s Zdata) SetData(v []byte) error {
	return s.Struct.SetData(0, v)
}

// Zdata_List is a list of Zdata.
type Zdata_List = capnp.StructList[Zdata]

// NewZdata creates a new list of Zdata.
func NewZdata_List(s *capnp.Segment, sz int32) (Zdata_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Zdata]{List: l}, err
}

// Zdata_Future is a wrapper for a Zdata promised by a client call.
type Zdata_Future struct{ *capnp.Future }

func (p Zdata_Future) Struct() (Zdata, error) {
	s, err := p.Future.Struct()
	return Zdata{s}, err
}

type Airport uint16

// Airport_TypeID is the unique identifier for the type Airport.
const Airport_TypeID = 0xe55d85fc1bf82f21

// Values of Airport.
const (
	Airport_none Airport = 0
	Airport_jfk  Airport = 1
	Airport_lax  Airport = 2
	Airport_sfo  Airport = 3
	Airport_luv  Airport = 4
	Airport_dfw  Airport = 5
	Airport_test Airport = 6
)

// String returns the enum's constant name.
func (c Airport) String() string {
	switch c {
	case Airport_none:
		return "none"
	case Airport_jfk:
		return "jfk"
	case Airport_lax:
		return "lax"
	case Airport_sfo:
		return "sfo"
	case Airport_luv:
		return "luv"
	case Airport_dfw:
		return "dfw"
	case Airport_test:
		return "test"

	default:
		return ""
	}
}

// AirportFromString returns the enum value with a name,
// or the zero value if there's no such value.
func AirportFromString(c string) Airport {
	switch c {
	case "none":
		return Airport_none
	case "jfk":
		return Airport_jfk
	case "lax":
		return Airport_lax
	case "sfo":
		return Airport_sfo
	case "luv":
		return Airport_luv
	case "dfw":
		return Airport_dfw
	case "test":
		return Airport_test

	default:
		return 0
	}
}

type Airport_List = capnp.EnumList[Airport]

func NewAirport_List(s *capnp.Segment, sz int32) (Airport_List, error) {
	return capnp.NewEnumList[Airport](s, sz)
}

type PlaneBase struct{ capnp.Struct }

// PlaneBase_TypeID is the unique identifier for the type PlaneBase.
const PlaneBase_TypeID = 0xd8bccf6e60a73791

func NewPlaneBase(s *capnp.Segment) (PlaneBase, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 2})
	return PlaneBase{st}, err
}

func NewRootPlaneBase(s *capnp.Segment) (PlaneBase, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 2})
	return PlaneBase{st}, err
}

func ReadRootPlaneBase(msg *capnp.Message) (PlaneBase, error) {
	root, err := msg.Root()
	return PlaneBase{root.Struct()}, err
}

func (s PlaneBase) String() string {
	str, _ := text.Marshal(0xd8bccf6e60a73791, s.Struct)
	return str
}

func (s PlaneBase) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s PlaneBase) HasName() bool {
	return s.Struct.HasPtr(0)
}

func (s PlaneBase) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s PlaneBase) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s PlaneBase) Homes() (Airport_List, error) {
	p, err := s.Struct.Ptr(1)
	return Airport_List{List: p.List()}, err
}

func (s PlaneBase) HasHomes() bool {
	return s.Struct.HasPtr(1)
}

func (s PlaneBase) SetHomes(v Airport_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewHomes sets the homes field to a newly
// allocated Airport_List, preferring placement in s's segment.
func (s PlaneBase) NewHomes(n int32) (Airport_List, error) {
	l, err := NewAirport_List(s.Struct.Segment(), n)
	if err != nil {
		return Airport_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

func (s PlaneBase) Rating() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s PlaneBase) SetRating(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

func (s PlaneBase) CanFly() bool {
	return s.Struct.Bit(64)
}

func (s PlaneBase) SetCanFly(v bool) {
	s.Struct.SetBit(64, v)
}

func (s PlaneBase) Capacity() int64 {
	return int64(s.Struct.Uint64(16))
}

func (s PlaneBase) SetCapacity(v int64) {
	s.Struct.SetUint64(16, uint64(v))
}

func (s PlaneBase) MaxSpeed() float64 {
	return math.Float64frombits(s.Struct.Uint64(24))
}

func (s PlaneBase) SetMaxSpeed(v float64) {
	s.Struct.SetUint64(24, math.Float64bits(v))
}

// PlaneBase_List is a list of PlaneBase.
type PlaneBase_List = capnp.StructList[PlaneBase]

// NewPlaneBase creates a new list of PlaneBase.
func NewPlaneBase_List(s *capnp.Segment, sz int32) (PlaneBase_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 32, PointerCount: 2}, sz)
	return capnp.StructList[PlaneBase]{List: l}, err
}

// PlaneBase_Future is a wrapper for a PlaneBase promised by a client call.
type PlaneBase_Future struct{ *capnp.Future }

func (p PlaneBase_Future) Struct() (PlaneBase, error) {
	s, err := p.Future.Struct()
	return PlaneBase{s}, err
}

type B737 struct{ capnp.Struct }

// B737_TypeID is the unique identifier for the type B737.
const B737_TypeID = 0xccb3b2e3603826e0

func NewB737(s *capnp.Segment) (B737, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return B737{st}, err
}

func NewRootB737(s *capnp.Segment) (B737, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return B737{st}, err
}

func ReadRootB737(msg *capnp.Message) (B737, error) {
	root, err := msg.Root()
	return B737{root.Struct()}, err
}

func (s B737) String() string {
	str, _ := text.Marshal(0xccb3b2e3603826e0, s.Struct)
	return str
}

func (s B737) Base() (PlaneBase, error) {
	p, err := s.Struct.Ptr(0)
	return PlaneBase{Struct: p.Struct()}, err
}

func (s B737) HasBase() bool {
	return s.Struct.HasPtr(0)
}

func (s B737) SetBase(v PlaneBase) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBase sets the base field to a newly
// allocated PlaneBase struct, preferring placement in s's segment.
func (s B737) NewBase() (PlaneBase, error) {
	ss, err := NewPlaneBase(s.Struct.Segment())
	if err != nil {
		return PlaneBase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// B737_List is a list of B737.
type B737_List = capnp.StructList[B737]

// NewB737 creates a new list of B737.
func NewB737_List(s *capnp.Segment, sz int32) (B737_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[B737]{List: l}, err
}

// B737_Future is a wrapper for a B737 promised by a client call.
type B737_Future struct{ *capnp.Future }

func (p B737_Future) Struct() (B737, error) {
	s, err := p.Future.Struct()
	return B737{s}, err
}

func (p B737_Future) Base() PlaneBase_Future {
	return PlaneBase_Future{Future: p.Future.Field(0, nil)}
}

type A320 struct{ capnp.Struct }

// A320_TypeID is the unique identifier for the type A320.
const A320_TypeID = 0xd98c608877d9cb8d

func NewA320(s *capnp.Segment) (A320, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return A320{st}, err
}

func NewRootA320(s *capnp.Segment) (A320, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return A320{st}, err
}

func ReadRootA320(msg *capnp.Message) (A320, error) {
	root, err := msg.Root()
	return A320{root.Struct()}, err
}

func (s A320) String() string {
	str, _ := text.Marshal(0xd98c608877d9cb8d, s.Struct)
	return str
}

func (s A320) Base() (PlaneBase, error) {
	p, err := s.Struct.Ptr(0)
	return PlaneBase{Struct: p.Struct()}, err
}

func (s A320) HasBase() bool {
	return s.Struct.HasPtr(0)
}

func (s A320) SetBase(v PlaneBase) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBase sets the base field to a newly
// allocated PlaneBase struct, preferring placement in s's segment.
func (s A320) NewBase() (PlaneBase, error) {
	ss, err := NewPlaneBase(s.Struct.Segment())
	if err != nil {
		return PlaneBase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// A320_List is a list of A320.
type A320_List = capnp.StructList[A320]

// NewA320 creates a new list of A320.
func NewA320_List(s *capnp.Segment, sz int32) (A320_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[A320]{List: l}, err
}

// A320_Future is a wrapper for a A320 promised by a client call.
type A320_Future struct{ *capnp.Future }

func (p A320_Future) Struct() (A320, error) {
	s, err := p.Future.Struct()
	return A320{s}, err
}

func (p A320_Future) Base() PlaneBase_Future {
	return PlaneBase_Future{Future: p.Future.Field(0, nil)}
}

type F16 struct{ capnp.Struct }

// F16_TypeID is the unique identifier for the type F16.
const F16_TypeID = 0xe1c9eac512335361

func NewF16(s *capnp.Segment) (F16, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return F16{st}, err
}

func NewRootF16(s *capnp.Segment) (F16, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return F16{st}, err
}

func ReadRootF16(msg *capnp.Message) (F16, error) {
	root, err := msg.Root()
	return F16{root.Struct()}, err
}

func (s F16) String() string {
	str, _ := text.Marshal(0xe1c9eac512335361, s.Struct)
	return str
}

func (s F16) Base() (PlaneBase, error) {
	p, err := s.Struct.Ptr(0)
	return PlaneBase{Struct: p.Struct()}, err
}

func (s F16) HasBase() bool {
	return s.Struct.HasPtr(0)
}

func (s F16) SetBase(v PlaneBase) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBase sets the base field to a newly
// allocated PlaneBase struct, preferring placement in s's segment.
func (s F16) NewBase() (PlaneBase, error) {
	ss, err := NewPlaneBase(s.Struct.Segment())
	if err != nil {
		return PlaneBase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// F16_List is a list of F16.
type F16_List = capnp.StructList[F16]

// NewF16 creates a new list of F16.
func NewF16_List(s *capnp.Segment, sz int32) (F16_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[F16]{List: l}, err
}

// F16_Future is a wrapper for a F16 promised by a client call.
type F16_Future struct{ *capnp.Future }

func (p F16_Future) Struct() (F16, error) {
	s, err := p.Future.Struct()
	return F16{s}, err
}

func (p F16_Future) Base() PlaneBase_Future {
	return PlaneBase_Future{Future: p.Future.Field(0, nil)}
}

type Regression struct{ capnp.Struct }

// Regression_TypeID is the unique identifier for the type Regression.
const Regression_TypeID = 0xb1f0385d845e367f

func NewRegression(s *capnp.Segment) (Regression, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3})
	return Regression{st}, err
}

func NewRootRegression(s *capnp.Segment) (Regression, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3})
	return Regression{st}, err
}

func ReadRootRegression(msg *capnp.Message) (Regression, error) {
	root, err := msg.Root()
	return Regression{root.Struct()}, err
}

func (s Regression) String() string {
	str, _ := text.Marshal(0xb1f0385d845e367f, s.Struct)
	return str
}

func (s Regression) Base() (PlaneBase, error) {
	p, err := s.Struct.Ptr(0)
	return PlaneBase{Struct: p.Struct()}, err
}

func (s Regression) HasBase() bool {
	return s.Struct.HasPtr(0)
}

func (s Regression) SetBase(v PlaneBase) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBase sets the base field to a newly
// allocated PlaneBase struct, preferring placement in s's segment.
func (s Regression) NewBase() (PlaneBase, error) {
	ss, err := NewPlaneBase(s.Struct.Segment())
	if err != nil {
		return PlaneBase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Regression) B0() float64 {
	return math.Float64frombits(s.Struct.Uint64(0))
}

func (s Regression) SetB0(v float64) {
	s.Struct.SetUint64(0, math.Float64bits(v))
}

func (s Regression) Beta() (capnp.Float64List, error) {
	p, err := s.Struct.Ptr(1)
	return capnp.Float64List{List: p.List()}, err
}

func (s Regression) HasBeta() bool {
	return s.Struct.HasPtr(1)
}

func (s Regression) SetBeta(v capnp.Float64List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewBeta sets the beta field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Regression) NewBeta(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

func (s Regression) Planes() (Aircraft_List, error) {
	p, err := s.Struct.Ptr(2)
	return Aircraft_List{List: p.List()}, err
}

func (s Regression) HasPlanes() bool {
	return s.Struct.HasPtr(2)
}

func (s Regression) SetPlanes(v Aircraft_List) error {
	return s.Struct.SetPtr(2, v.List.ToPtr())
}

// NewPlanes sets the planes field to a newly
// allocated Aircraft_List, preferring placement in s's segment.
func (s Regression) NewPlanes(n int32) (Aircraft_List, error) {
	l, err := NewAircraft_List(s.Struct.Segment(), n)
	if err != nil {
		return Aircraft_List{}, err
	}
	err = s.Struct.SetPtr(2, l.List.ToPtr())
	return l, err
}

func (s Regression) Ymu() float64 {
	return math.Float64frombits(s.Struct.Uint64(8))
}

func (s Regression) SetYmu(v float64) {
	s.Struct.SetUint64(8, math.Float64bits(v))
}

func (s Regression) Ysd() float64 {
	return math.Float64frombits(s.Struct.Uint64(16))
}

func (s Regression) SetYsd(v float64) {
	s.Struct.SetUint64(16, math.Float64bits(v))
}

// Regression_List is a list of Regression.
type Regression_List = capnp.StructList[Regression]

// NewRegression creates a new list of Regression.
func NewRegression_List(s *capnp.Segment, sz int32) (Regression_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3}, sz)
	return capnp.StructList[Regression]{List: l}, err
}

// Regression_Future is a wrapper for a Regression promised by a client call.
type Regression_Future struct{ *capnp.Future }

func (p Regression_Future) Struct() (Regression, error) {
	s, err := p.Future.Struct()
	return Regression{s}, err
}

func (p Regression_Future) Base() PlaneBase_Future {
	return PlaneBase_Future{Future: p.Future.Field(0, nil)}
}

type Aircraft struct{ capnp.Struct }
type Aircraft_Which uint16

const (
	Aircraft_Which_void Aircraft_Which = 0
	Aircraft_Which_b737 Aircraft_Which = 1
	Aircraft_Which_a320 Aircraft_Which = 2
	Aircraft_Which_f16  Aircraft_Which = 3
)

func (w Aircraft_Which) String() string {
	const s = "voidb737a320f16"
	switch w {
	case Aircraft_Which_void:
		return s[0:4]
	case Aircraft_Which_b737:
		return s[4:8]
	case Aircraft_Which_a320:
		return s[8:12]
	case Aircraft_Which_f16:
		return s[12:15]

	}
	return "Aircraft_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Aircraft_TypeID is the unique identifier for the type Aircraft.
const Aircraft_TypeID = 0xe54e10aede55c7b1

func NewAircraft(s *capnp.Segment) (Aircraft, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Aircraft{st}, err
}

func NewRootAircraft(s *capnp.Segment) (Aircraft, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Aircraft{st}, err
}

func ReadRootAircraft(msg *capnp.Message) (Aircraft, error) {
	root, err := msg.Root()
	return Aircraft{root.Struct()}, err
}

func (s Aircraft) String() string {
	str, _ := text.Marshal(0xe54e10aede55c7b1, s.Struct)
	return str
}

func (s Aircraft) Which() Aircraft_Which {
	return Aircraft_Which(s.Struct.Uint16(0))
}
func (s Aircraft) SetVoid() {
	s.Struct.SetUint16(0, 0)

}

func (s Aircraft) B737() (B737, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != b737")
	}
	p, err := s.Struct.Ptr(0)
	return B737{Struct: p.Struct()}, err
}

func (s Aircraft) HasB737() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Aircraft) SetB737(v B737) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewB737 sets the b737 field to a newly
// allocated B737 struct, preferring placement in s's segment.
func (s Aircraft) NewB737() (B737, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewB737(s.Struct.Segment())
	if err != nil {
		return B737{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Aircraft) A320() (A320, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != a320")
	}
	p, err := s.Struct.Ptr(0)
	return A320{Struct: p.Struct()}, err
}

func (s Aircraft) HasA320() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Aircraft) SetA320(v A320) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewA320 sets the a320 field to a newly
// allocated A320 struct, preferring placement in s's segment.
func (s Aircraft) NewA320() (A320, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewA320(s.Struct.Segment())
	if err != nil {
		return A320{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Aircraft) F16() (F16, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != f16")
	}
	p, err := s.Struct.Ptr(0)
	return F16{Struct: p.Struct()}, err
}

func (s Aircraft) HasF16() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Aircraft) SetF16(v F16) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewF16 sets the f16 field to a newly
// allocated F16 struct, preferring placement in s's segment.
func (s Aircraft) NewF16() (F16, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewF16(s.Struct.Segment())
	if err != nil {
		return F16{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Aircraft_List is a list of Aircraft.
type Aircraft_List = capnp.StructList[Aircraft]

// NewAircraft creates a new list of Aircraft.
func NewAircraft_List(s *capnp.Segment, sz int32) (Aircraft_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Aircraft]{List: l}, err
}

// Aircraft_Future is a wrapper for a Aircraft promised by a client call.
type Aircraft_Future struct{ *capnp.Future }

func (p Aircraft_Future) Struct() (Aircraft, error) {
	s, err := p.Future.Struct()
	return Aircraft{s}, err
}

func (p Aircraft_Future) B737() B737_Future {
	return B737_Future{Future: p.Future.Field(0, nil)}
}

func (p Aircraft_Future) A320() A320_Future {
	return A320_Future{Future: p.Future.Field(0, nil)}
}

func (p Aircraft_Future) F16() F16_Future {
	return F16_Future{Future: p.Future.Field(0, nil)}
}

type Z struct{ capnp.Struct }
type Z_grp Z
type Z_Which uint16

const (
	Z_Which_void          Z_Which = 0
	Z_Which_zz            Z_Which = 1
	Z_Which_f64           Z_Which = 2
	Z_Which_f32           Z_Which = 3
	Z_Which_i64           Z_Which = 4
	Z_Which_i32           Z_Which = 5
	Z_Which_i16           Z_Which = 6
	Z_Which_i8            Z_Which = 7
	Z_Which_u64           Z_Which = 8
	Z_Which_u32           Z_Which = 9
	Z_Which_u16           Z_Which = 10
	Z_Which_u8            Z_Which = 11
	Z_Which_bool          Z_Which = 12
	Z_Which_text          Z_Which = 13
	Z_Which_blob          Z_Which = 14
	Z_Which_f64vec        Z_Which = 15
	Z_Which_f32vec        Z_Which = 16
	Z_Which_i64vec        Z_Which = 17
	Z_Which_i32vec        Z_Which = 18
	Z_Which_i16vec        Z_Which = 19
	Z_Which_i8vec         Z_Which = 20
	Z_Which_u64vec        Z_Which = 21
	Z_Which_u32vec        Z_Which = 22
	Z_Which_u16vec        Z_Which = 23
	Z_Which_u8vec         Z_Which = 24
	Z_Which_boolvec       Z_Which = 39
	Z_Which_datavec       Z_Which = 40
	Z_Which_textvec       Z_Which = 41
	Z_Which_zvec          Z_Which = 25
	Z_Which_zvecvec       Z_Which = 26
	Z_Which_zdate         Z_Which = 27
	Z_Which_zdata         Z_Which = 28
	Z_Which_aircraftvec   Z_Which = 29
	Z_Which_aircraft      Z_Which = 30
	Z_Which_regression    Z_Which = 31
	Z_Which_planebase     Z_Which = 32
	Z_Which_airport       Z_Which = 33
	Z_Which_b737          Z_Which = 34
	Z_Which_a320          Z_Which = 35
	Z_Which_f16           Z_Which = 36
	Z_Which_zdatevec      Z_Which = 37
	Z_Which_zdatavec      Z_Which = 38
	Z_Which_grp           Z_Which = 42
	Z_Which_echo          Z_Which = 43
	Z_Which_echoes        Z_Which = 44
	Z_Which_anyPtr        Z_Which = 45
	Z_Which_anyStruct     Z_Which = 46
	Z_Which_anyList       Z_Which = 47
	Z_Which_anyCapability Z_Which = 48
)

func (w Z_Which) String() string {
	const s = "voidzzf64f32i64i32i16i8u64u32u16u8booltextblobf64vecf32veci64veci32veci16veci8vecu64vecu32vecu16vecu8vecboolvecdatavectextveczveczvecveczdatezdataaircraftvecaircraftregressionplanebaseairportb737a320f16zdateveczdatavecgrpechoechoesanyPtranyStructanyListanyCapability"
	switch w {
	case Z_Which_void:
		return s[0:4]
	case Z_Which_zz:
		return s[4:6]
	case Z_Which_f64:
		return s[6:9]
	case Z_Which_f32:
		return s[9:12]
	case Z_Which_i64:
		return s[12:15]
	case Z_Which_i32:
		return s[15:18]
	case Z_Which_i16:
		return s[18:21]
	case Z_Which_i8:
		return s[21:23]
	case Z_Which_u64:
		return s[23:26]
	case Z_Which_u32:
		return s[26:29]
	case Z_Which_u16:
		return s[29:32]
	case Z_Which_u8:
		return s[32:34]
	case Z_Which_bool:
		return s[34:38]
	case Z_Which_text:
		return s[38:42]
	case Z_Which_blob:
		return s[42:46]
	case Z_Which_f64vec:
		return s[46:52]
	case Z_Which_f32vec:
		return s[52:58]
	case Z_Which_i64vec:
		return s[58:64]
	case Z_Which_i32vec:
		return s[64:70]
	case Z_Which_i16vec:
		return s[70:76]
	case Z_Which_i8vec:
		return s[76:81]
	case Z_Which_u64vec:
		return s[81:87]
	case Z_Which_u32vec:
		return s[87:93]
	case Z_Which_u16vec:
		return s[93:99]
	case Z_Which_u8vec:
		return s[99:104]
	case Z_Which_boolvec:
		return s[104:111]
	case Z_Which_datavec:
		return s[111:118]
	case Z_Which_textvec:
		return s[118:125]
	case Z_Which_zvec:
		return s[125:129]
	case Z_Which_zvecvec:
		return s[129:136]
	case Z_Which_zdate:
		return s[136:141]
	case Z_Which_zdata:
		return s[141:146]
	case Z_Which_aircraftvec:
		return s[146:157]
	case Z_Which_aircraft:
		return s[157:165]
	case Z_Which_regression:
		return s[165:175]
	case Z_Which_planebase:
		return s[175:184]
	case Z_Which_airport:
		return s[184:191]
	case Z_Which_b737:
		return s[191:195]
	case Z_Which_a320:
		return s[195:199]
	case Z_Which_f16:
		return s[199:202]
	case Z_Which_zdatevec:
		return s[202:210]
	case Z_Which_zdatavec:
		return s[210:218]
	case Z_Which_grp:
		return s[218:221]
	case Z_Which_echo:
		return s[221:225]
	case Z_Which_echoes:
		return s[225:231]
	case Z_Which_anyPtr:
		return s[231:237]
	case Z_Which_anyStruct:
		return s[237:246]
	case Z_Which_anyList:
		return s[246:253]
	case Z_Which_anyCapability:
		return s[253:266]

	}
	return "Z_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Z_TypeID is the unique identifier for the type Z.
const Z_TypeID = 0xea26e9973bd6a0d9

func NewZ(s *capnp.Segment) (Z, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return Z{st}, err
}

func NewRootZ(s *capnp.Segment) (Z, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return Z{st}, err
}

func ReadRootZ(msg *capnp.Message) (Z, error) {
	root, err := msg.Root()
	return Z{root.Struct()}, err
}

func (s Z) String() string {
	str, _ := text.Marshal(0xea26e9973bd6a0d9, s.Struct)
	return str
}

func (s Z) Which() Z_Which {
	return Z_Which(s.Struct.Uint16(0))
}
func (s Z) SetVoid() {
	s.Struct.SetUint16(0, 0)

}

func (s Z) Zz() (Z, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != zz")
	}
	p, err := s.Struct.Ptr(0)
	return Z{Struct: p.Struct()}, err
}

func (s Z) HasZz() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetZz(v Z) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewZz sets the zz field to a newly
// allocated Z struct, preferring placement in s's segment.
func (s Z) NewZz() (Z, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewZ(s.Struct.Segment())
	if err != nil {
		return Z{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) F64() float64 {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != f64")
	}
	return math.Float64frombits(s.Struct.Uint64(8))
}

func (s Z) SetF64(v float64) {
	s.Struct.SetUint16(0, 2)
	s.Struct.SetUint64(8, math.Float64bits(v))
}

func (s Z) F32() float32 {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != f32")
	}
	return math.Float32frombits(s.Struct.Uint32(8))
}

func (s Z) SetF32(v float32) {
	s.Struct.SetUint16(0, 3)
	s.Struct.SetUint32(8, math.Float32bits(v))
}

func (s Z) I64() int64 {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != i64")
	}
	return int64(s.Struct.Uint64(8))
}

func (s Z) SetI64(v int64) {
	s.Struct.SetUint16(0, 4)
	s.Struct.SetUint64(8, uint64(v))
}

func (s Z) I32() int32 {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != i32")
	}
	return int32(s.Struct.Uint32(8))
}

func (s Z) SetI32(v int32) {
	s.Struct.SetUint16(0, 5)
	s.Struct.SetUint32(8, uint32(v))
}

func (s Z) I16() int16 {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != i16")
	}
	return int16(s.Struct.Uint16(8))
}

func (s Z) SetI16(v int16) {
	s.Struct.SetUint16(0, 6)
	s.Struct.SetUint16(8, uint16(v))
}

func (s Z) I8() int8 {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != i8")
	}
	return int8(s.Struct.Uint8(8))
}

func (s Z) SetI8(v int8) {
	s.Struct.SetUint16(0, 7)
	s.Struct.SetUint8(8, uint8(v))
}

func (s Z) U64() uint64 {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != u64")
	}
	return s.Struct.Uint64(8)
}

func (s Z) SetU64(v uint64) {
	s.Struct.SetUint16(0, 8)
	s.Struct.SetUint64(8, v)
}

func (s Z) U32() uint32 {
	if s.Struct.Uint16(0) != 9 {
		panic("Which() != u32")
	}
	return s.Struct.Uint32(8)
}

func (s Z) SetU32(v uint32) {
	s.Struct.SetUint16(0, 9)
	s.Struct.SetUint32(8, v)
}

func (s Z) U16() uint16 {
	if s.Struct.Uint16(0) != 10 {
		panic("Which() != u16")
	}
	return s.Struct.Uint16(8)
}

func (s Z) SetU16(v uint16) {
	s.Struct.SetUint16(0, 10)
	s.Struct.SetUint16(8, v)
}

func (s Z) U8() uint8 {
	if s.Struct.Uint16(0) != 11 {
		panic("Which() != u8")
	}
	return s.Struct.Uint8(8)
}

func (s Z) SetU8(v uint8) {
	s.Struct.SetUint16(0, 11)
	s.Struct.SetUint8(8, v)
}

func (s Z) Bool() bool {
	if s.Struct.Uint16(0) != 12 {
		panic("Which() != bool")
	}
	return s.Struct.Bit(64)
}

func (s Z) SetBool(v bool) {
	s.Struct.SetUint16(0, 12)
	s.Struct.SetBit(64, v)
}

func (s Z) Text() (string, error) {
	if s.Struct.Uint16(0) != 13 {
		panic("Which() != text")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Z) HasText() bool {
	if s.Struct.Uint16(0) != 13 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) TextBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Z) SetText(v string) error {
	s.Struct.SetUint16(0, 13)
	return s.Struct.SetText(0, v)
}

func (s Z) Blob() ([]byte, error) {
	if s.Struct.Uint16(0) != 14 {
		panic("Which() != blob")
	}
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s Z) HasBlob() bool {
	if s.Struct.Uint16(0) != 14 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetBlob(v []byte) error {
	s.Struct.SetUint16(0, 14)
	return s.Struct.SetData(0, v)
}

func (s Z) F64vec() (capnp.Float64List, error) {
	if s.Struct.Uint16(0) != 15 {
		panic("Which() != f64vec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.Float64List{List: p.List()}, err
}

func (s Z) HasF64vec() bool {
	if s.Struct.Uint16(0) != 15 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetF64vec(v capnp.Float64List) error {
	s.Struct.SetUint16(0, 15)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewF64vec sets the f64vec field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Z) NewF64vec(n int32) (capnp.Float64List, error) {
	s.Struct.SetUint16(0, 15)
	l, err := capnp.NewFloat64List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) F32vec() (capnp.Float32List, error) {
	if s.Struct.Uint16(0) != 16 {
		panic("Which() != f32vec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.Float32List{List: p.List()}, err
}

func (s Z) HasF32vec() bool {
	if s.Struct.Uint16(0) != 16 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetF32vec(v capnp.Float32List) error {
	s.Struct.SetUint16(0, 16)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewF32vec sets the f32vec field to a newly
// allocated capnp.Float32List, preferring placement in s's segment.
func (s Z) NewF32vec(n int32) (capnp.Float32List, error) {
	s.Struct.SetUint16(0, 16)
	l, err := capnp.NewFloat32List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.Float32List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) I64vec() (capnp.Int64List, error) {
	if s.Struct.Uint16(0) != 17 {
		panic("Which() != i64vec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.Int64List{List: p.List()}, err
}

func (s Z) HasI64vec() bool {
	if s.Struct.Uint16(0) != 17 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetI64vec(v capnp.Int64List) error {
	s.Struct.SetUint16(0, 17)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewI64vec sets the i64vec field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s Z) NewI64vec(n int32) (capnp.Int64List, error) {
	s.Struct.SetUint16(0, 17)
	l, err := capnp.NewInt64List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) I32vec() (capnp.Int32List, error) {
	if s.Struct.Uint16(0) != 18 {
		panic("Which() != i32vec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.Int32List{List: p.List()}, err
}

func (s Z) HasI32vec() bool {
	if s.Struct.Uint16(0) != 18 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetI32vec(v capnp.Int32List) error {
	s.Struct.SetUint16(0, 18)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewI32vec sets the i32vec field to a newly
// allocated capnp.Int32List, preferring placement in s's segment.
func (s Z) NewI32vec(n int32) (capnp.Int32List, error) {
	s.Struct.SetUint16(0, 18)
	l, err := capnp.NewInt32List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.Int32List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) I16vec() (capnp.Int16List, error) {
	if s.Struct.Uint16(0) != 19 {
		panic("Which() != i16vec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.Int16List{List: p.List()}, err
}

func (s Z) HasI16vec() bool {
	if s.Struct.Uint16(0) != 19 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetI16vec(v capnp.Int16List) error {
	s.Struct.SetUint16(0, 19)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewI16vec sets the i16vec field to a newly
// allocated capnp.Int16List, preferring placement in s's segment.
func (s Z) NewI16vec(n int32) (capnp.Int16List, error) {
	s.Struct.SetUint16(0, 19)
	l, err := capnp.NewInt16List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.Int16List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) I8vec() (capnp.Int8List, error) {
	if s.Struct.Uint16(0) != 20 {
		panic("Which() != i8vec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.Int8List{List: p.List()}, err
}

func (s Z) HasI8vec() bool {
	if s.Struct.Uint16(0) != 20 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetI8vec(v capnp.Int8List) error {
	s.Struct.SetUint16(0, 20)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewI8vec sets the i8vec field to a newly
// allocated capnp.Int8List, preferring placement in s's segment.
func (s Z) NewI8vec(n int32) (capnp.Int8List, error) {
	s.Struct.SetUint16(0, 20)
	l, err := capnp.NewInt8List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.Int8List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) U64vec() (capnp.UInt64List, error) {
	if s.Struct.Uint16(0) != 21 {
		panic("Which() != u64vec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.UInt64List{List: p.List()}, err
}

func (s Z) HasU64vec() bool {
	if s.Struct.Uint16(0) != 21 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetU64vec(v capnp.UInt64List) error {
	s.Struct.SetUint16(0, 21)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewU64vec sets the u64vec field to a newly
// allocated capnp.UInt64List, preferring placement in s's segment.
func (s Z) NewU64vec(n int32) (capnp.UInt64List, error) {
	s.Struct.SetUint16(0, 21)
	l, err := capnp.NewUInt64List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.UInt64List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) U32vec() (capnp.UInt32List, error) {
	if s.Struct.Uint16(0) != 22 {
		panic("Which() != u32vec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.UInt32List{List: p.List()}, err
}

func (s Z) HasU32vec() bool {
	if s.Struct.Uint16(0) != 22 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetU32vec(v capnp.UInt32List) error {
	s.Struct.SetUint16(0, 22)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewU32vec sets the u32vec field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s Z) NewU32vec(n int32) (capnp.UInt32List, error) {
	s.Struct.SetUint16(0, 22)
	l, err := capnp.NewUInt32List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) U16vec() (capnp.UInt16List, error) {
	if s.Struct.Uint16(0) != 23 {
		panic("Which() != u16vec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.UInt16List{List: p.List()}, err
}

func (s Z) HasU16vec() bool {
	if s.Struct.Uint16(0) != 23 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetU16vec(v capnp.UInt16List) error {
	s.Struct.SetUint16(0, 23)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewU16vec sets the u16vec field to a newly
// allocated capnp.UInt16List, preferring placement in s's segment.
func (s Z) NewU16vec(n int32) (capnp.UInt16List, error) {
	s.Struct.SetUint16(0, 23)
	l, err := capnp.NewUInt16List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.UInt16List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) U8vec() (capnp.UInt8List, error) {
	if s.Struct.Uint16(0) != 24 {
		panic("Which() != u8vec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.UInt8List{List: p.List()}, err
}

func (s Z) HasU8vec() bool {
	if s.Struct.Uint16(0) != 24 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetU8vec(v capnp.UInt8List) error {
	s.Struct.SetUint16(0, 24)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewU8vec sets the u8vec field to a newly
// allocated capnp.UInt8List, preferring placement in s's segment.
func (s Z) NewU8vec(n int32) (capnp.UInt8List, error) {
	s.Struct.SetUint16(0, 24)
	l, err := capnp.NewUInt8List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.UInt8List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) Boolvec() (capnp.BitList, error) {
	if s.Struct.Uint16(0) != 39 {
		panic("Which() != boolvec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.BitList{List: p.List()}, err
}

func (s Z) HasBoolvec() bool {
	if s.Struct.Uint16(0) != 39 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetBoolvec(v capnp.BitList) error {
	s.Struct.SetUint16(0, 39)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewBoolvec sets the boolvec field to a newly
// allocated capnp.BitList, preferring placement in s's segment.
func (s Z) NewBoolvec(n int32) (capnp.BitList, error) {
	s.Struct.SetUint16(0, 39)
	l, err := capnp.NewBitList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.BitList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) Datavec() (capnp.DataList, error) {
	if s.Struct.Uint16(0) != 40 {
		panic("Which() != datavec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.DataList{List: p.List()}, err
}

func (s Z) HasDatavec() bool {
	if s.Struct.Uint16(0) != 40 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetDatavec(v capnp.DataList) error {
	s.Struct.SetUint16(0, 40)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewDatavec sets the datavec field to a newly
// allocated capnp.DataList, preferring placement in s's segment.
func (s Z) NewDatavec(n int32) (capnp.DataList, error) {
	s.Struct.SetUint16(0, 40)
	l, err := capnp.NewDataList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.DataList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) Textvec() (capnp.TextList, error) {
	if s.Struct.Uint16(0) != 41 {
		panic("Which() != textvec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.TextList{List: p.List()}, err
}

func (s Z) HasTextvec() bool {
	if s.Struct.Uint16(0) != 41 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetTextvec(v capnp.TextList) error {
	s.Struct.SetUint16(0, 41)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewTextvec sets the textvec field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Z) NewTextvec(n int32) (capnp.TextList, error) {
	s.Struct.SetUint16(0, 41)
	l, err := capnp.NewTextList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) Zvec() (Z_List, error) {
	if s.Struct.Uint16(0) != 25 {
		panic("Which() != zvec")
	}
	p, err := s.Struct.Ptr(0)
	return Z_List{List: p.List()}, err
}

func (s Z) HasZvec() bool {
	if s.Struct.Uint16(0) != 25 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetZvec(v Z_List) error {
	s.Struct.SetUint16(0, 25)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewZvec sets the zvec field to a newly
// allocated Z_List, preferring placement in s's segment.
func (s Z) NewZvec(n int32) (Z_List, error) {
	s.Struct.SetUint16(0, 25)
	l, err := NewZ_List(s.Struct.Segment(), n)
	if err != nil {
		return Z_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) Zvecvec() (capnp.PointerList, error) {
	if s.Struct.Uint16(0) != 26 {
		panic("Which() != zvecvec")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.PointerList{List: p.List()}, err
}

func (s Z) HasZvecvec() bool {
	if s.Struct.Uint16(0) != 26 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetZvecvec(v capnp.PointerList) error {
	s.Struct.SetUint16(0, 26)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewZvecvec sets the zvecvec field to a newly
// allocated capnp.PointerList, preferring placement in s's segment.
func (s Z) NewZvecvec(n int32) (capnp.PointerList, error) {
	s.Struct.SetUint16(0, 26)
	l, err := capnp.NewPointerList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.PointerList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) Zdate() (Zdate, error) {
	if s.Struct.Uint16(0) != 27 {
		panic("Which() != zdate")
	}
	p, err := s.Struct.Ptr(0)
	return Zdate{Struct: p.Struct()}, err
}

func (s Z) HasZdate() bool {
	if s.Struct.Uint16(0) != 27 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetZdate(v Zdate) error {
	s.Struct.SetUint16(0, 27)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewZdate sets the zdate field to a newly
// allocated Zdate struct, preferring placement in s's segment.
func (s Z) NewZdate() (Zdate, error) {
	s.Struct.SetUint16(0, 27)
	ss, err := NewZdate(s.Struct.Segment())
	if err != nil {
		return Zdate{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Zdata() (Zdata, error) {
	if s.Struct.Uint16(0) != 28 {
		panic("Which() != zdata")
	}
	p, err := s.Struct.Ptr(0)
	return Zdata{Struct: p.Struct()}, err
}

func (s Z) HasZdata() bool {
	if s.Struct.Uint16(0) != 28 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetZdata(v Zdata) error {
	s.Struct.SetUint16(0, 28)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewZdata sets the zdata field to a newly
// allocated Zdata struct, preferring placement in s's segment.
func (s Z) NewZdata() (Zdata, error) {
	s.Struct.SetUint16(0, 28)
	ss, err := NewZdata(s.Struct.Segment())
	if err != nil {
		return Zdata{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Aircraftvec() (Aircraft_List, error) {
	if s.Struct.Uint16(0) != 29 {
		panic("Which() != aircraftvec")
	}
	p, err := s.Struct.Ptr(0)
	return Aircraft_List{List: p.List()}, err
}

func (s Z) HasAircraftvec() bool {
	if s.Struct.Uint16(0) != 29 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetAircraftvec(v Aircraft_List) error {
	s.Struct.SetUint16(0, 29)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewAircraftvec sets the aircraftvec field to a newly
// allocated Aircraft_List, preferring placement in s's segment.
func (s Z) NewAircraftvec(n int32) (Aircraft_List, error) {
	s.Struct.SetUint16(0, 29)
	l, err := NewAircraft_List(s.Struct.Segment(), n)
	if err != nil {
		return Aircraft_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) Aircraft() (Aircraft, error) {
	if s.Struct.Uint16(0) != 30 {
		panic("Which() != aircraft")
	}
	p, err := s.Struct.Ptr(0)
	return Aircraft{Struct: p.Struct()}, err
}

func (s Z) HasAircraft() bool {
	if s.Struct.Uint16(0) != 30 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetAircraft(v Aircraft) error {
	s.Struct.SetUint16(0, 30)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAircraft sets the aircraft field to a newly
// allocated Aircraft struct, preferring placement in s's segment.
func (s Z) NewAircraft() (Aircraft, error) {
	s.Struct.SetUint16(0, 30)
	ss, err := NewAircraft(s.Struct.Segment())
	if err != nil {
		return Aircraft{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Regression() (Regression, error) {
	if s.Struct.Uint16(0) != 31 {
		panic("Which() != regression")
	}
	p, err := s.Struct.Ptr(0)
	return Regression{Struct: p.Struct()}, err
}

func (s Z) HasRegression() bool {
	if s.Struct.Uint16(0) != 31 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetRegression(v Regression) error {
	s.Struct.SetUint16(0, 31)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRegression sets the regression field to a newly
// allocated Regression struct, preferring placement in s's segment.
func (s Z) NewRegression() (Regression, error) {
	s.Struct.SetUint16(0, 31)
	ss, err := NewRegression(s.Struct.Segment())
	if err != nil {
		return Regression{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Planebase() (PlaneBase, error) {
	if s.Struct.Uint16(0) != 32 {
		panic("Which() != planebase")
	}
	p, err := s.Struct.Ptr(0)
	return PlaneBase{Struct: p.Struct()}, err
}

func (s Z) HasPlanebase() bool {
	if s.Struct.Uint16(0) != 32 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetPlanebase(v PlaneBase) error {
	s.Struct.SetUint16(0, 32)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPlanebase sets the planebase field to a newly
// allocated PlaneBase struct, preferring placement in s's segment.
func (s Z) NewPlanebase() (PlaneBase, error) {
	s.Struct.SetUint16(0, 32)
	ss, err := NewPlaneBase(s.Struct.Segment())
	if err != nil {
		return PlaneBase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Airport() Airport {
	if s.Struct.Uint16(0) != 33 {
		panic("Which() != airport")
	}
	return Airport(s.Struct.Uint16(8))
}

func (s Z) SetAirport(v Airport) {
	s.Struct.SetUint16(0, 33)
	s.Struct.SetUint16(8, uint16(v))
}

func (s Z) B737() (B737, error) {
	if s.Struct.Uint16(0) != 34 {
		panic("Which() != b737")
	}
	p, err := s.Struct.Ptr(0)
	return B737{Struct: p.Struct()}, err
}

func (s Z) HasB737() bool {
	if s.Struct.Uint16(0) != 34 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetB737(v B737) error {
	s.Struct.SetUint16(0, 34)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewB737 sets the b737 field to a newly
// allocated B737 struct, preferring placement in s's segment.
func (s Z) NewB737() (B737, error) {
	s.Struct.SetUint16(0, 34)
	ss, err := NewB737(s.Struct.Segment())
	if err != nil {
		return B737{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) A320() (A320, error) {
	if s.Struct.Uint16(0) != 35 {
		panic("Which() != a320")
	}
	p, err := s.Struct.Ptr(0)
	return A320{Struct: p.Struct()}, err
}

func (s Z) HasA320() bool {
	if s.Struct.Uint16(0) != 35 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetA320(v A320) error {
	s.Struct.SetUint16(0, 35)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewA320 sets the a320 field to a newly
// allocated A320 struct, preferring placement in s's segment.
func (s Z) NewA320() (A320, error) {
	s.Struct.SetUint16(0, 35)
	ss, err := NewA320(s.Struct.Segment())
	if err != nil {
		return A320{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) F16() (F16, error) {
	if s.Struct.Uint16(0) != 36 {
		panic("Which() != f16")
	}
	p, err := s.Struct.Ptr(0)
	return F16{Struct: p.Struct()}, err
}

func (s Z) HasF16() bool {
	if s.Struct.Uint16(0) != 36 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetF16(v F16) error {
	s.Struct.SetUint16(0, 36)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewF16 sets the f16 field to a newly
// allocated F16 struct, preferring placement in s's segment.
func (s Z) NewF16() (F16, error) {
	s.Struct.SetUint16(0, 36)
	ss, err := NewF16(s.Struct.Segment())
	if err != nil {
		return F16{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Zdatevec() (Zdate_List, error) {
	if s.Struct.Uint16(0) != 37 {
		panic("Which() != zdatevec")
	}
	p, err := s.Struct.Ptr(0)
	return Zdate_List{List: p.List()}, err
}

func (s Z) HasZdatevec() bool {
	if s.Struct.Uint16(0) != 37 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetZdatevec(v Zdate_List) error {
	s.Struct.SetUint16(0, 37)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewZdatevec sets the zdatevec field to a newly
// allocated Zdate_List, preferring placement in s's segment.
func (s Z) NewZdatevec(n int32) (Zdate_List, error) {
	s.Struct.SetUint16(0, 37)
	l, err := NewZdate_List(s.Struct.Segment(), n)
	if err != nil {
		return Zdate_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) Zdatavec() (Zdata_List, error) {
	if s.Struct.Uint16(0) != 38 {
		panic("Which() != zdatavec")
	}
	p, err := s.Struct.Ptr(0)
	return Zdata_List{List: p.List()}, err
}

func (s Z) HasZdatavec() bool {
	if s.Struct.Uint16(0) != 38 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetZdatavec(v Zdata_List) error {
	s.Struct.SetUint16(0, 38)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewZdatavec sets the zdatavec field to a newly
// allocated Zdata_List, preferring placement in s's segment.
func (s Z) NewZdatavec(n int32) (Zdata_List, error) {
	s.Struct.SetUint16(0, 38)
	l, err := NewZdata_List(s.Struct.Segment(), n)
	if err != nil {
		return Zdata_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) Grp() Z_grp { return Z_grp(s) }

func (s Z) SetGrp() {
	s.Struct.SetUint16(0, 42)
}

func (s Z_grp) First() uint64 {
	return s.Struct.Uint64(8)
}

func (s Z_grp) SetFirst(v uint64) {
	s.Struct.SetUint64(8, v)
}

func (s Z_grp) Second() uint64 {
	return s.Struct.Uint64(16)
}

func (s Z_grp) SetSecond(v uint64) {
	s.Struct.SetUint64(16, v)
}

func (s Z) Echo() Echo {
	if s.Struct.Uint16(0) != 43 {
		panic("Which() != echo")
	}
	p, _ := s.Struct.Ptr(0)
	return Echo{Client: p.Interface().Client()}
}

func (s Z) HasEcho() bool {
	if s.Struct.Uint16(0) != 43 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetEcho(v Echo) error {
	s.Struct.SetUint16(0, 43)
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(0, in.ToPtr())
}

func (s Z) Echoes() (capnp.PointerList, error) {
	if s.Struct.Uint16(0) != 44 {
		panic("Which() != echoes")
	}
	p, err := s.Struct.Ptr(0)
	return capnp.PointerList{List: p.List()}, err
}

func (s Z) HasEchoes() bool {
	if s.Struct.Uint16(0) != 44 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetEchoes(v capnp.PointerList) error {
	s.Struct.SetUint16(0, 44)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewEchoes sets the echoes field to a newly
// allocated capnp.PointerList, preferring placement in s's segment.
func (s Z) NewEchoes(n int32) (capnp.PointerList, error) {
	s.Struct.SetUint16(0, 44)
	l, err := capnp.NewPointerList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.PointerList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Z) AnyPtr() (capnp.Ptr, error) {
	if s.Struct.Uint16(0) != 45 {
		panic("Which() != anyPtr")
	}
	return s.Struct.Ptr(0)
}

func (s Z) HasAnyPtr() bool {
	if s.Struct.Uint16(0) != 45 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetAnyPtr(v capnp.Ptr) error {
	s.Struct.SetUint16(0, 45)
	return s.Struct.SetPtr(0, v)
}

func (s Z) AnyStruct() (capnp.Ptr, error) {
	if s.Struct.Uint16(0) != 46 {
		panic("Which() != anyStruct")
	}
	return s.Struct.Ptr(0)
}

func (s Z) HasAnyStruct() bool {
	if s.Struct.Uint16(0) != 46 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetAnyStruct(v capnp.Ptr) error {
	s.Struct.SetUint16(0, 46)
	return s.Struct.SetPtr(0, v)
}

func (s Z) AnyList() (capnp.Ptr, error) {
	if s.Struct.Uint16(0) != 47 {
		panic("Which() != anyList")
	}
	return s.Struct.Ptr(0)
}

func (s Z) HasAnyList() bool {
	if s.Struct.Uint16(0) != 47 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetAnyList(v capnp.Ptr) error {
	s.Struct.SetUint16(0, 47)
	return s.Struct.SetPtr(0, v)
}

func (s Z) AnyCapability() *capnp.Client {
	if s.Struct.Uint16(0) != 48 {
		panic("Which() != anyCapability")
	}
	p, _ := s.Struct.Ptr(0)
	return p.Interface().Client()
}

func (s Z) HasAnyCapability() bool {
	if s.Struct.Uint16(0) != 48 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s Z) SetAnyCapability(c *capnp.Client) error {
	s.Struct.SetUint16(0, 48)
	if !c.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(c))
	return s.Struct.SetPtr(0, in.ToPtr())
}

// Z_List is a list of Z.
type Z_List = capnp.StructList[Z]

// NewZ creates a new list of Z.
func NewZ_List(s *capnp.Segment, sz int32) (Z_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[Z]{List: l}, err
}

// Z_Future is a wrapper for a Z promised by a client call.
type Z_Future struct{ *capnp.Future }

func (p Z_Future) Struct() (Z, error) {
	s, err := p.Future.Struct()
	return Z{s}, err
}

func (p Z_Future) Zz() Z_Future {
	return Z_Future{Future: p.Future.Field(0, nil)}
}

func (p Z_Future) Zdate() Zdate_Future {
	return Zdate_Future{Future: p.Future.Field(0, nil)}
}

func (p Z_Future) Zdata() Zdata_Future {
	return Zdata_Future{Future: p.Future.Field(0, nil)}
}

func (p Z_Future) Aircraft() Aircraft_Future {
	return Aircraft_Future{Future: p.Future.Field(0, nil)}
}

func (p Z_Future) Regression() Regression_Future {
	return Regression_Future{Future: p.Future.Field(0, nil)}
}

func (p Z_Future) Planebase() PlaneBase_Future {
	return PlaneBase_Future{Future: p.Future.Field(0, nil)}
}

func (p Z_Future) B737() B737_Future {
	return B737_Future{Future: p.Future.Field(0, nil)}
}

func (p Z_Future) A320() A320_Future {
	return A320_Future{Future: p.Future.Field(0, nil)}
}

func (p Z_Future) F16() F16_Future {
	return F16_Future{Future: p.Future.Field(0, nil)}
}

func (p Z_Future) Grp() Z_grp_Future { return Z_grp_Future{p.Future} }

// Z_grp_Future is a wrapper for a Z_grp promised by a client call.
type Z_grp_Future struct{ *capnp.Future }

func (p Z_grp_Future) Struct() (Z_grp, error) {
	s, err := p.Future.Struct()
	return Z_grp{s}, err
}

func (p Z_Future) Echo() Echo {
	return Echo{Client: p.Future.Field(0, nil).Client()}
}

func (p Z_Future) AnyPtr() *capnp.Future {
	return p.Future.Field(0, nil)
}

func (p Z_Future) AnyStruct() *capnp.Future {
	return p.Future.Field(0, nil)
}

func (p Z_Future) AnyList() *capnp.Future {
	return p.Future.Field(0, nil)
}

func (p Z_Future) AnyCapability() *capnp.Future {
	return p.Future.Field(0, nil)
}

type Counter struct{ capnp.Struct }

// Counter_TypeID is the unique identifier for the type Counter.
const Counter_TypeID = 0x8748bc095e10cb5d

func NewCounter(s *capnp.Segment) (Counter, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return Counter{st}, err
}

func NewRootCounter(s *capnp.Segment) (Counter, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return Counter{st}, err
}

func ReadRootCounter(msg *capnp.Message) (Counter, error) {
	root, err := msg.Root()
	return Counter{root.Struct()}, err
}

func (s Counter) String() string {
	str, _ := text.Marshal(0x8748bc095e10cb5d, s.Struct)
	return str
}

func (s Counter) Size() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s Counter) SetSize(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

func (s Counter) Words() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Counter) HasWords() bool {
	return s.Struct.HasPtr(0)
}

func (s Counter) WordsBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Counter) SetWords(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Counter) Wordlist() (capnp.TextList, error) {
	p, err := s.Struct.Ptr(1)
	return capnp.TextList{List: p.List()}, err
}

func (s Counter) HasWordlist() bool {
	return s.Struct.HasPtr(1)
}

func (s Counter) SetWordlist(v capnp.TextList) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewWordlist sets the wordlist field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Counter) NewWordlist(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

func (s Counter) Bitlist() (capnp.BitList, error) {
	p, err := s.Struct.Ptr(2)
	return capnp.BitList{List: p.List()}, err
}

func (s Counter) HasBitlist() bool {
	return s.Struct.HasPtr(2)
}

func (s Counter) SetBitlist(v capnp.BitList) error {
	return s.Struct.SetPtr(2, v.List.ToPtr())
}

// NewBitlist sets the bitlist field to a newly
// allocated capnp.BitList, preferring placement in s's segment.
func (s Counter) NewBitlist(n int32) (capnp.BitList, error) {
	l, err := capnp.NewBitList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.BitList{}, err
	}
	err = s.Struct.SetPtr(2, l.List.ToPtr())
	return l, err
}

// Counter_List is a list of Counter.
type Counter_List = capnp.StructList[Counter]

// NewCounter creates a new list of Counter.
func NewCounter_List(s *capnp.Segment, sz int32) (Counter_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3}, sz)
	return capnp.StructList[Counter]{List: l}, err
}

// Counter_Future is a wrapper for a Counter promised by a client call.
type Counter_Future struct{ *capnp.Future }

func (p Counter_Future) Struct() (Counter, error) {
	s, err := p.Future.Struct()
	return Counter{s}, err
}

type Bag struct{ capnp.Struct }

// Bag_TypeID is the unique identifier for the type Bag.
const Bag_TypeID = 0xd636fba4f188dabe

func NewBag(s *capnp.Segment) (Bag, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Bag{st}, err
}

func NewRootBag(s *capnp.Segment) (Bag, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Bag{st}, err
}

func ReadRootBag(msg *capnp.Message) (Bag, error) {
	root, err := msg.Root()
	return Bag{root.Struct()}, err
}

func (s Bag) String() string {
	str, _ := text.Marshal(0xd636fba4f188dabe, s.Struct)
	return str
}

func (s Bag) Counter() (Counter, error) {
	p, err := s.Struct.Ptr(0)
	return Counter{Struct: p.Struct()}, err
}

func (s Bag) HasCounter() bool {
	return s.Struct.HasPtr(0)
}

func (s Bag) SetCounter(v Counter) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCounter sets the counter field to a newly
// allocated Counter struct, preferring placement in s's segment.
func (s Bag) NewCounter() (Counter, error) {
	ss, err := NewCounter(s.Struct.Segment())
	if err != nil {
		return Counter{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Bag_List is a list of Bag.
type Bag_List = capnp.StructList[Bag]

// NewBag creates a new list of Bag.
func NewBag_List(s *capnp.Segment, sz int32) (Bag_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Bag]{List: l}, err
}

// Bag_Future is a wrapper for a Bag promised by a client call.
type Bag_Future struct{ *capnp.Future }

func (p Bag_Future) Struct() (Bag, error) {
	s, err := p.Future.Struct()
	return Bag{s}, err
}

func (p Bag_Future) Counter() Counter_Future {
	return Counter_Future{Future: p.Future.Field(0, nil)}
}

type Zserver struct{ capnp.Struct }

// Zserver_TypeID is the unique identifier for the type Zserver.
const Zserver_TypeID = 0xcc4411e60ba9c498

func NewZserver(s *capnp.Segment) (Zserver, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Zserver{st}, err
}

func NewRootZserver(s *capnp.Segment) (Zserver, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Zserver{st}, err
}

func ReadRootZserver(msg *capnp.Message) (Zserver, error) {
	root, err := msg.Root()
	return Zserver{root.Struct()}, err
}

func (s Zserver) String() string {
	str, _ := text.Marshal(0xcc4411e60ba9c498, s.Struct)
	return str
}

func (s Zserver) Waitingjobs() (Zjob_List, error) {
	p, err := s.Struct.Ptr(0)
	return Zjob_List{List: p.List()}, err
}

func (s Zserver) HasWaitingjobs() bool {
	return s.Struct.HasPtr(0)
}

func (s Zserver) SetWaitingjobs(v Zjob_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewWaitingjobs sets the waitingjobs field to a newly
// allocated Zjob_List, preferring placement in s's segment.
func (s Zserver) NewWaitingjobs(n int32) (Zjob_List, error) {
	l, err := NewZjob_List(s.Struct.Segment(), n)
	if err != nil {
		return Zjob_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Zserver_List is a list of Zserver.
type Zserver_List = capnp.StructList[Zserver]

// NewZserver creates a new list of Zserver.
func NewZserver_List(s *capnp.Segment, sz int32) (Zserver_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Zserver]{List: l}, err
}

// Zserver_Future is a wrapper for a Zserver promised by a client call.
type Zserver_Future struct{ *capnp.Future }

func (p Zserver_Future) Struct() (Zserver, error) {
	s, err := p.Future.Struct()
	return Zserver{s}, err
}

type Zjob struct{ capnp.Struct }

// Zjob_TypeID is the unique identifier for the type Zjob.
const Zjob_TypeID = 0xddd1416669fb7613

func NewZjob(s *capnp.Segment) (Zjob, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Zjob{st}, err
}

func NewRootZjob(s *capnp.Segment) (Zjob, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Zjob{st}, err
}

func ReadRootZjob(msg *capnp.Message) (Zjob, error) {
	root, err := msg.Root()
	return Zjob{root.Struct()}, err
}

func (s Zjob) String() string {
	str, _ := text.Marshal(0xddd1416669fb7613, s.Struct)
	return str
}

func (s Zjob) Cmd() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Zjob) HasCmd() bool {
	return s.Struct.HasPtr(0)
}

func (s Zjob) CmdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Zjob) SetCmd(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Zjob) Args() (capnp.TextList, error) {
	p, err := s.Struct.Ptr(1)
	return capnp.TextList{List: p.List()}, err
}

func (s Zjob) HasArgs() bool {
	return s.Struct.HasPtr(1)
}

func (s Zjob) SetArgs(v capnp.TextList) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewArgs sets the args field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Zjob) NewArgs(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Zjob_List is a list of Zjob.
type Zjob_List = capnp.StructList[Zjob]

// NewZjob creates a new list of Zjob.
func NewZjob_List(s *capnp.Segment, sz int32) (Zjob_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Zjob]{List: l}, err
}

// Zjob_Future is a wrapper for a Zjob promised by a client call.
type Zjob_Future struct{ *capnp.Future }

func (p Zjob_Future) Struct() (Zjob, error) {
	s, err := p.Future.Struct()
	return Zjob{s}, err
}

type VerEmpty struct{ capnp.Struct }

// VerEmpty_TypeID is the unique identifier for the type VerEmpty.
const VerEmpty_TypeID = 0x93c99951eacc72ff

func NewVerEmpty(s *capnp.Segment) (VerEmpty, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return VerEmpty{st}, err
}

func NewRootVerEmpty(s *capnp.Segment) (VerEmpty, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return VerEmpty{st}, err
}

func ReadRootVerEmpty(msg *capnp.Message) (VerEmpty, error) {
	root, err := msg.Root()
	return VerEmpty{root.Struct()}, err
}

func (s VerEmpty) String() string {
	str, _ := text.Marshal(0x93c99951eacc72ff, s.Struct)
	return str
}

// VerEmpty_List is a list of VerEmpty.
type VerEmpty_List = capnp.StructList[VerEmpty]

// NewVerEmpty creates a new list of VerEmpty.
func NewVerEmpty_List(s *capnp.Segment, sz int32) (VerEmpty_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[VerEmpty]{List: l}, err
}

// VerEmpty_Future is a wrapper for a VerEmpty promised by a client call.
type VerEmpty_Future struct{ *capnp.Future }

func (p VerEmpty_Future) Struct() (VerEmpty, error) {
	s, err := p.Future.Struct()
	return VerEmpty{s}, err
}

type VerOneData struct{ capnp.Struct }

// VerOneData_TypeID is the unique identifier for the type VerOneData.
const VerOneData_TypeID = 0xfca3742893be4cde

func NewVerOneData(s *capnp.Segment) (VerOneData, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return VerOneData{st}, err
}

func NewRootVerOneData(s *capnp.Segment) (VerOneData, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return VerOneData{st}, err
}

func ReadRootVerOneData(msg *capnp.Message) (VerOneData, error) {
	root, err := msg.Root()
	return VerOneData{root.Struct()}, err
}

func (s VerOneData) String() string {
	str, _ := text.Marshal(0xfca3742893be4cde, s.Struct)
	return str
}

func (s VerOneData) Val() int16 {
	return int16(s.Struct.Uint16(0))
}

func (s VerOneData) SetVal(v int16) {
	s.Struct.SetUint16(0, uint16(v))
}

// VerOneData_List is a list of VerOneData.
type VerOneData_List = capnp.StructList[VerOneData]

// NewVerOneData creates a new list of VerOneData.
func NewVerOneData_List(s *capnp.Segment, sz int32) (VerOneData_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[VerOneData]{List: l}, err
}

// VerOneData_Future is a wrapper for a VerOneData promised by a client call.
type VerOneData_Future struct{ *capnp.Future }

func (p VerOneData_Future) Struct() (VerOneData, error) {
	s, err := p.Future.Struct()
	return VerOneData{s}, err
}

type VerTwoData struct{ capnp.Struct }

// VerTwoData_TypeID is the unique identifier for the type VerTwoData.
const VerTwoData_TypeID = 0xf705dc45c94766fd

func NewVerTwoData(s *capnp.Segment) (VerTwoData, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return VerTwoData{st}, err
}

func NewRootVerTwoData(s *capnp.Segment) (VerTwoData, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return VerTwoData{st}, err
}

func ReadRootVerTwoData(msg *capnp.Message) (VerTwoData, error) {
	root, err := msg.Root()
	return VerTwoData{root.Struct()}, err
}

func (s VerTwoData) String() string {
	str, _ := text.Marshal(0xf705dc45c94766fd, s.Struct)
	return str
}

func (s VerTwoData) Val() int16 {
	return int16(s.Struct.Uint16(0))
}

func (s VerTwoData) SetVal(v int16) {
	s.Struct.SetUint16(0, uint16(v))
}

func (s VerTwoData) Duo() int64 {
	return int64(s.Struct.Uint64(8))
}

func (s VerTwoData) SetDuo(v int64) {
	s.Struct.SetUint64(8, uint64(v))
}

// VerTwoData_List is a list of VerTwoData.
type VerTwoData_List = capnp.StructList[VerTwoData]

// NewVerTwoData creates a new list of VerTwoData.
func NewVerTwoData_List(s *capnp.Segment, sz int32) (VerTwoData_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[VerTwoData]{List: l}, err
}

// VerTwoData_Future is a wrapper for a VerTwoData promised by a client call.
type VerTwoData_Future struct{ *capnp.Future }

func (p VerTwoData_Future) Struct() (VerTwoData, error) {
	s, err := p.Future.Struct()
	return VerTwoData{s}, err
}

type VerOnePtr struct{ capnp.Struct }

// VerOnePtr_TypeID is the unique identifier for the type VerOnePtr.
const VerOnePtr_TypeID = 0x94bf7df83408218d

func NewVerOnePtr(s *capnp.Segment) (VerOnePtr, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return VerOnePtr{st}, err
}

func NewRootVerOnePtr(s *capnp.Segment) (VerOnePtr, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return VerOnePtr{st}, err
}

func ReadRootVerOnePtr(msg *capnp.Message) (VerOnePtr, error) {
	root, err := msg.Root()
	return VerOnePtr{root.Struct()}, err
}

func (s VerOnePtr) String() string {
	str, _ := text.Marshal(0x94bf7df83408218d, s.Struct)
	return str
}

func (s VerOnePtr) Ptr() (VerOneData, error) {
	p, err := s.Struct.Ptr(0)
	return VerOneData{Struct: p.Struct()}, err
}

func (s VerOnePtr) HasPtr() bool {
	return s.Struct.HasPtr(0)
}

func (s VerOnePtr) SetPtr(v VerOneData) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPtr sets the ptr field to a newly
// allocated VerOneData struct, preferring placement in s's segment.
func (s VerOnePtr) NewPtr() (VerOneData, error) {
	ss, err := NewVerOneData(s.Struct.Segment())
	if err != nil {
		return VerOneData{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// VerOnePtr_List is a list of VerOnePtr.
type VerOnePtr_List = capnp.StructList[VerOnePtr]

// NewVerOnePtr creates a new list of VerOnePtr.
func NewVerOnePtr_List(s *capnp.Segment, sz int32) (VerOnePtr_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[VerOnePtr]{List: l}, err
}

// VerOnePtr_Future is a wrapper for a VerOnePtr promised by a client call.
type VerOnePtr_Future struct{ *capnp.Future }

func (p VerOnePtr_Future) Struct() (VerOnePtr, error) {
	s, err := p.Future.Struct()
	return VerOnePtr{s}, err
}

func (p VerOnePtr_Future) Ptr() VerOneData_Future {
	return VerOneData_Future{Future: p.Future.Field(0, nil)}
}

type VerTwoPtr struct{ capnp.Struct }

// VerTwoPtr_TypeID is the unique identifier for the type VerTwoPtr.
const VerTwoPtr_TypeID = 0xc95babe3bd394d2d

func NewVerTwoPtr(s *capnp.Segment) (VerTwoPtr, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return VerTwoPtr{st}, err
}

func NewRootVerTwoPtr(s *capnp.Segment) (VerTwoPtr, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return VerTwoPtr{st}, err
}

func ReadRootVerTwoPtr(msg *capnp.Message) (VerTwoPtr, error) {
	root, err := msg.Root()
	return VerTwoPtr{root.Struct()}, err
}

func (s VerTwoPtr) String() string {
	str, _ := text.Marshal(0xc95babe3bd394d2d, s.Struct)
	return str
}

func (s VerTwoPtr) Ptr1() (VerOneData, error) {
	p, err := s.Struct.Ptr(0)
	return VerOneData{Struct: p.Struct()}, err
}

func (s VerTwoPtr) HasPtr1() bool {
	return s.Struct.HasPtr(0)
}

func (s VerTwoPtr) SetPtr1(v VerOneData) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPtr1 sets the ptr1 field to a newly
// allocated VerOneData struct, preferring placement in s's segment.
func (s VerTwoPtr) NewPtr1() (VerOneData, error) {
	ss, err := NewVerOneData(s.Struct.Segment())
	if err != nil {
		return VerOneData{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s VerTwoPtr) Ptr2() (VerOneData, error) {
	p, err := s.Struct.Ptr(1)
	return VerOneData{Struct: p.Struct()}, err
}

func (s VerTwoPtr) HasPtr2() bool {
	return s.Struct.HasPtr(1)
}

func (s VerTwoPtr) SetPtr2(v VerOneData) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewPtr2 sets the ptr2 field to a newly
// allocated VerOneData struct, preferring placement in s's segment.
func (s VerTwoPtr) NewPtr2() (VerOneData, error) {
	ss, err := NewVerOneData(s.Struct.Segment())
	if err != nil {
		return VerOneData{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// VerTwoPtr_List is a list of VerTwoPtr.
type VerTwoPtr_List = capnp.StructList[VerTwoPtr]

// NewVerTwoPtr creates a new list of VerTwoPtr.
func NewVerTwoPtr_List(s *capnp.Segment, sz int32) (VerTwoPtr_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[VerTwoPtr]{List: l}, err
}

// VerTwoPtr_Future is a wrapper for a VerTwoPtr promised by a client call.
type VerTwoPtr_Future struct{ *capnp.Future }

func (p VerTwoPtr_Future) Struct() (VerTwoPtr, error) {
	s, err := p.Future.Struct()
	return VerTwoPtr{s}, err
}

func (p VerTwoPtr_Future) Ptr1() VerOneData_Future {
	return VerOneData_Future{Future: p.Future.Field(0, nil)}
}

func (p VerTwoPtr_Future) Ptr2() VerOneData_Future {
	return VerOneData_Future{Future: p.Future.Field(1, nil)}
}

type VerTwoDataTwoPtr struct{ capnp.Struct }

// VerTwoDataTwoPtr_TypeID is the unique identifier for the type VerTwoDataTwoPtr.
const VerTwoDataTwoPtr_TypeID = 0xb61ee2ecff34ca73

func NewVerTwoDataTwoPtr(s *capnp.Segment) (VerTwoDataTwoPtr, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return VerTwoDataTwoPtr{st}, err
}

func NewRootVerTwoDataTwoPtr(s *capnp.Segment) (VerTwoDataTwoPtr, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return VerTwoDataTwoPtr{st}, err
}

func ReadRootVerTwoDataTwoPtr(msg *capnp.Message) (VerTwoDataTwoPtr, error) {
	root, err := msg.Root()
	return VerTwoDataTwoPtr{root.Struct()}, err
}

func (s VerTwoDataTwoPtr) String() string {
	str, _ := text.Marshal(0xb61ee2ecff34ca73, s.Struct)
	return str
}

func (s VerTwoDataTwoPtr) Val() int16 {
	return int16(s.Struct.Uint16(0))
}

func (s VerTwoDataTwoPtr) SetVal(v int16) {
	s.Struct.SetUint16(0, uint16(v))
}

func (s VerTwoDataTwoPtr) Duo() int64 {
	return int64(s.Struct.Uint64(8))
}

func (s VerTwoDataTwoPtr) SetDuo(v int64) {
	s.Struct.SetUint64(8, uint64(v))
}

func (s VerTwoDataTwoPtr) Ptr1() (VerOneData, error) {
	p, err := s.Struct.Ptr(0)
	return VerOneData{Struct: p.Struct()}, err
}

func (s VerTwoDataTwoPtr) HasPtr1() bool {
	return s.Struct.HasPtr(0)
}

func (s VerTwoDataTwoPtr) SetPtr1(v VerOneData) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPtr1 sets the ptr1 field to a newly
// allocated VerOneData struct, preferring placement in s's segment.
func (s VerTwoDataTwoPtr) NewPtr1() (VerOneData, error) {
	ss, err := NewVerOneData(s.Struct.Segment())
	if err != nil {
		return VerOneData{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s VerTwoDataTwoPtr) Ptr2() (VerOneData, error) {
	p, err := s.Struct.Ptr(1)
	return VerOneData{Struct: p.Struct()}, err
}

func (s VerTwoDataTwoPtr) HasPtr2() bool {
	return s.Struct.HasPtr(1)
}

func (s VerTwoDataTwoPtr) SetPtr2(v VerOneData) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewPtr2 sets the ptr2 field to a newly
// allocated VerOneData struct, preferring placement in s's segment.
func (s VerTwoDataTwoPtr) NewPtr2() (VerOneData, error) {
	ss, err := NewVerOneData(s.Struct.Segment())
	if err != nil {
		return VerOneData{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// VerTwoDataTwoPtr_List is a list of VerTwoDataTwoPtr.
type VerTwoDataTwoPtr_List = capnp.StructList[VerTwoDataTwoPtr]

// NewVerTwoDataTwoPtr creates a new list of VerTwoDataTwoPtr.
func NewVerTwoDataTwoPtr_List(s *capnp.Segment, sz int32) (VerTwoDataTwoPtr_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[VerTwoDataTwoPtr]{List: l}, err
}

// VerTwoDataTwoPtr_Future is a wrapper for a VerTwoDataTwoPtr promised by a client call.
type VerTwoDataTwoPtr_Future struct{ *capnp.Future }

func (p VerTwoDataTwoPtr_Future) Struct() (VerTwoDataTwoPtr, error) {
	s, err := p.Future.Struct()
	return VerTwoDataTwoPtr{s}, err
}

func (p VerTwoDataTwoPtr_Future) Ptr1() VerOneData_Future {
	return VerOneData_Future{Future: p.Future.Field(0, nil)}
}

func (p VerTwoDataTwoPtr_Future) Ptr2() VerOneData_Future {
	return VerOneData_Future{Future: p.Future.Field(1, nil)}
}

type HoldsVerEmptyList struct{ capnp.Struct }

// HoldsVerEmptyList_TypeID is the unique identifier for the type HoldsVerEmptyList.
const HoldsVerEmptyList_TypeID = 0xde9ed43cfaa83093

func NewHoldsVerEmptyList(s *capnp.Segment) (HoldsVerEmptyList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerEmptyList{st}, err
}

func NewRootHoldsVerEmptyList(s *capnp.Segment) (HoldsVerEmptyList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerEmptyList{st}, err
}

func ReadRootHoldsVerEmptyList(msg *capnp.Message) (HoldsVerEmptyList, error) {
	root, err := msg.Root()
	return HoldsVerEmptyList{root.Struct()}, err
}

func (s HoldsVerEmptyList) String() string {
	str, _ := text.Marshal(0xde9ed43cfaa83093, s.Struct)
	return str
}

func (s HoldsVerEmptyList) Mylist() (VerEmpty_List, error) {
	p, err := s.Struct.Ptr(0)
	return VerEmpty_List{List: p.List()}, err
}

func (s HoldsVerEmptyList) HasMylist() bool {
	return s.Struct.HasPtr(0)
}

func (s HoldsVerEmptyList) SetMylist(v VerEmpty_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerEmpty_List, preferring placement in s's segment.
func (s HoldsVerEmptyList) NewMylist(n int32) (VerEmpty_List, error) {
	l, err := NewVerEmpty_List(s.Struct.Segment(), n)
	if err != nil {
		return VerEmpty_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// HoldsVerEmptyList_List is a list of HoldsVerEmptyList.
type HoldsVerEmptyList_List = capnp.StructList[HoldsVerEmptyList]

// NewHoldsVerEmptyList creates a new list of HoldsVerEmptyList.
func NewHoldsVerEmptyList_List(s *capnp.Segment, sz int32) (HoldsVerEmptyList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerEmptyList]{List: l}, err
}

// HoldsVerEmptyList_Future is a wrapper for a HoldsVerEmptyList promised by a client call.
type HoldsVerEmptyList_Future struct{ *capnp.Future }

func (p HoldsVerEmptyList_Future) Struct() (HoldsVerEmptyList, error) {
	s, err := p.Future.Struct()
	return HoldsVerEmptyList{s}, err
}

type HoldsVerOneDataList struct{ capnp.Struct }

// HoldsVerOneDataList_TypeID is the unique identifier for the type HoldsVerOneDataList.
const HoldsVerOneDataList_TypeID = 0xabd055422a4d7df1

func NewHoldsVerOneDataList(s *capnp.Segment) (HoldsVerOneDataList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerOneDataList{st}, err
}

func NewRootHoldsVerOneDataList(s *capnp.Segment) (HoldsVerOneDataList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerOneDataList{st}, err
}

func ReadRootHoldsVerOneDataList(msg *capnp.Message) (HoldsVerOneDataList, error) {
	root, err := msg.Root()
	return HoldsVerOneDataList{root.Struct()}, err
}

func (s HoldsVerOneDataList) String() string {
	str, _ := text.Marshal(0xabd055422a4d7df1, s.Struct)
	return str
}

func (s HoldsVerOneDataList) Mylist() (VerOneData_List, error) {
	p, err := s.Struct.Ptr(0)
	return VerOneData_List{List: p.List()}, err
}

func (s HoldsVerOneDataList) HasMylist() bool {
	return s.Struct.HasPtr(0)
}

func (s HoldsVerOneDataList) SetMylist(v VerOneData_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerOneData_List, preferring placement in s's segment.
func (s HoldsVerOneDataList) NewMylist(n int32) (VerOneData_List, error) {
	l, err := NewVerOneData_List(s.Struct.Segment(), n)
	if err != nil {
		return VerOneData_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// HoldsVerOneDataList_List is a list of HoldsVerOneDataList.
type HoldsVerOneDataList_List = capnp.StructList[HoldsVerOneDataList]

// NewHoldsVerOneDataList creates a new list of HoldsVerOneDataList.
func NewHoldsVerOneDataList_List(s *capnp.Segment, sz int32) (HoldsVerOneDataList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerOneDataList]{List: l}, err
}

// HoldsVerOneDataList_Future is a wrapper for a HoldsVerOneDataList promised by a client call.
type HoldsVerOneDataList_Future struct{ *capnp.Future }

func (p HoldsVerOneDataList_Future) Struct() (HoldsVerOneDataList, error) {
	s, err := p.Future.Struct()
	return HoldsVerOneDataList{s}, err
}

type HoldsVerTwoDataList struct{ capnp.Struct }

// HoldsVerTwoDataList_TypeID is the unique identifier for the type HoldsVerTwoDataList.
const HoldsVerTwoDataList_TypeID = 0xcbdc765fd5dff7ba

func NewHoldsVerTwoDataList(s *capnp.Segment) (HoldsVerTwoDataList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoDataList{st}, err
}

func NewRootHoldsVerTwoDataList(s *capnp.Segment) (HoldsVerTwoDataList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoDataList{st}, err
}

func ReadRootHoldsVerTwoDataList(msg *capnp.Message) (HoldsVerTwoDataList, error) {
	root, err := msg.Root()
	return HoldsVerTwoDataList{root.Struct()}, err
}

func (s HoldsVerTwoDataList) String() string {
	str, _ := text.Marshal(0xcbdc765fd5dff7ba, s.Struct)
	return str
}

func (s HoldsVerTwoDataList) Mylist() (VerTwoData_List, error) {
	p, err := s.Struct.Ptr(0)
	return VerTwoData_List{List: p.List()}, err
}

func (s HoldsVerTwoDataList) HasMylist() bool {
	return s.Struct.HasPtr(0)
}

func (s HoldsVerTwoDataList) SetMylist(v VerTwoData_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerTwoData_List, preferring placement in s's segment.
func (s HoldsVerTwoDataList) NewMylist(n int32) (VerTwoData_List, error) {
	l, err := NewVerTwoData_List(s.Struct.Segment(), n)
	if err != nil {
		return VerTwoData_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// HoldsVerTwoDataList_List is a list of HoldsVerTwoDataList.
type HoldsVerTwoDataList_List = capnp.StructList[HoldsVerTwoDataList]

// NewHoldsVerTwoDataList creates a new list of HoldsVerTwoDataList.
func NewHoldsVerTwoDataList_List(s *capnp.Segment, sz int32) (HoldsVerTwoDataList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerTwoDataList]{List: l}, err
}

// HoldsVerTwoDataList_Future is a wrapper for a HoldsVerTwoDataList promised by a client call.
type HoldsVerTwoDataList_Future struct{ *capnp.Future }

func (p HoldsVerTwoDataList_Future) Struct() (HoldsVerTwoDataList, error) {
	s, err := p.Future.Struct()
	return HoldsVerTwoDataList{s}, err
}

type HoldsVerOnePtrList struct{ capnp.Struct }

// HoldsVerOnePtrList_TypeID is the unique identifier for the type HoldsVerOnePtrList.
const HoldsVerOnePtrList_TypeID = 0xe508a29c83a059f8

func NewHoldsVerOnePtrList(s *capnp.Segment) (HoldsVerOnePtrList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerOnePtrList{st}, err
}

func NewRootHoldsVerOnePtrList(s *capnp.Segment) (HoldsVerOnePtrList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerOnePtrList{st}, err
}

func ReadRootHoldsVerOnePtrList(msg *capnp.Message) (HoldsVerOnePtrList, error) {
	root, err := msg.Root()
	return HoldsVerOnePtrList{root.Struct()}, err
}

func (s HoldsVerOnePtrList) String() string {
	str, _ := text.Marshal(0xe508a29c83a059f8, s.Struct)
	return str
}

func (s HoldsVerOnePtrList) Mylist() (VerOnePtr_List, error) {
	p, err := s.Struct.Ptr(0)
	return VerOnePtr_List{List: p.List()}, err
}

func (s HoldsVerOnePtrList) HasMylist() bool {
	return s.Struct.HasPtr(0)
}

func (s HoldsVerOnePtrList) SetMylist(v VerOnePtr_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerOnePtr_List, preferring placement in s's segment.
func (s HoldsVerOnePtrList) NewMylist(n int32) (VerOnePtr_List, error) {
	l, err := NewVerOnePtr_List(s.Struct.Segment(), n)
	if err != nil {
		return VerOnePtr_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// HoldsVerOnePtrList_List is a list of HoldsVerOnePtrList.
type HoldsVerOnePtrList_List = capnp.StructList[HoldsVerOnePtrList]

// NewHoldsVerOnePtrList creates a new list of HoldsVerOnePtrList.
func NewHoldsVerOnePtrList_List(s *capnp.Segment, sz int32) (HoldsVerOnePtrList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerOnePtrList]{List: l}, err
}

// HoldsVerOnePtrList_Future is a wrapper for a HoldsVerOnePtrList promised by a client call.
type HoldsVerOnePtrList_Future struct{ *capnp.Future }

func (p HoldsVerOnePtrList_Future) Struct() (HoldsVerOnePtrList, error) {
	s, err := p.Future.Struct()
	return HoldsVerOnePtrList{s}, err
}

type HoldsVerTwoPtrList struct{ capnp.Struct }

// HoldsVerTwoPtrList_TypeID is the unique identifier for the type HoldsVerTwoPtrList.
const HoldsVerTwoPtrList_TypeID = 0xcf9beaca1cc180c8

func NewHoldsVerTwoPtrList(s *capnp.Segment) (HoldsVerTwoPtrList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoPtrList{st}, err
}

func NewRootHoldsVerTwoPtrList(s *capnp.Segment) (HoldsVerTwoPtrList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoPtrList{st}, err
}

func ReadRootHoldsVerTwoPtrList(msg *capnp.Message) (HoldsVerTwoPtrList, error) {
	root, err := msg.Root()
	return HoldsVerTwoPtrList{root.Struct()}, err
}

func (s HoldsVerTwoPtrList) String() string {
	str, _ := text.Marshal(0xcf9beaca1cc180c8, s.Struct)
	return str
}

func (s HoldsVerTwoPtrList) Mylist() (VerTwoPtr_List, error) {
	p, err := s.Struct.Ptr(0)
	return VerTwoPtr_List{List: p.List()}, err
}

func (s HoldsVerTwoPtrList) HasMylist() bool {
	return s.Struct.HasPtr(0)
}

func (s HoldsVerTwoPtrList) SetMylist(v VerTwoPtr_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerTwoPtr_List, preferring placement in s's segment.
func (s HoldsVerTwoPtrList) NewMylist(n int32) (VerTwoPtr_List, error) {
	l, err := NewVerTwoPtr_List(s.Struct.Segment(), n)
	if err != nil {
		return VerTwoPtr_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// HoldsVerTwoPtrList_List is a list of HoldsVerTwoPtrList.
type HoldsVerTwoPtrList_List = capnp.StructList[HoldsVerTwoPtrList]

// NewHoldsVerTwoPtrList creates a new list of HoldsVerTwoPtrList.
func NewHoldsVerTwoPtrList_List(s *capnp.Segment, sz int32) (HoldsVerTwoPtrList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerTwoPtrList]{List: l}, err
}

// HoldsVerTwoPtrList_Future is a wrapper for a HoldsVerTwoPtrList promised by a client call.
type HoldsVerTwoPtrList_Future struct{ *capnp.Future }

func (p HoldsVerTwoPtrList_Future) Struct() (HoldsVerTwoPtrList, error) {
	s, err := p.Future.Struct()
	return HoldsVerTwoPtrList{s}, err
}

type HoldsVerTwoTwoList struct{ capnp.Struct }

// HoldsVerTwoTwoList_TypeID is the unique identifier for the type HoldsVerTwoTwoList.
const HoldsVerTwoTwoList_TypeID = 0x95befe3f14606e6b

func NewHoldsVerTwoTwoList(s *capnp.Segment) (HoldsVerTwoTwoList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoTwoList{st}, err
}

func NewRootHoldsVerTwoTwoList(s *capnp.Segment) (HoldsVerTwoTwoList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoTwoList{st}, err
}

func ReadRootHoldsVerTwoTwoList(msg *capnp.Message) (HoldsVerTwoTwoList, error) {
	root, err := msg.Root()
	return HoldsVerTwoTwoList{root.Struct()}, err
}

func (s HoldsVerTwoTwoList) String() string {
	str, _ := text.Marshal(0x95befe3f14606e6b, s.Struct)
	return str
}

func (s HoldsVerTwoTwoList) Mylist() (VerTwoDataTwoPtr_List, error) {
	p, err := s.Struct.Ptr(0)
	return VerTwoDataTwoPtr_List{List: p.List()}, err
}

func (s HoldsVerTwoTwoList) HasMylist() bool {
	return s.Struct.HasPtr(0)
}

func (s HoldsVerTwoTwoList) SetMylist(v VerTwoDataTwoPtr_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerTwoDataTwoPtr_List, preferring placement in s's segment.
func (s HoldsVerTwoTwoList) NewMylist(n int32) (VerTwoDataTwoPtr_List, error) {
	l, err := NewVerTwoDataTwoPtr_List(s.Struct.Segment(), n)
	if err != nil {
		return VerTwoDataTwoPtr_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// HoldsVerTwoTwoList_List is a list of HoldsVerTwoTwoList.
type HoldsVerTwoTwoList_List = capnp.StructList[HoldsVerTwoTwoList]

// NewHoldsVerTwoTwoList creates a new list of HoldsVerTwoTwoList.
func NewHoldsVerTwoTwoList_List(s *capnp.Segment, sz int32) (HoldsVerTwoTwoList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerTwoTwoList]{List: l}, err
}

// HoldsVerTwoTwoList_Future is a wrapper for a HoldsVerTwoTwoList promised by a client call.
type HoldsVerTwoTwoList_Future struct{ *capnp.Future }

func (p HoldsVerTwoTwoList_Future) Struct() (HoldsVerTwoTwoList, error) {
	s, err := p.Future.Struct()
	return HoldsVerTwoTwoList{s}, err
}

type HoldsVerTwoTwoPlus struct{ capnp.Struct }

// HoldsVerTwoTwoPlus_TypeID is the unique identifier for the type HoldsVerTwoTwoPlus.
const HoldsVerTwoTwoPlus_TypeID = 0x87c33f2330feb3d8

func NewHoldsVerTwoTwoPlus(s *capnp.Segment) (HoldsVerTwoTwoPlus, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoTwoPlus{st}, err
}

func NewRootHoldsVerTwoTwoPlus(s *capnp.Segment) (HoldsVerTwoTwoPlus, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoTwoPlus{st}, err
}

func ReadRootHoldsVerTwoTwoPlus(msg *capnp.Message) (HoldsVerTwoTwoPlus, error) {
	root, err := msg.Root()
	return HoldsVerTwoTwoPlus{root.Struct()}, err
}

func (s HoldsVerTwoTwoPlus) String() string {
	str, _ := text.Marshal(0x87c33f2330feb3d8, s.Struct)
	return str
}

func (s HoldsVerTwoTwoPlus) Mylist() (VerTwoTwoPlus_List, error) {
	p, err := s.Struct.Ptr(0)
	return VerTwoTwoPlus_List{List: p.List()}, err
}

func (s HoldsVerTwoTwoPlus) HasMylist() bool {
	return s.Struct.HasPtr(0)
}

func (s HoldsVerTwoTwoPlus) SetMylist(v VerTwoTwoPlus_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerTwoTwoPlus_List, preferring placement in s's segment.
func (s HoldsVerTwoTwoPlus) NewMylist(n int32) (VerTwoTwoPlus_List, error) {
	l, err := NewVerTwoTwoPlus_List(s.Struct.Segment(), n)
	if err != nil {
		return VerTwoTwoPlus_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// HoldsVerTwoTwoPlus_List is a list of HoldsVerTwoTwoPlus.
type HoldsVerTwoTwoPlus_List = capnp.StructList[HoldsVerTwoTwoPlus]

// NewHoldsVerTwoTwoPlus creates a new list of HoldsVerTwoTwoPlus.
func NewHoldsVerTwoTwoPlus_List(s *capnp.Segment, sz int32) (HoldsVerTwoTwoPlus_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerTwoTwoPlus]{List: l}, err
}

// HoldsVerTwoTwoPlus_Future is a wrapper for a HoldsVerTwoTwoPlus promised by a client call.
type HoldsVerTwoTwoPlus_Future struct{ *capnp.Future }

func (p HoldsVerTwoTwoPlus_Future) Struct() (HoldsVerTwoTwoPlus, error) {
	s, err := p.Future.Struct()
	return HoldsVerTwoTwoPlus{s}, err
}

type VerTwoTwoPlus struct{ capnp.Struct }

// VerTwoTwoPlus_TypeID is the unique identifier for the type VerTwoTwoPlus.
const VerTwoTwoPlus_TypeID = 0xce44aee2d9e25049

func NewVerTwoTwoPlus(s *capnp.Segment) (VerTwoTwoPlus, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3})
	return VerTwoTwoPlus{st}, err
}

func NewRootVerTwoTwoPlus(s *capnp.Segment) (VerTwoTwoPlus, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3})
	return VerTwoTwoPlus{st}, err
}

func ReadRootVerTwoTwoPlus(msg *capnp.Message) (VerTwoTwoPlus, error) {
	root, err := msg.Root()
	return VerTwoTwoPlus{root.Struct()}, err
}

func (s VerTwoTwoPlus) String() string {
	str, _ := text.Marshal(0xce44aee2d9e25049, s.Struct)
	return str
}

func (s VerTwoTwoPlus) Val() int16 {
	return int16(s.Struct.Uint16(0))
}

func (s VerTwoTwoPlus) SetVal(v int16) {
	s.Struct.SetUint16(0, uint16(v))
}

func (s VerTwoTwoPlus) Duo() int64 {
	return int64(s.Struct.Uint64(8))
}

func (s VerTwoTwoPlus) SetDuo(v int64) {
	s.Struct.SetUint64(8, uint64(v))
}

func (s VerTwoTwoPlus) Ptr1() (VerTwoDataTwoPtr, error) {
	p, err := s.Struct.Ptr(0)
	return VerTwoDataTwoPtr{Struct: p.Struct()}, err
}

func (s VerTwoTwoPlus) HasPtr1() bool {
	return s.Struct.HasPtr(0)
}

func (s VerTwoTwoPlus) SetPtr1(v VerTwoDataTwoPtr) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPtr1 sets the ptr1 field to a newly
// allocated VerTwoDataTwoPtr struct, preferring placement in s's segment.
func (s VerTwoTwoPlus) NewPtr1() (VerTwoDataTwoPtr, error) {
	ss, err := NewVerTwoDataTwoPtr(s.Struct.Segment())
	if err != nil {
		return VerTwoDataTwoPtr{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s VerTwoTwoPlus) Ptr2() (VerTwoDataTwoPtr, error) {
	p, err := s.Struct.Ptr(1)
	return VerTwoDataTwoPtr{Struct: p.Struct()}, err
}

func (s VerTwoTwoPlus) HasPtr2() bool {
	return s.Struct.HasPtr(1)
}

func (s VerTwoTwoPlus) SetPtr2(v VerTwoDataTwoPtr) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewPtr2 sets the ptr2 field to a newly
// allocated VerTwoDataTwoPtr struct, preferring placement in s's segment.
func (s VerTwoTwoPlus) NewPtr2() (VerTwoDataTwoPtr, error) {
	ss, err := NewVerTwoDataTwoPtr(s.Struct.Segment())
	if err != nil {
		return VerTwoDataTwoPtr{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s VerTwoTwoPlus) Tre() int64 {
	return int64(s.Struct.Uint64(16))
}

func (s VerTwoTwoPlus) SetTre(v int64) {
	s.Struct.SetUint64(16, uint64(v))
}

func (s VerTwoTwoPlus) Lst3() (capnp.Int64List, error) {
	p, err := s.Struct.Ptr(2)
	return capnp.Int64List{List: p.List()}, err
}

func (s VerTwoTwoPlus) HasLst3() bool {
	return s.Struct.HasPtr(2)
}

func (s VerTwoTwoPlus) SetLst3(v capnp.Int64List) error {
	return s.Struct.SetPtr(2, v.List.ToPtr())
}

// NewLst3 sets the lst3 field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s VerTwoTwoPlus) NewLst3(n int32) (capnp.Int64List, error) {
	l, err := capnp.NewInt64List(s.Struct.Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = s.Struct.SetPtr(2, l.List.ToPtr())
	return l, err
}

// VerTwoTwoPlus_List is a list of VerTwoTwoPlus.
type VerTwoTwoPlus_List = capnp.StructList[VerTwoTwoPlus]

// NewVerTwoTwoPlus creates a new list of VerTwoTwoPlus.
func NewVerTwoTwoPlus_List(s *capnp.Segment, sz int32) (VerTwoTwoPlus_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3}, sz)
	return capnp.StructList[VerTwoTwoPlus]{List: l}, err
}

// VerTwoTwoPlus_Future is a wrapper for a VerTwoTwoPlus promised by a client call.
type VerTwoTwoPlus_Future struct{ *capnp.Future }

func (p VerTwoTwoPlus_Future) Struct() (VerTwoTwoPlus, error) {
	s, err := p.Future.Struct()
	return VerTwoTwoPlus{s}, err
}

func (p VerTwoTwoPlus_Future) Ptr1() VerTwoDataTwoPtr_Future {
	return VerTwoDataTwoPtr_Future{Future: p.Future.Field(0, nil)}
}

func (p VerTwoTwoPlus_Future) Ptr2() VerTwoDataTwoPtr_Future {
	return VerTwoDataTwoPtr_Future{Future: p.Future.Field(1, nil)}
}

type HoldsText struct{ capnp.Struct }

// HoldsText_TypeID is the unique identifier for the type HoldsText.
const HoldsText_TypeID = 0xe5817f849ff906dc

func NewHoldsText(s *capnp.Segment) (HoldsText, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return HoldsText{st}, err
}

func NewRootHoldsText(s *capnp.Segment) (HoldsText, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return HoldsText{st}, err
}

func ReadRootHoldsText(msg *capnp.Message) (HoldsText, error) {
	root, err := msg.Root()
	return HoldsText{root.Struct()}, err
}

func (s HoldsText) String() string {
	str, _ := text.Marshal(0xe5817f849ff906dc, s.Struct)
	return str
}

func (s HoldsText) Txt() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s HoldsText) HasTxt() bool {
	return s.Struct.HasPtr(0)
}

func (s HoldsText) TxtBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s HoldsText) SetTxt(v string) error {
	return s.Struct.SetText(0, v)
}

func (s HoldsText) Lst() (capnp.TextList, error) {
	p, err := s.Struct.Ptr(1)
	return capnp.TextList{List: p.List()}, err
}

func (s HoldsText) HasLst() bool {
	return s.Struct.HasPtr(1)
}

func (s HoldsText) SetLst(v capnp.TextList) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewLst sets the lst field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s HoldsText) NewLst(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

func (s HoldsText) Lstlst() (capnp.PointerList, error) {
	p, err := s.Struct.Ptr(2)
	return capnp.PointerList{List: p.List()}, err
}

func (s HoldsText) HasLstlst() bool {
	return s.Struct.HasPtr(2)
}

func (s HoldsText) SetLstlst(v capnp.PointerList) error {
	return s.Struct.SetPtr(2, v.List.ToPtr())
}

// NewLstlst sets the lstlst field to a newly
// allocated capnp.PointerList, preferring placement in s's segment.
func (s HoldsText) NewLstlst(n int32) (capnp.PointerList, error) {
	l, err := capnp.NewPointerList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.PointerList{}, err
	}
	err = s.Struct.SetPtr(2, l.List.ToPtr())
	return l, err
}

// HoldsText_List is a list of HoldsText.
type HoldsText_List = capnp.StructList[HoldsText]

// NewHoldsText creates a new list of HoldsText.
func NewHoldsText_List(s *capnp.Segment, sz int32) (HoldsText_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[HoldsText]{List: l}, err
}

// HoldsText_Future is a wrapper for a HoldsText promised by a client call.
type HoldsText_Future struct{ *capnp.Future }

func (p HoldsText_Future) Struct() (HoldsText, error) {
	s, err := p.Future.Struct()
	return HoldsText{s}, err
}

type WrapEmpty struct{ capnp.Struct }

// WrapEmpty_TypeID is the unique identifier for the type WrapEmpty.
const WrapEmpty_TypeID = 0x9ab599979b02ac59

func NewWrapEmpty(s *capnp.Segment) (WrapEmpty, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return WrapEmpty{st}, err
}

func NewRootWrapEmpty(s *capnp.Segment) (WrapEmpty, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return WrapEmpty{st}, err
}

func ReadRootWrapEmpty(msg *capnp.Message) (WrapEmpty, error) {
	root, err := msg.Root()
	return WrapEmpty{root.Struct()}, err
}

func (s WrapEmpty) String() string {
	str, _ := text.Marshal(0x9ab599979b02ac59, s.Struct)
	return str
}

func (s WrapEmpty) MightNotBeReallyEmpty() (VerEmpty, error) {
	p, err := s.Struct.Ptr(0)
	return VerEmpty{Struct: p.Struct()}, err
}

func (s WrapEmpty) HasMightNotBeReallyEmpty() bool {
	return s.Struct.HasPtr(0)
}

func (s WrapEmpty) SetMightNotBeReallyEmpty(v VerEmpty) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMightNotBeReallyEmpty sets the mightNotBeReallyEmpty field to a newly
// allocated VerEmpty struct, preferring placement in s's segment.
func (s WrapEmpty) NewMightNotBeReallyEmpty() (VerEmpty, error) {
	ss, err := NewVerEmpty(s.Struct.Segment())
	if err != nil {
		return VerEmpty{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// WrapEmpty_List is a list of WrapEmpty.
type WrapEmpty_List = capnp.StructList[WrapEmpty]

// NewWrapEmpty creates a new list of WrapEmpty.
func NewWrapEmpty_List(s *capnp.Segment, sz int32) (WrapEmpty_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[WrapEmpty]{List: l}, err
}

// WrapEmpty_Future is a wrapper for a WrapEmpty promised by a client call.
type WrapEmpty_Future struct{ *capnp.Future }

func (p WrapEmpty_Future) Struct() (WrapEmpty, error) {
	s, err := p.Future.Struct()
	return WrapEmpty{s}, err
}

func (p WrapEmpty_Future) MightNotBeReallyEmpty() VerEmpty_Future {
	return VerEmpty_Future{Future: p.Future.Field(0, nil)}
}

type Wrap2x2 struct{ capnp.Struct }

// Wrap2x2_TypeID is the unique identifier for the type Wrap2x2.
const Wrap2x2_TypeID = 0xe1a2d1d51107bead

func NewWrap2x2(s *capnp.Segment) (Wrap2x2, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Wrap2x2{st}, err
}

func NewRootWrap2x2(s *capnp.Segment) (Wrap2x2, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Wrap2x2{st}, err
}

func ReadRootWrap2x2(msg *capnp.Message) (Wrap2x2, error) {
	root, err := msg.Root()
	return Wrap2x2{root.Struct()}, err
}

func (s Wrap2x2) String() string {
	str, _ := text.Marshal(0xe1a2d1d51107bead, s.Struct)
	return str
}

func (s Wrap2x2) MightNotBeReallyEmpty() (VerTwoDataTwoPtr, error) {
	p, err := s.Struct.Ptr(0)
	return VerTwoDataTwoPtr{Struct: p.Struct()}, err
}

func (s Wrap2x2) HasMightNotBeReallyEmpty() bool {
	return s.Struct.HasPtr(0)
}

func (s Wrap2x2) SetMightNotBeReallyEmpty(v VerTwoDataTwoPtr) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMightNotBeReallyEmpty sets the mightNotBeReallyEmpty field to a newly
// allocated VerTwoDataTwoPtr struct, preferring placement in s's segment.
func (s Wrap2x2) NewMightNotBeReallyEmpty() (VerTwoDataTwoPtr, error) {
	ss, err := NewVerTwoDataTwoPtr(s.Struct.Segment())
	if err != nil {
		return VerTwoDataTwoPtr{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Wrap2x2_List is a list of Wrap2x2.
type Wrap2x2_List = capnp.StructList[Wrap2x2]

// NewWrap2x2 creates a new list of Wrap2x2.
func NewWrap2x2_List(s *capnp.Segment, sz int32) (Wrap2x2_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Wrap2x2]{List: l}, err
}

// Wrap2x2_Future is a wrapper for a Wrap2x2 promised by a client call.
type Wrap2x2_Future struct{ *capnp.Future }

func (p Wrap2x2_Future) Struct() (Wrap2x2, error) {
	s, err := p.Future.Struct()
	return Wrap2x2{s}, err
}

func (p Wrap2x2_Future) MightNotBeReallyEmpty() VerTwoDataTwoPtr_Future {
	return VerTwoDataTwoPtr_Future{Future: p.Future.Field(0, nil)}
}

type Wrap2x2plus struct{ capnp.Struct }

// Wrap2x2plus_TypeID is the unique identifier for the type Wrap2x2plus.
const Wrap2x2plus_TypeID = 0xe684eb3aef1a6859

func NewWrap2x2plus(s *capnp.Segment) (Wrap2x2plus, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Wrap2x2plus{st}, err
}

func NewRootWrap2x2plus(s *capnp.Segment) (Wrap2x2plus, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Wrap2x2plus{st}, err
}

func ReadRootWrap2x2plus(msg *capnp.Message) (Wrap2x2plus, error) {
	root, err := msg.Root()
	return Wrap2x2plus{root.Struct()}, err
}

func (s Wrap2x2plus) String() string {
	str, _ := text.Marshal(0xe684eb3aef1a6859, s.Struct)
	return str
}

func (s Wrap2x2plus) MightNotBeReallyEmpty() (VerTwoTwoPlus, error) {
	p, err := s.Struct.Ptr(0)
	return VerTwoTwoPlus{Struct: p.Struct()}, err
}

func (s Wrap2x2plus) HasMightNotBeReallyEmpty() bool {
	return s.Struct.HasPtr(0)
}

func (s Wrap2x2plus) SetMightNotBeReallyEmpty(v VerTwoTwoPlus) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMightNotBeReallyEmpty sets the mightNotBeReallyEmpty field to a newly
// allocated VerTwoTwoPlus struct, preferring placement in s's segment.
func (s Wrap2x2plus) NewMightNotBeReallyEmpty() (VerTwoTwoPlus, error) {
	ss, err := NewVerTwoTwoPlus(s.Struct.Segment())
	if err != nil {
		return VerTwoTwoPlus{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Wrap2x2plus_List is a list of Wrap2x2plus.
type Wrap2x2plus_List = capnp.StructList[Wrap2x2plus]

// NewWrap2x2plus creates a new list of Wrap2x2plus.
func NewWrap2x2plus_List(s *capnp.Segment, sz int32) (Wrap2x2plus_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Wrap2x2plus]{List: l}, err
}

// Wrap2x2plus_Future is a wrapper for a Wrap2x2plus promised by a client call.
type Wrap2x2plus_Future struct{ *capnp.Future }

func (p Wrap2x2plus_Future) Struct() (Wrap2x2plus, error) {
	s, err := p.Future.Struct()
	return Wrap2x2plus{s}, err
}

func (p Wrap2x2plus_Future) MightNotBeReallyEmpty() VerTwoTwoPlus_Future {
	return VerTwoTwoPlus_Future{Future: p.Future.Field(0, nil)}
}

type VoidUnion struct{ capnp.Struct }
type VoidUnion_Which uint16

const (
	VoidUnion_Which_a VoidUnion_Which = 0
	VoidUnion_Which_b VoidUnion_Which = 1
)

func (w VoidUnion_Which) String() string {
	const s = "ab"
	switch w {
	case VoidUnion_Which_a:
		return s[0:1]
	case VoidUnion_Which_b:
		return s[1:2]

	}
	return "VoidUnion_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// VoidUnion_TypeID is the unique identifier for the type VoidUnion.
const VoidUnion_TypeID = 0x8821cdb23640783a

func NewVoidUnion(s *capnp.Segment) (VoidUnion, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return VoidUnion{st}, err
}

func NewRootVoidUnion(s *capnp.Segment) (VoidUnion, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return VoidUnion{st}, err
}

func ReadRootVoidUnion(msg *capnp.Message) (VoidUnion, error) {
	root, err := msg.Root()
	return VoidUnion{root.Struct()}, err
}

func (s VoidUnion) String() string {
	str, _ := text.Marshal(0x8821cdb23640783a, s.Struct)
	return str
}

func (s VoidUnion) Which() VoidUnion_Which {
	return VoidUnion_Which(s.Struct.Uint16(0))
}
func (s VoidUnion) SetA() {
	s.Struct.SetUint16(0, 0)

}

func (s VoidUnion) SetB() {
	s.Struct.SetUint16(0, 1)

}

// VoidUnion_List is a list of VoidUnion.
type VoidUnion_List = capnp.StructList[VoidUnion]

// NewVoidUnion creates a new list of VoidUnion.
func NewVoidUnion_List(s *capnp.Segment, sz int32) (VoidUnion_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[VoidUnion]{List: l}, err
}

// VoidUnion_Future is a wrapper for a VoidUnion promised by a client call.
type VoidUnion_Future struct{ *capnp.Future }

func (p VoidUnion_Future) Struct() (VoidUnion, error) {
	s, err := p.Future.Struct()
	return VoidUnion{s}, err
}

type Nester1Capn struct{ capnp.Struct }

// Nester1Capn_TypeID is the unique identifier for the type Nester1Capn.
const Nester1Capn_TypeID = 0xf14fad09425d081c

func NewNester1Capn(s *capnp.Segment) (Nester1Capn, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Nester1Capn{st}, err
}

func NewRootNester1Capn(s *capnp.Segment) (Nester1Capn, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Nester1Capn{st}, err
}

func ReadRootNester1Capn(msg *capnp.Message) (Nester1Capn, error) {
	root, err := msg.Root()
	return Nester1Capn{root.Struct()}, err
}

func (s Nester1Capn) String() string {
	str, _ := text.Marshal(0xf14fad09425d081c, s.Struct)
	return str
}

func (s Nester1Capn) Strs() (capnp.TextList, error) {
	p, err := s.Struct.Ptr(0)
	return capnp.TextList{List: p.List()}, err
}

func (s Nester1Capn) HasStrs() bool {
	return s.Struct.HasPtr(0)
}

func (s Nester1Capn) SetStrs(v capnp.TextList) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewStrs sets the strs field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Nester1Capn) NewStrs(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Nester1Capn_List is a list of Nester1Capn.
type Nester1Capn_List = capnp.StructList[Nester1Capn]

// NewNester1Capn creates a new list of Nester1Capn.
func NewNester1Capn_List(s *capnp.Segment, sz int32) (Nester1Capn_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Nester1Capn]{List: l}, err
}

// Nester1Capn_Future is a wrapper for a Nester1Capn promised by a client call.
type Nester1Capn_Future struct{ *capnp.Future }

func (p Nester1Capn_Future) Struct() (Nester1Capn, error) {
	s, err := p.Future.Struct()
	return Nester1Capn{s}, err
}

type RWTestCapn struct{ capnp.Struct }

// RWTestCapn_TypeID is the unique identifier for the type RWTestCapn.
const RWTestCapn_TypeID = 0xf7ff4414476c186a

func NewRWTestCapn(s *capnp.Segment) (RWTestCapn, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RWTestCapn{st}, err
}

func NewRootRWTestCapn(s *capnp.Segment) (RWTestCapn, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RWTestCapn{st}, err
}

func ReadRootRWTestCapn(msg *capnp.Message) (RWTestCapn, error) {
	root, err := msg.Root()
	return RWTestCapn{root.Struct()}, err
}

func (s RWTestCapn) String() string {
	str, _ := text.Marshal(0xf7ff4414476c186a, s.Struct)
	return str
}

func (s RWTestCapn) NestMatrix() (capnp.PointerList, error) {
	p, err := s.Struct.Ptr(0)
	return capnp.PointerList{List: p.List()}, err
}

func (s RWTestCapn) HasNestMatrix() bool {
	return s.Struct.HasPtr(0)
}

func (s RWTestCapn) SetNestMatrix(v capnp.PointerList) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewNestMatrix sets the nestMatrix field to a newly
// allocated capnp.PointerList, preferring placement in s's segment.
func (s RWTestCapn) NewNestMatrix(n int32) (capnp.PointerList, error) {
	l, err := capnp.NewPointerList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.PointerList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// RWTestCapn_List is a list of RWTestCapn.
type RWTestCapn_List = capnp.StructList[RWTestCapn]

// NewRWTestCapn creates a new list of RWTestCapn.
func NewRWTestCapn_List(s *capnp.Segment, sz int32) (RWTestCapn_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[RWTestCapn]{List: l}, err
}

// RWTestCapn_Future is a wrapper for a RWTestCapn promised by a client call.
type RWTestCapn_Future struct{ *capnp.Future }

func (p RWTestCapn_Future) Struct() (RWTestCapn, error) {
	s, err := p.Future.Struct()
	return RWTestCapn{s}, err
}

type ListStructCapn struct{ capnp.Struct }

// ListStructCapn_TypeID is the unique identifier for the type ListStructCapn.
const ListStructCapn_TypeID = 0xb1ac056ed7647011

func NewListStructCapn(s *capnp.Segment) (ListStructCapn, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ListStructCapn{st}, err
}

func NewRootListStructCapn(s *capnp.Segment) (ListStructCapn, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ListStructCapn{st}, err
}

func ReadRootListStructCapn(msg *capnp.Message) (ListStructCapn, error) {
	root, err := msg.Root()
	return ListStructCapn{root.Struct()}, err
}

func (s ListStructCapn) String() string {
	str, _ := text.Marshal(0xb1ac056ed7647011, s.Struct)
	return str
}

func (s ListStructCapn) Vec() (Nester1Capn_List, error) {
	p, err := s.Struct.Ptr(0)
	return Nester1Capn_List{List: p.List()}, err
}

func (s ListStructCapn) HasVec() bool {
	return s.Struct.HasPtr(0)
}

func (s ListStructCapn) SetVec(v Nester1Capn_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewVec sets the vec field to a newly
// allocated Nester1Capn_List, preferring placement in s's segment.
func (s ListStructCapn) NewVec(n int32) (Nester1Capn_List, error) {
	l, err := NewNester1Capn_List(s.Struct.Segment(), n)
	if err != nil {
		return Nester1Capn_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// ListStructCapn_List is a list of ListStructCapn.
type ListStructCapn_List = capnp.StructList[ListStructCapn]

// NewListStructCapn creates a new list of ListStructCapn.
func NewListStructCapn_List(s *capnp.Segment, sz int32) (ListStructCapn_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[ListStructCapn]{List: l}, err
}

// ListStructCapn_Future is a wrapper for a ListStructCapn promised by a client call.
type ListStructCapn_Future struct{ *capnp.Future }

func (p ListStructCapn_Future) Struct() (ListStructCapn, error) {
	s, err := p.Future.Struct()
	return ListStructCapn{s}, err
}

type Echo struct{ Client *capnp.Client }

// Echo_TypeID is the unique identifier for the type Echo.
const Echo_TypeID = 0x8e5322c1e9282534

func (c Echo) Echo(ctx context.Context, params func(Echo_echo_Params) error) (Echo_echo_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8e5322c1e9282534,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:Echo",
			MethodName:    "echo",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Echo_echo_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Echo_echo_Results_Future{Future: ans.Future()}, release
}

func (c Echo) AddRef() Echo {
	return Echo{
		Client: c.Client.AddRef(),
	}
}

func (c Echo) Release() {
	c.Client.Release()
}

// A Echo_Server is a Echo with a local implementation.
type Echo_Server interface {
	Echo(context.Context, Echo_echo) error
}

// Echo_NewServer creates a new Server from an implementation of Echo_Server.
func Echo_NewServer(s Echo_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Echo_Methods(nil, s), s, c, policy)
}

// Echo_ServerToClient creates a new Client from an implementation of Echo_Server.
// The caller is responsible for calling Release on the returned Client.
func Echo_ServerToClient(s Echo_Server, policy *server.Policy) Echo {
	return Echo{Client: capnp.NewClient(Echo_NewServer(s, policy))}
}

// Echo_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Echo_Methods(methods []server.Method, s Echo_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8e5322c1e9282534,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:Echo",
			MethodName:    "echo",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Echo(ctx, Echo_echo{call})
		},
	})

	return methods
}

// Echo_echo holds the state for a server call to Echo.echo.
// See server.Call for documentation.
type Echo_echo struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Echo_echo) Args() Echo_echo_Params {
	return Echo_echo_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Echo_echo) AllocResults() (Echo_echo_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Echo_echo_Results{Struct: r}, err
}

type Echo_echo_Params struct{ capnp.Struct }

// Echo_echo_Params_TypeID is the unique identifier for the type Echo_echo_Params.
const Echo_echo_Params_TypeID = 0x8a165fb4d71bf3a2

func NewEcho_echo_Params(s *capnp.Segment) (Echo_echo_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Echo_echo_Params{st}, err
}

func NewRootEcho_echo_Params(s *capnp.Segment) (Echo_echo_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Echo_echo_Params{st}, err
}

func ReadRootEcho_echo_Params(msg *capnp.Message) (Echo_echo_Params, error) {
	root, err := msg.Root()
	return Echo_echo_Params{root.Struct()}, err
}

func (s Echo_echo_Params) String() string {
	str, _ := text.Marshal(0x8a165fb4d71bf3a2, s.Struct)
	return str
}

func (s Echo_echo_Params) In() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Echo_echo_Params) HasIn() bool {
	return s.Struct.HasPtr(0)
}

func (s Echo_echo_Params) InBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Echo_echo_Params) SetIn(v string) error {
	return s.Struct.SetText(0, v)
}

// Echo_echo_Params_List is a list of Echo_echo_Params.
type Echo_echo_Params_List = capnp.StructList[Echo_echo_Params]

// NewEcho_echo_Params creates a new list of Echo_echo_Params.
func NewEcho_echo_Params_List(s *capnp.Segment, sz int32) (Echo_echo_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Echo_echo_Params]{List: l}, err
}

// Echo_echo_Params_Future is a wrapper for a Echo_echo_Params promised by a client call.
type Echo_echo_Params_Future struct{ *capnp.Future }

func (p Echo_echo_Params_Future) Struct() (Echo_echo_Params, error) {
	s, err := p.Future.Struct()
	return Echo_echo_Params{s}, err
}

type Echo_echo_Results struct{ capnp.Struct }

// Echo_echo_Results_TypeID is the unique identifier for the type Echo_echo_Results.
const Echo_echo_Results_TypeID = 0x9b37d729b9dd7b9d

func NewEcho_echo_Results(s *capnp.Segment) (Echo_echo_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Echo_echo_Results{st}, err
}

func NewRootEcho_echo_Results(s *capnp.Segment) (Echo_echo_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Echo_echo_Results{st}, err
}

func ReadRootEcho_echo_Results(msg *capnp.Message) (Echo_echo_Results, error) {
	root, err := msg.Root()
	return Echo_echo_Results{root.Struct()}, err
}

func (s Echo_echo_Results) String() string {
	str, _ := text.Marshal(0x9b37d729b9dd7b9d, s.Struct)
	return str
}

func (s Echo_echo_Results) Out() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Echo_echo_Results) HasOut() bool {
	return s.Struct.HasPtr(0)
}

func (s Echo_echo_Results) OutBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Echo_echo_Results) SetOut(v string) error {
	return s.Struct.SetText(0, v)
}

// Echo_echo_Results_List is a list of Echo_echo_Results.
type Echo_echo_Results_List = capnp.StructList[Echo_echo_Results]

// NewEcho_echo_Results creates a new list of Echo_echo_Results.
func NewEcho_echo_Results_List(s *capnp.Segment, sz int32) (Echo_echo_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Echo_echo_Results]{List: l}, err
}

// Echo_echo_Results_Future is a wrapper for a Echo_echo_Results promised by a client call.
type Echo_echo_Results_Future struct{ *capnp.Future }

func (p Echo_echo_Results_Future) Struct() (Echo_echo_Results, error) {
	s, err := p.Future.Struct()
	return Echo_echo_Results{s}, err
}

type Hoth struct{ capnp.Struct }

// Hoth_TypeID is the unique identifier for the type Hoth.
const Hoth_TypeID = 0xad87da456fb0ebb9

func NewHoth(s *capnp.Segment) (Hoth, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Hoth{st}, err
}

func NewRootHoth(s *capnp.Segment) (Hoth, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Hoth{st}, err
}

func ReadRootHoth(msg *capnp.Message) (Hoth, error) {
	root, err := msg.Root()
	return Hoth{root.Struct()}, err
}

func (s Hoth) String() string {
	str, _ := text.Marshal(0xad87da456fb0ebb9, s.Struct)
	return str
}

func (s Hoth) Base() (EchoBase, error) {
	p, err := s.Struct.Ptr(0)
	return EchoBase{Struct: p.Struct()}, err
}

func (s Hoth) HasBase() bool {
	return s.Struct.HasPtr(0)
}

func (s Hoth) SetBase(v EchoBase) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBase sets the base field to a newly
// allocated EchoBase struct, preferring placement in s's segment.
func (s Hoth) NewBase() (EchoBase, error) {
	ss, err := NewEchoBase(s.Struct.Segment())
	if err != nil {
		return EchoBase{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Hoth_List is a list of Hoth.
type Hoth_List = capnp.StructList[Hoth]

// NewHoth creates a new list of Hoth.
func NewHoth_List(s *capnp.Segment, sz int32) (Hoth_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Hoth]{List: l}, err
}

// Hoth_Future is a wrapper for a Hoth promised by a client call.
type Hoth_Future struct{ *capnp.Future }

func (p Hoth_Future) Struct() (Hoth, error) {
	s, err := p.Future.Struct()
	return Hoth{s}, err
}

func (p Hoth_Future) Base() EchoBase_Future {
	return EchoBase_Future{Future: p.Future.Field(0, nil)}
}

type EchoBase struct{ capnp.Struct }

// EchoBase_TypeID is the unique identifier for the type EchoBase.
const EchoBase_TypeID = 0xa8bf13fef2674866

func NewEchoBase(s *capnp.Segment) (EchoBase, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return EchoBase{st}, err
}

func NewRootEchoBase(s *capnp.Segment) (EchoBase, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return EchoBase{st}, err
}

func ReadRootEchoBase(msg *capnp.Message) (EchoBase, error) {
	root, err := msg.Root()
	return EchoBase{root.Struct()}, err
}

func (s EchoBase) String() string {
	str, _ := text.Marshal(0xa8bf13fef2674866, s.Struct)
	return str
}

func (s EchoBase) Echo() Echo {
	p, _ := s.Struct.Ptr(0)
	return Echo{Client: p.Interface().Client()}
}

func (s EchoBase) HasEcho() bool {
	return s.Struct.HasPtr(0)
}

func (s EchoBase) SetEcho(v Echo) error {
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(0, in.ToPtr())
}

// EchoBase_List is a list of EchoBase.
type EchoBase_List = capnp.StructList[EchoBase]

// NewEchoBase creates a new list of EchoBase.
func NewEchoBase_List(s *capnp.Segment, sz int32) (EchoBase_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[EchoBase]{List: l}, err
}

// EchoBase_Future is a wrapper for a EchoBase promised by a client call.
type EchoBase_Future struct{ *capnp.Future }

func (p EchoBase_Future) Struct() (EchoBase, error) {
	s, err := p.Future.Struct()
	return EchoBase{s}, err
}

func (p EchoBase_Future) Echo() Echo {
	return Echo{Client: p.Future.Field(0, nil).Client()}
}

type StackingRoot struct{ capnp.Struct }

// StackingRoot_TypeID is the unique identifier for the type StackingRoot.
const StackingRoot_TypeID = 0x8fae7b41c61fc890

func NewStackingRoot(s *capnp.Segment) (StackingRoot, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return StackingRoot{st}, err
}

func NewRootStackingRoot(s *capnp.Segment) (StackingRoot, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return StackingRoot{st}, err
}

func ReadRootStackingRoot(msg *capnp.Message) (StackingRoot, error) {
	root, err := msg.Root()
	return StackingRoot{root.Struct()}, err
}

func (s StackingRoot) String() string {
	str, _ := text.Marshal(0x8fae7b41c61fc890, s.Struct)
	return str
}

func (s StackingRoot) A() (StackingA, error) {
	p, err := s.Struct.Ptr(1)
	return StackingA{Struct: p.Struct()}, err
}

func (s StackingRoot) HasA() bool {
	return s.Struct.HasPtr(1)
}

func (s StackingRoot) SetA(v StackingA) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewA sets the a field to a newly
// allocated StackingA struct, preferring placement in s's segment.
func (s StackingRoot) NewA() (StackingA, error) {
	ss, err := NewStackingA(s.Struct.Segment())
	if err != nil {
		return StackingA{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s StackingRoot) AWithDefault() (StackingA, error) {
	p, err := s.Struct.Ptr(0)
	if err != nil {
		return StackingA{}, err
	}
	ss, err := p.StructDefault(x_832bcc6686a26d56[64:96])
	return StackingA{Struct: ss}, err
}

func (s StackingRoot) HasAWithDefault() bool {
	return s.Struct.HasPtr(0)
}

func (s StackingRoot) SetAWithDefault(v StackingA) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAWithDefault sets the aWithDefault field to a newly
// allocated StackingA struct, preferring placement in s's segment.
func (s StackingRoot) NewAWithDefault() (StackingA, error) {
	ss, err := NewStackingA(s.Struct.Segment())
	if err != nil {
		return StackingA{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// StackingRoot_List is a list of StackingRoot.
type StackingRoot_List = capnp.StructList[StackingRoot]

// NewStackingRoot creates a new list of StackingRoot.
func NewStackingRoot_List(s *capnp.Segment, sz int32) (StackingRoot_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[StackingRoot]{List: l}, err
}

// StackingRoot_Future is a wrapper for a StackingRoot promised by a client call.
type StackingRoot_Future struct{ *capnp.Future }

func (p StackingRoot_Future) Struct() (StackingRoot, error) {
	s, err := p.Future.Struct()
	return StackingRoot{s}, err
}

func (p StackingRoot_Future) A() StackingA_Future {
	return StackingA_Future{Future: p.Future.Field(1, nil)}
}

func (p StackingRoot_Future) AWithDefault() StackingA_Future {
	return StackingA_Future{Future: p.Future.Field(0, x_832bcc6686a26d56[96:128])}
}

type StackingA struct{ capnp.Struct }

// StackingA_TypeID is the unique identifier for the type StackingA.
const StackingA_TypeID = 0x9d3032ff86043b75

func NewStackingA(s *capnp.Segment) (StackingA, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return StackingA{st}, err
}

func NewRootStackingA(s *capnp.Segment) (StackingA, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return StackingA{st}, err
}

func ReadRootStackingA(msg *capnp.Message) (StackingA, error) {
	root, err := msg.Root()
	return StackingA{root.Struct()}, err
}

func (s StackingA) String() string {
	str, _ := text.Marshal(0x9d3032ff86043b75, s.Struct)
	return str
}

func (s StackingA) Num() int32 {
	return int32(s.Struct.Uint32(0))
}

func (s StackingA) SetNum(v int32) {
	s.Struct.SetUint32(0, uint32(v))
}

func (s StackingA) B() (StackingB, error) {
	p, err := s.Struct.Ptr(0)
	return StackingB{Struct: p.Struct()}, err
}

func (s StackingA) HasB() bool {
	return s.Struct.HasPtr(0)
}

func (s StackingA) SetB(v StackingB) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewB sets the b field to a newly
// allocated StackingB struct, preferring placement in s's segment.
func (s StackingA) NewB() (StackingB, error) {
	ss, err := NewStackingB(s.Struct.Segment())
	if err != nil {
		return StackingB{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// StackingA_List is a list of StackingA.
type StackingA_List = capnp.StructList[StackingA]

// NewStackingA creates a new list of StackingA.
func NewStackingA_List(s *capnp.Segment, sz int32) (StackingA_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[StackingA]{List: l}, err
}

// StackingA_Future is a wrapper for a StackingA promised by a client call.
type StackingA_Future struct{ *capnp.Future }

func (p StackingA_Future) Struct() (StackingA, error) {
	s, err := p.Future.Struct()
	return StackingA{s}, err
}

func (p StackingA_Future) B() StackingB_Future {
	return StackingB_Future{Future: p.Future.Field(0, nil)}
}

type StackingB struct{ capnp.Struct }

// StackingB_TypeID is the unique identifier for the type StackingB.
const StackingB_TypeID = 0x85257b30d6edf8c5

func NewStackingB(s *capnp.Segment) (StackingB, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return StackingB{st}, err
}

func NewRootStackingB(s *capnp.Segment) (StackingB, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return StackingB{st}, err
}

func ReadRootStackingB(msg *capnp.Message) (StackingB, error) {
	root, err := msg.Root()
	return StackingB{root.Struct()}, err
}

func (s StackingB) String() string {
	str, _ := text.Marshal(0x85257b30d6edf8c5, s.Struct)
	return str
}

func (s StackingB) Num() int32 {
	return int32(s.Struct.Uint32(0))
}

func (s StackingB) SetNum(v int32) {
	s.Struct.SetUint32(0, uint32(v))
}

// StackingB_List is a list of StackingB.
type StackingB_List = capnp.StructList[StackingB]

// NewStackingB creates a new list of StackingB.
func NewStackingB_List(s *capnp.Segment, sz int32) (StackingB_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[StackingB]{List: l}, err
}

// StackingB_Future is a wrapper for a StackingB promised by a client call.
type StackingB_Future struct{ *capnp.Future }

func (p StackingB_Future) Struct() (StackingB, error) {
	s, err := p.Future.Struct()
	return StackingB{s}, err
}

type CallSequence struct{ Client *capnp.Client }

// CallSequence_TypeID is the unique identifier for the type CallSequence.
const CallSequence_TypeID = 0xabaedf5f7817c820

func (c CallSequence) GetNumber(ctx context.Context, params func(CallSequence_getNumber_Params) error) (CallSequence_getNumber_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xabaedf5f7817c820,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:CallSequence",
			MethodName:    "getNumber",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(CallSequence_getNumber_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return CallSequence_getNumber_Results_Future{Future: ans.Future()}, release
}

func (c CallSequence) AddRef() CallSequence {
	return CallSequence{
		Client: c.Client.AddRef(),
	}
}

func (c CallSequence) Release() {
	c.Client.Release()
}

// A CallSequence_Server is a CallSequence with a local implementation.
type CallSequence_Server interface {
	GetNumber(context.Context, CallSequence_getNumber) error
}

// CallSequence_NewServer creates a new Server from an implementation of CallSequence_Server.
func CallSequence_NewServer(s CallSequence_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(CallSequence_Methods(nil, s), s, c, policy)
}

// CallSequence_ServerToClient creates a new Client from an implementation of CallSequence_Server.
// The caller is responsible for calling Release on the returned Client.
func CallSequence_ServerToClient(s CallSequence_Server, policy *server.Policy) CallSequence {
	return CallSequence{Client: capnp.NewClient(CallSequence_NewServer(s, policy))}
}

// CallSequence_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func CallSequence_Methods(methods []server.Method, s CallSequence_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xabaedf5f7817c820,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:CallSequence",
			MethodName:    "getNumber",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.GetNumber(ctx, CallSequence_getNumber{call})
		},
	})

	return methods
}

// CallSequence_getNumber holds the state for a server call to CallSequence.getNumber.
// See server.Call for documentation.
type CallSequence_getNumber struct {
	*server.Call
}

// Args returns the call's arguments.
func (c CallSequence_getNumber) Args() CallSequence_getNumber_Params {
	return CallSequence_getNumber_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c CallSequence_getNumber) AllocResults() (CallSequence_getNumber_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return CallSequence_getNumber_Results{Struct: r}, err
}

type CallSequence_getNumber_Params struct{ capnp.Struct }

// CallSequence_getNumber_Params_TypeID is the unique identifier for the type CallSequence_getNumber_Params.
const CallSequence_getNumber_Params_TypeID = 0xf58782f48a121998

func NewCallSequence_getNumber_Params(s *capnp.Segment) (CallSequence_getNumber_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return CallSequence_getNumber_Params{st}, err
}

func NewRootCallSequence_getNumber_Params(s *capnp.Segment) (CallSequence_getNumber_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return CallSequence_getNumber_Params{st}, err
}

func ReadRootCallSequence_getNumber_Params(msg *capnp.Message) (CallSequence_getNumber_Params, error) {
	root, err := msg.Root()
	return CallSequence_getNumber_Params{root.Struct()}, err
}

func (s CallSequence_getNumber_Params) String() string {
	str, _ := text.Marshal(0xf58782f48a121998, s.Struct)
	return str
}

// CallSequence_getNumber_Params_List is a list of CallSequence_getNumber_Params.
type CallSequence_getNumber_Params_List = capnp.StructList[CallSequence_getNumber_Params]

// NewCallSequence_getNumber_Params creates a new list of CallSequence_getNumber_Params.
func NewCallSequence_getNumber_Params_List(s *capnp.Segment, sz int32) (CallSequence_getNumber_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[CallSequence_getNumber_Params]{List: l}, err
}

// CallSequence_getNumber_Params_Future is a wrapper for a CallSequence_getNumber_Params promised by a client call.
type CallSequence_getNumber_Params_Future struct{ *capnp.Future }

func (p CallSequence_getNumber_Params_Future) Struct() (CallSequence_getNumber_Params, error) {
	s, err := p.Future.Struct()
	return CallSequence_getNumber_Params{s}, err
}

type CallSequence_getNumber_Results struct{ capnp.Struct }

// CallSequence_getNumber_Results_TypeID is the unique identifier for the type CallSequence_getNumber_Results.
const CallSequence_getNumber_Results_TypeID = 0xa465f9502fd11e97

func NewCallSequence_getNumber_Results(s *capnp.Segment) (CallSequence_getNumber_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return CallSequence_getNumber_Results{st}, err
}

func NewRootCallSequence_getNumber_Results(s *capnp.Segment) (CallSequence_getNumber_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return CallSequence_getNumber_Results{st}, err
}

func ReadRootCallSequence_getNumber_Results(msg *capnp.Message) (CallSequence_getNumber_Results, error) {
	root, err := msg.Root()
	return CallSequence_getNumber_Results{root.Struct()}, err
}

func (s CallSequence_getNumber_Results) String() string {
	str, _ := text.Marshal(0xa465f9502fd11e97, s.Struct)
	return str
}

func (s CallSequence_getNumber_Results) N() uint32 {
	return s.Struct.Uint32(0)
}

func (s CallSequence_getNumber_Results) SetN(v uint32) {
	s.Struct.SetUint32(0, v)
}

// CallSequence_getNumber_Results_List is a list of CallSequence_getNumber_Results.
type CallSequence_getNumber_Results_List = capnp.StructList[CallSequence_getNumber_Results]

// NewCallSequence_getNumber_Results creates a new list of CallSequence_getNumber_Results.
func NewCallSequence_getNumber_Results_List(s *capnp.Segment, sz int32) (CallSequence_getNumber_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[CallSequence_getNumber_Results]{List: l}, err
}

// CallSequence_getNumber_Results_Future is a wrapper for a CallSequence_getNumber_Results promised by a client call.
type CallSequence_getNumber_Results_Future struct{ *capnp.Future }

func (p CallSequence_getNumber_Results_Future) Struct() (CallSequence_getNumber_Results, error) {
	s, err := p.Future.Struct()
	return CallSequence_getNumber_Results{s}, err
}

type Pipeliner struct{ Client *capnp.Client }

// Pipeliner_TypeID is the unique identifier for the type Pipeliner.
const Pipeliner_TypeID = 0xd6514008f0f84ebc

func (c Pipeliner) NewPipeliner(ctx context.Context, params func(Pipeliner_newPipeliner_Params) error) (Pipeliner_newPipeliner_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xd6514008f0f84ebc,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:Pipeliner",
			MethodName:    "newPipeliner",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Pipeliner_newPipeliner_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Pipeliner_newPipeliner_Results_Future{Future: ans.Future()}, release
}
func (c Pipeliner) GetNumber(ctx context.Context, params func(CallSequence_getNumber_Params) error) (CallSequence_getNumber_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xabaedf5f7817c820,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:CallSequence",
			MethodName:    "getNumber",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(CallSequence_getNumber_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return CallSequence_getNumber_Results_Future{Future: ans.Future()}, release
}

func (c Pipeliner) AddRef() Pipeliner {
	return Pipeliner{
		Client: c.Client.AddRef(),
	}
}

func (c Pipeliner) Release() {
	c.Client.Release()
}

// A Pipeliner_Server is a Pipeliner with a local implementation.
type Pipeliner_Server interface {
	NewPipeliner(context.Context, Pipeliner_newPipeliner) error

	GetNumber(context.Context, CallSequence_getNumber) error
}

// Pipeliner_NewServer creates a new Server from an implementation of Pipeliner_Server.
func Pipeliner_NewServer(s Pipeliner_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Pipeliner_Methods(nil, s), s, c, policy)
}

// Pipeliner_ServerToClient creates a new Client from an implementation of Pipeliner_Server.
// The caller is responsible for calling Release on the returned Client.
func Pipeliner_ServerToClient(s Pipeliner_Server, policy *server.Policy) Pipeliner {
	return Pipeliner{Client: capnp.NewClient(Pipeliner_NewServer(s, policy))}
}

// Pipeliner_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Pipeliner_Methods(methods []server.Method, s Pipeliner_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xd6514008f0f84ebc,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:Pipeliner",
			MethodName:    "newPipeliner",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.NewPipeliner(ctx, Pipeliner_newPipeliner{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xabaedf5f7817c820,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:CallSequence",
			MethodName:    "getNumber",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.GetNumber(ctx, CallSequence_getNumber{call})
		},
	})

	return methods
}

// Pipeliner_newPipeliner holds the state for a server call to Pipeliner.newPipeliner.
// See server.Call for documentation.
type Pipeliner_newPipeliner struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Pipeliner_newPipeliner) Args() Pipeliner_newPipeliner_Params {
	return Pipeliner_newPipeliner_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Pipeliner_newPipeliner) AllocResults() (Pipeliner_newPipeliner_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Pipeliner_newPipeliner_Results{Struct: r}, err
}

type Pipeliner_newPipeliner_Params struct{ capnp.Struct }

// Pipeliner_newPipeliner_Params_TypeID is the unique identifier for the type Pipeliner_newPipeliner_Params.
const Pipeliner_newPipeliner_Params_TypeID = 0xbaa7b3b1ca91f833

func NewPipeliner_newPipeliner_Params(s *capnp.Segment) (Pipeliner_newPipeliner_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Pipeliner_newPipeliner_Params{st}, err
}

func NewRootPipeliner_newPipeliner_Params(s *capnp.Segment) (Pipeliner_newPipeliner_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Pipeliner_newPipeliner_Params{st}, err
}

func ReadRootPipeliner_newPipeliner_Params(msg *capnp.Message) (Pipeliner_newPipeliner_Params, error) {
	root, err := msg.Root()
	return Pipeliner_newPipeliner_Params{root.Struct()}, err
}

func (s Pipeliner_newPipeliner_Params) String() string {
	str, _ := text.Marshal(0xbaa7b3b1ca91f833, s.Struct)
	return str
}

// Pipeliner_newPipeliner_Params_List is a list of Pipeliner_newPipeliner_Params.
type Pipeliner_newPipeliner_Params_List = capnp.StructList[Pipeliner_newPipeliner_Params]

// NewPipeliner_newPipeliner_Params creates a new list of Pipeliner_newPipeliner_Params.
func NewPipeliner_newPipeliner_Params_List(s *capnp.Segment, sz int32) (Pipeliner_newPipeliner_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Pipeliner_newPipeliner_Params]{List: l}, err
}

// Pipeliner_newPipeliner_Params_Future is a wrapper for a Pipeliner_newPipeliner_Params promised by a client call.
type Pipeliner_newPipeliner_Params_Future struct{ *capnp.Future }

func (p Pipeliner_newPipeliner_Params_Future) Struct() (Pipeliner_newPipeliner_Params, error) {
	s, err := p.Future.Struct()
	return Pipeliner_newPipeliner_Params{s}, err
}

type Pipeliner_newPipeliner_Results struct{ capnp.Struct }

// Pipeliner_newPipeliner_Results_TypeID is the unique identifier for the type Pipeliner_newPipeliner_Results.
const Pipeliner_newPipeliner_Results_TypeID = 0xbbcdbf4b4ae501fa

func NewPipeliner_newPipeliner_Results(s *capnp.Segment) (Pipeliner_newPipeliner_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Pipeliner_newPipeliner_Results{st}, err
}

func NewRootPipeliner_newPipeliner_Results(s *capnp.Segment) (Pipeliner_newPipeliner_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Pipeliner_newPipeliner_Results{st}, err
}

func ReadRootPipeliner_newPipeliner_Results(msg *capnp.Message) (Pipeliner_newPipeliner_Results, error) {
	root, err := msg.Root()
	return Pipeliner_newPipeliner_Results{root.Struct()}, err
}

func (s Pipeliner_newPipeliner_Results) String() string {
	str, _ := text.Marshal(0xbbcdbf4b4ae501fa, s.Struct)
	return str
}

func (s Pipeliner_newPipeliner_Results) Extra() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s Pipeliner_newPipeliner_Results) HasExtra() bool {
	return s.Struct.HasPtr(0)
}

func (s Pipeliner_newPipeliner_Results) SetExtra(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

func (s Pipeliner_newPipeliner_Results) Pipeliner() Pipeliner {
	p, _ := s.Struct.Ptr(1)
	return Pipeliner{Client: p.Interface().Client()}
}

func (s Pipeliner_newPipeliner_Results) HasPipeliner() bool {
	return s.Struct.HasPtr(1)
}

func (s Pipeliner_newPipeliner_Results) SetPipeliner(v Pipeliner) error {
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(1, in.ToPtr())
}

// Pipeliner_newPipeliner_Results_List is a list of Pipeliner_newPipeliner_Results.
type Pipeliner_newPipeliner_Results_List = capnp.StructList[Pipeliner_newPipeliner_Results]

// NewPipeliner_newPipeliner_Results creates a new list of Pipeliner_newPipeliner_Results.
func NewPipeliner_newPipeliner_Results_List(s *capnp.Segment, sz int32) (Pipeliner_newPipeliner_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Pipeliner_newPipeliner_Results]{List: l}, err
}

// Pipeliner_newPipeliner_Results_Future is a wrapper for a Pipeliner_newPipeliner_Results promised by a client call.
type Pipeliner_newPipeliner_Results_Future struct{ *capnp.Future }

func (p Pipeliner_newPipeliner_Results_Future) Struct() (Pipeliner_newPipeliner_Results, error) {
	s, err := p.Future.Struct()
	return Pipeliner_newPipeliner_Results{s}, err
}

func (p Pipeliner_newPipeliner_Results_Future) Extra() *capnp.Future {
	return p.Future.Field(0, nil)
}

func (p Pipeliner_newPipeliner_Results_Future) Pipeliner() Pipeliner {
	return Pipeliner{Client: p.Future.Field(1, nil).Client()}
}

type Sender struct{ Client *capnp.Client }

// Sender_TypeID is the unique identifier for the type Sender.
const Sender_TypeID = 0x9c0550a706af8bd2

func (c Sender) Send(ctx context.Context, params func(Sender_send_Params) error) (Sender_send_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9c0550a706af8bd2,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Sender_send_Results_Future{Future: ans.Future()}, release
}

func (c Sender) AddRef() Sender {
	return Sender{
		Client: c.Client.AddRef(),
	}
}

func (c Sender) Release() {
	c.Client.Release()
}

// A Sender_Server is a Sender with a local implementation.
type Sender_Server interface {
	Send(context.Context, Sender_send) error
}

// Sender_NewServer creates a new Server from an implementation of Sender_Server.
func Sender_NewServer(s Sender_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Sender_Methods(nil, s), s, c, policy)
}

// Sender_ServerToClient creates a new Client from an implementation of Sender_Server.
// The caller is responsible for calling Release on the returned Client.
func Sender_ServerToClient(s Sender_Server, policy *server.Policy) Sender {
	return Sender{Client: capnp.NewClient(Sender_NewServer(s, policy))}
}

// Sender_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Sender_Methods(methods []server.Method, s Sender_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9c0550a706af8bd2,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	return methods
}

// Sender_send holds the state for a server call to Sender.send.
// See server.Call for documentation.
type Sender_send struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Sender_send) Args() Sender_send_Params {
	return Sender_send_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Sender_send) AllocResults() (Sender_send_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results{Struct: r}, err
}

type Sender_send_Params struct{ capnp.Struct }

// Sender_send_Params_TypeID is the unique identifier for the type Sender_send_Params.
const Sender_send_Params_TypeID = 0xfd3eb2db747ca085

func NewSender_send_Params(s *capnp.Segment) (Sender_send_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Sender_send_Params{st}, err
}

func NewRootSender_send_Params(s *capnp.Segment) (Sender_send_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Sender_send_Params{st}, err
}

func ReadRootSender_send_Params(msg *capnp.Message) (Sender_send_Params, error) {
	root, err := msg.Root()
	return Sender_send_Params{root.Struct()}, err
}

func (s Sender_send_Params) String() string {
	str, _ := text.Marshal(0xfd3eb2db747ca085, s.Struct)
	return str
}

func (s Sender_send_Params) T() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s Sender_send_Params) HasT() bool {
	return s.Struct.HasPtr(0)
}

func (s Sender_send_Params) SetT(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// Sender_send_Params_List is a list of Sender_send_Params.
type Sender_send_Params_List = capnp.StructList[Sender_send_Params]

// NewSender_send_Params creates a new list of Sender_send_Params.
func NewSender_send_Params_List(s *capnp.Segment, sz int32) (Sender_send_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Sender_send_Params]{List: l}, err
}

// Sender_send_Params_Future is a wrapper for a Sender_send_Params promised by a client call.
type Sender_send_Params_Future struct{ *capnp.Future }

func (p Sender_send_Params_Future) Struct() (Sender_send_Params, error) {
	s, err := p.Future.Struct()
	return Sender_send_Params{s}, err
}

func (p Sender_send_Params_Future) T() *capnp.Future {
	return p.Future.Field(0, nil)
}

type Sender_send_Results struct{ capnp.Struct }

// Sender_send_Results_TypeID is the unique identifier for the type Sender_send_Results.
const Sender_send_Results_TypeID = 0xc8a79f2635d71e94

func NewSender_send_Results(s *capnp.Segment) (Sender_send_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results{st}, err
}

func NewRootSender_send_Results(s *capnp.Segment) (Sender_send_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results{st}, err
}

func ReadRootSender_send_Results(msg *capnp.Message) (Sender_send_Results, error) {
	root, err := msg.Root()
	return Sender_send_Results{root.Struct()}, err
}

func (s Sender_send_Results) String() string {
	str, _ := text.Marshal(0xc8a79f2635d71e94, s.Struct)
	return str
}

// Sender_send_Results_List is a list of Sender_send_Results.
type Sender_send_Results_List = capnp.StructList[Sender_send_Results]

// NewSender_send_Results creates a new list of Sender_send_Results.
func NewSender_send_Results_List(s *capnp.Segment, sz int32) (Sender_send_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Sender_send_Results]{List: l}, err
}

// Sender_send_Results_Future is a wrapper for a Sender_send_Results promised by a client call.
type Sender_send_Results_Future struct{ *capnp.Future }

func (p Sender_send_Results_Future) Struct() (Sender_send_Results, error) {
	s, err := p.Future.Struct()
	return Sender_send_Results{s}, err
}

type Defaults struct{ capnp.Struct }

// Defaults_TypeID is the unique identifier for the type Defaults.
const Defaults_TypeID = 0x97e38948c61f878d

func NewDefaults(s *capnp.Segment) (Defaults, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Defaults{st}, err
}

func NewRootDefaults(s *capnp.Segment) (Defaults, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Defaults{st}, err
}

func ReadRootDefaults(msg *capnp.Message) (Defaults, error) {
	root, err := msg.Root()
	return Defaults{root.Struct()}, err
}

func (s Defaults) String() string {
	str, _ := text.Marshal(0x97e38948c61f878d, s.Struct)
	return str
}

func (s Defaults) Text() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextDefault("foo"), err
}

func (s Defaults) HasText() bool {
	return s.Struct.HasPtr(0)
}

func (s Defaults) TextBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytesDefault("foo"), err
}

func (s Defaults) SetText(v string) error {
	return s.Struct.SetNewText(0, v)
}

func (s Defaults) Data() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.DataDefault([]byte{0x62, 0x61, 0x72})), err
}

func (s Defaults) HasData() bool {
	return s.Struct.HasPtr(1)
}

func (s Defaults) SetData(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(1, v)
}

func (s Defaults) Float() float32 {
	return math.Float32frombits(s.Struct.Uint32(0) ^ 0x4048f5c3)
}

func (s Defaults) SetFloat(v float32) {
	s.Struct.SetUint32(0, math.Float32bits(v)^0x4048f5c3)
}

func (s Defaults) Int() int32 {
	return int32(s.Struct.Uint32(4) ^ 4294967173)
}

func (s Defaults) SetInt(v int32) {
	s.Struct.SetUint32(4, uint32(v)^4294967173)
}

func (s Defaults) Uint() uint32 {
	return s.Struct.Uint32(8) ^ 42
}

func (s Defaults) SetUint(v uint32) {
	s.Struct.SetUint32(8, v^42)
}

// Defaults_List is a list of Defaults.
type Defaults_List = capnp.StructList[Defaults]

// NewDefaults creates a new list of Defaults.
func NewDefaults_List(s *capnp.Segment, sz int32) (Defaults_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Defaults]{List: l}, err
}

// Defaults_Future is a wrapper for a Defaults promised by a client call.
type Defaults_Future struct{ *capnp.Future }

func (p Defaults_Future) Struct() (Defaults, error) {
	s, err := p.Future.Struct()
	return Defaults{s}, err
}

type BenchmarkA struct{ capnp.Struct }

// BenchmarkA_TypeID is the unique identifier for the type BenchmarkA.
const BenchmarkA_TypeID = 0xde2a1a960863c11c

func NewBenchmarkA(s *capnp.Segment) (BenchmarkA, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return BenchmarkA{st}, err
}

func NewRootBenchmarkA(s *capnp.Segment) (BenchmarkA, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return BenchmarkA{st}, err
}

func ReadRootBenchmarkA(msg *capnp.Message) (BenchmarkA, error) {
	root, err := msg.Root()
	return BenchmarkA{root.Struct()}, err
}

func (s BenchmarkA) String() string {
	str, _ := text.Marshal(0xde2a1a960863c11c, s.Struct)
	return str
}

func (s BenchmarkA) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s BenchmarkA) HasName() bool {
	return s.Struct.HasPtr(0)
}

func (s BenchmarkA) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s BenchmarkA) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s BenchmarkA) BirthDay() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s BenchmarkA) SetBirthDay(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

func (s BenchmarkA) Phone() (string, error) {
	p, err := s.Struct.Ptr(1)
	return p.Text(), err
}

func (s BenchmarkA) HasPhone() bool {
	return s.Struct.HasPtr(1)
}

func (s BenchmarkA) PhoneBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return p.TextBytes(), err
}

func (s BenchmarkA) SetPhone(v string) error {
	return s.Struct.SetText(1, v)
}

func (s BenchmarkA) Siblings() int32 {
	return int32(s.Struct.Uint32(8))
}

func (s BenchmarkA) SetSiblings(v int32) {
	s.Struct.SetUint32(8, uint32(v))
}

func (s BenchmarkA) Spouse() bool {
	return s.Struct.Bit(96)
}

func (s BenchmarkA) SetSpouse(v bool) {
	s.Struct.SetBit(96, v)
}

func (s BenchmarkA) Money() float64 {
	return math.Float64frombits(s.Struct.Uint64(16))
}

func (s BenchmarkA) SetMoney(v float64) {
	s.Struct.SetUint64(16, math.Float64bits(v))
}

// BenchmarkA_List is a list of BenchmarkA.
type BenchmarkA_List = capnp.StructList[BenchmarkA]

// NewBenchmarkA creates a new list of BenchmarkA.
func NewBenchmarkA_List(s *capnp.Segment, sz int32) (BenchmarkA_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2}, sz)
	return capnp.StructList[BenchmarkA]{List: l}, err
}

// BenchmarkA_Future is a wrapper for a BenchmarkA promised by a client call.
type BenchmarkA_Future struct{ *capnp.Future }

func (p BenchmarkA_Future) Struct() (BenchmarkA, error) {
	s, err := p.Future.Struct()
	return BenchmarkA{s}, err
}

type AllocBenchmark struct{ capnp.Struct }

// AllocBenchmark_TypeID is the unique identifier for the type AllocBenchmark.
const AllocBenchmark_TypeID = 0xecea3e9ebcbe5655

func NewAllocBenchmark(s *capnp.Segment) (AllocBenchmark, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllocBenchmark{st}, err
}

func NewRootAllocBenchmark(s *capnp.Segment) (AllocBenchmark, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllocBenchmark{st}, err
}

func ReadRootAllocBenchmark(msg *capnp.Message) (AllocBenchmark, error) {
	root, err := msg.Root()
	return AllocBenchmark{root.Struct()}, err
}

func (s AllocBenchmark) String() string {
	str, _ := text.Marshal(0xecea3e9ebcbe5655, s.Struct)
	return str
}

func (s AllocBenchmark) Fields() (AllocBenchmark_Field_List, error) {
	p, err := s.Struct.Ptr(0)
	return AllocBenchmark_Field_List{List: p.List()}, err
}

func (s AllocBenchmark) HasFields() bool {
	return s.Struct.HasPtr(0)
}

func (s AllocBenchmark) SetFields(v AllocBenchmark_Field_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewFields sets the fields field to a newly
// allocated AllocBenchmark_Field_List, preferring placement in s's segment.
func (s AllocBenchmark) NewFields(n int32) (AllocBenchmark_Field_List, error) {
	l, err := NewAllocBenchmark_Field_List(s.Struct.Segment(), n)
	if err != nil {
		return AllocBenchmark_Field_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// AllocBenchmark_List is a list of AllocBenchmark.
type AllocBenchmark_List = capnp.StructList[AllocBenchmark]

// NewAllocBenchmark creates a new list of AllocBenchmark.
func NewAllocBenchmark_List(s *capnp.Segment, sz int32) (AllocBenchmark_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[AllocBenchmark]{List: l}, err
}

// AllocBenchmark_Future is a wrapper for a AllocBenchmark promised by a client call.
type AllocBenchmark_Future struct{ *capnp.Future }

func (p AllocBenchmark_Future) Struct() (AllocBenchmark, error) {
	s, err := p.Future.Struct()
	return AllocBenchmark{s}, err
}

type AllocBenchmark_Field struct{ capnp.Struct }

// AllocBenchmark_Field_TypeID is the unique identifier for the type AllocBenchmark_Field.
const AllocBenchmark_Field_TypeID = 0xb8fb64b8ed846ae6

func NewAllocBenchmark_Field(s *capnp.Segment) (AllocBenchmark_Field, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllocBenchmark_Field{st}, err
}

func NewRootAllocBenchmark_Field(s *capnp.Segment) (AllocBenchmark_Field, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllocBenchmark_Field{st}, err
}

func ReadRootAllocBenchmark_Field(msg *capnp.Message) (AllocBenchmark_Field, error) {
	root, err := msg.Root()
	return AllocBenchmark_Field{root.Struct()}, err
}

func (s AllocBenchmark_Field) String() string {
	str, _ := text.Marshal(0xb8fb64b8ed846ae6, s.Struct)
	return str
}

func (s AllocBenchmark_Field) StringValue() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s AllocBenchmark_Field) HasStringValue() bool {
	return s.Struct.HasPtr(0)
}

func (s AllocBenchmark_Field) StringValueBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s AllocBenchmark_Field) SetStringValue(v string) error {
	return s.Struct.SetText(0, v)
}

// AllocBenchmark_Field_List is a list of AllocBenchmark_Field.
type AllocBenchmark_Field_List = capnp.StructList[AllocBenchmark_Field]

// NewAllocBenchmark_Field creates a new list of AllocBenchmark_Field.
func NewAllocBenchmark_Field_List(s *capnp.Segment, sz int32) (AllocBenchmark_Field_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[AllocBenchmark_Field]{List: l}, err
}

// AllocBenchmark_Field_Future is a wrapper for a AllocBenchmark_Field promised by a client call.
type AllocBenchmark_Field_Future struct{ *capnp.Future }

func (p AllocBenchmark_Field_Future) Struct() (AllocBenchmark_Field, error) {
	s, err := p.Future.Struct()
	return AllocBenchmark_Field{s}, err
}

const schema_832bcc6686a26d56 = "x\xda\xacz\x7fxT\xe5\x95\xff9\xf7\xce\xcc\x0d$" +
	"\xe3\x9d\x9b\xf7BB~J\x0a\x16\x12\xc0\xfc\xc0\x80\xf4" +
	"K\x93`\"\xe0\x17l\x86\x01\x11\xb7Tn\x92\x9bd" +
	"p23\xce\xdc\x81\xc4\xea\x83n\xa1bW\xb6\xf2\x14" +
	"\xabVi)KW\xa9`\xc5\xca\xaeP\xc4b\xa1\x85" +
	"T\xb6\xc2\x82\x16\xaaXq\xb1\x95\xcaVlY\xa1\x82" +
	"w\x9f\xf3\xce\xdc\xb9\x93\xf9\x01\x96g\xffIn\xde\xcf" +
	"\xb9\xe7=\xef9\xe7\xfd\xbc\xe7=7\xb5;\xdd\xcd\x8e" +
	":\xf7\x9d#A\xf09\xd0\xe92\xf7\x9d?\xf3F\xed" +
	"\xd7\xc7\xae\x02\xaf\x8ch\xde\xd6\xb7\xf1\x9b\xdd\xaf\xd5|" +
	"\x03\x1c\x12\x00\x1b\x91?\xc8F\xe7\xd3Sy~\x13\xa0" +
	"\xb9\xf8\xd7\x9e\xaf\x0d\xdb5\xeb\xc14Y\xa7H\"\xd3" +
	"\xf3w\xb26.\xdc\x92\xff\x07@\xf3\xb7?\xfd\xac\xf6" +
	"\x0bM\xbfx\x10\x149U\x16%\x80\x86\x1b\x0b\x0a\x91" +
	"\xcd. \xe1\xb6\x02\xd2<\xad\xbf\xb9\xf1\x85\x83\xa3W" +
	"\xa7in\x95\x04\x00\x16+\x18d\x0fp\xe1\xfb\x0a\x96" +
	"\x03\x9a\x1b\xffR\xfa\xe6\x8bw\x8e\xfc\x16(*BB" +
	"\xe3\xb1\x02\x01\x01\xd9\xdb\\\xdb\xe4\xb1\xe3>\xd8S\xe5" +
	"\xfbgPd\xd1V\x06\xc8.\x15ldN7iB" +
	"\xf7L6\x9e\x9e\xccG\xf6W\xfe\xb2\xe5\xeb\xcf};" +
	"\xcdN\x81\xa4\x14\xf7IV\xce\xe5G\xb9if3\xf2" +
	"\xdai\xef\x13\x07\xbe3T\x96\xfb\xea\x01\xf7\xab\xec!" +
	"\xb7\x04\xa2Yp\xe4\xbb{\x0b\x9f\xad]\x07\x8a\xec\x18" +
	"2\xbb\xee\x1edw\x936_\xc0-\xa2o\xb5[@" +
	"\x00s\xcd\xe8\xbc\xc9\xe7\xef{e]\x16?\xb1U\xee" +
	"A\xb6\x96\xcf\xbf\xc6M\x0b\xbb+\xb8Dm\xfal\xf7" +
	"\xa3\xd9|\xba\xd5]\x88\xece.\xbc\x83\x0b\xafy\xb0" +
	"\xf2\x97\xb3\x1ez\xef1\xf2\xa9\x90\xbe\xb2\x0f\xdc\xaf\xb2" +
	"\xb3$\xdcp\xc6]\x89\x80\xe6\xa2-\xc2\x93\x8f=\xb1" +
	"\xfd{\xd9\xccp\xca\x83L\x91\xe9\xc9-\x93\xe6\xf5_" +
	"\x7f{\xc7\xf87\xa7<\x99\x1a\x80\x1b\xe4\xe1\x14\x80\xe9" +
	"\\`\xff\x82\x93\xce\x9d_\xfc\xf6\x93\x19.X,\x0f" +
	"2?i\xf2u\xc9\"\xfa\xc22w\xc1\xe1\x7f\xfa\x89" +
	"\xeb\xe9v\xe7Si\xf1\x02\x0f2M~!\xfe\x02\xd3" +
	"\xe5\x99l\xbb,\xb1\xed\xb2l\xc6\xbe\xe4\xf8\xa6Y_" +
	"\xbb>=\x11\xb9\xb5\x9b\xe5A\x12\x04`\xdbd\x0a\xda" +
	"c\x15\x87\xaeo\xbf\xa0o\x02o\x19\"\xf0h5\xb8" +
	"=\x11\xb2v\x94\x87\xac\xed\x9e\xd5\xf3\xf1g\xec\x95g" +
	"\xb2-\xfdF\xcf\xab\xac\xc5\xc3\xf3\x9b\xcb^\xbb\xbf\xa8" +
	"\xff\xcew\x9e{6#\xb5\x16{N2?\x17\xd4=" +
	"3\xd9Zz2\xcf\xde7\xb7z\xc6\x82\xd7\x9f\xcd\x16" +
	"\xae\x01O\x09\xb2\x87\xf8\x0b\xab\xb8\xe6\x1d\x7fz>\xd4" +
	"v\xfc\xc1\xad\xd9\xac\xd8\xee\xd9\xc8^\xe6\xb2;\xb8\xac" +
	"\x12\xeez3\xe8\xdc\xb2-\x9b\xec1\xcf\xc7\xec\x14\x97" +
	"}\x97\xcb\xaeh\xfc\xda\xca\xc5S?\xdaF\xbe\x12\xd3" +
	"7\xad\xa2\x1cf\xe5\x0a\xd93JYHi\x10\x1d\x9c" +
	"l~x\xb2\xe2\xdf\xb2%M\xc3\xaaB\x01\xd9\xdaB" +
	"\x9e\x8f\x85\xb4\xc77\xfd\xeb\xce\xb1\xbf\xec\xab\xf9w\xf0" +
	"*(\x9a\xc76\xbc\xf1\xa5\xc7>\xb8\xee4\x8c@\x09" +
	"\x01\x98\xc6~\x0c\xc84FAx\x7f\xe9\xca3/u" +
	"}\xfa\x12(\x15h.\xb8m\xf7\xae\xef\x7f\xf9\xf4\x87" +
	"\x09W\xbc\xcc\xaa\x90\x1dd\xa4\xf6\x00#\x93\x1b\xce\xaf" +
	"\x1d\xdc\xf6\xd3\xa7w\x822\xca\x0a\xd8\x19\xb6\x14\xc1a" +
	"\xfe\x0dO\xdd\xf2\xff_9\xf8\xb38\x12\xb7\xea\x18\xe3" +
	"\xb1<\xc5\xe7\xd9\x98\xff\xf1\xc6\x0b\xfa\xf1_e\xf3L" +
	"\x9b\xfac6W\xa5\xa7\xd9*M\xb3\xae\xe2\xcd\x1b\xae" +
	"\xfb\xc1\xd3\xfbA\x19\xc9\xa7\xf1`\x83_-\xa1i&" +
	"\xce\xbd\xf1\xe5\xf7\x9e\xfd\x87\x03\xd98\xc1\xab\x0e\xb2\xc5" +
	"\\\xcb\"\x95f\xdc\xf9\xc9;G\xef\\\xf6\xd6\xaf\xb3" +
	"\x05y\xbbZ\x82l\x1f\x17\xde\xc3\xa7||\xef\xe6\xfc" +
	"\xf7\x95\xd6\xd7\xb2\x99wV\xdd\xc9.p\xd9s\\\xf6" +
	"\xf7\xd7M]\xf2\xde\x0b?\xcd*;~\xc4FV7" +
	"\x82\x9e&\x8e \xd9\xd9\xed'\x8f\x9d|\xae\xf5?\xb2" +
	"\x06y\xee\x88\xd3l\x11\x097,\x18\xc1\x83\xbc\xff\xfe" +
	"=e\x83\xa7\x9f\xfcM6\x93\xb7\x8d,D\xb6g$" +
	"\xbd\xf7\xf2HR\xbd\xfb\xf8\xea\xb3\x9b>m|#\x9b" +
	"\x19gF~\x8f\x9d\xe3\xb2g\xb9\xec\xae[\xcf\x7f\x94" +
	"\xd7\xec}#cw(E\x83\xac\xbc\x88\x13i\xd1L" +
	"\xd6VT\x04`\xae\x9d\xf2\xf4\x92\xe0ov\xfd\x96l" +
	"v\xa4{\xf9\x86\xa2A\xd6B/4L/\xe26\xaf" +
	"\xf9\xf5\xb1\xe5\xab\x97<|,\x9b\x19?,\xde\xc86" +
	"\x17\xd3\xd3\x8f\x8a\xc9\x0c\xb6\xecS\x7fw\xcb\xa1\xb7\xb3" +
	"\x85o_\xf1Fv\x90\xcb\x1e(\xa6\xf0\x95\xed\xe9\xcc" +
	"\xfbnI\xf5\x89t\xcf\xc5\xad\x18u\x98\xb5\x8c\xe2V" +
	"\x8c\xe2V\xac\x9f\xbfp\xeb\xcf\x9ek?\x91\xed\xb4\\" +
	"[\xf2c\xf6D\x09==Z\xf2\x13@\xf3;\xb5\xcf" +
	"\xfc\xed\xff\x1d\xf9\xfe\x89l^\x9eX:\x1c\xd9\xf4R" +
	"\xce0\xa5d\xf2\xd6\xdd\x92r\xf4\xd0\xc6w\xb3-\xcf" +
	"_\xba\x93\xdd\xcde\xfb\xb8\xac\xe6k(\xdcw\xfa@" +
	"V\xd9GK\xbf\xc7\xd6s\xd9'\xb8\xec\xf9E\x1b\xbe" +
	"\xf1\xd4\xc6\xbcS\xd9\x8c\xd8QZ\x88\xec\x00\x17\xde\xc7" +
	"\x85\xb7\xfdj\xc1\x89\xe7<\xb7\x9eJ[]\x1bJ\x0e" +
	"\xca\xca\xd2W\xd9%.}\xa1\x946\xff\xe8\xeb\xcf\x97" +
	"^\\\xb5\x98T\x0bC\x82}\xb0l';ZF\x82" +
	"\x87\xca\xc8\x11o\xb9.\xfc`\xe5\x8a\x07\xd2m\xe0\xb9" +
	"9\xb6|\x90\xd5\x95\xf3D.'\xd9E\xbd%\x7f\x9e" +
	"\xf6\xa7\x95\xefg[\xdb\xb9\xf2\xe3\x0c+\xe8\xe9R9" +
	"?\x0d\x8f\xee\xde\xb4\xb5\xe4\xee?d\x9c2c+\x06" +
	"Y\x1d\x09\xfa&T\x88\xe8\x9bZ\xc1O\x99$=\x0d" +
	"\x8dt\x1bJu4}\xc5\xb7\xd8\x0d\xf4NC]\xc5" +
	"+\xc3!\x85\xa4\xb2Xr\xb4\xfac\xf6nu\x11\x9d" +
	"\xa3\xd5dIY\xde\xe2\x19\xc3\xb6~\xe5l6\xd9Q" +
	"5\xc7\xd9\xd8\x1az\x1a]\xc3)`T\xe1\xb7\xfe\xfa" +
	"\x8f\x0f\x9e\x03\xa5\xcc\"7o\x0d'\xb7K\xdd3\x0f" +
	"\xb4\xbd\xe5\xfc$\x8d{yrM\xaf9\xccfs-" +
	"m5\x94\xb6K\x8b\x033\xd5V\xf3\x93\xac\xdb\xa1\xe6" +
	"0\xdb\xcae7\xf3\x19O\xcc\xd9\xfd\x9dq\xc6\xbf\\" +
	"\xcc\x96\xb4gj\x0e\xb3\x0b\\\xf6\x1c\x97]\xb5\xe1^" +
	"\xe3w/|\xf9R\x9c\x13\x9dH\xa48bB!\x11" +
	"l\xf9\x84&\x98hj\xfeHgD\xeb6\x84I\x9d" +
	"Z8\x18\x9e\xe63\xb4\xce\xbb\xfc\xc1\x9e\x19\x00\xed\x88" +
	"^\x87\xe8\x00p \x80\xe2\xae\x02\xf0\xe6\x89\xe8U\x05" +
	"\x94\x82\xb1>t\x80\x80\x0eJ\xdf\x84\x06Lh\xb8\xa9" +
	")\x14\x0b\x1az\x84^\xf7$_\xd7\xaa\x01\xbc_\x15" +
	"\xd1\xdb+ \xa2J'\xb7\xa2\xd7\x03x\x97\x88\xe8\x0d" +
	"\x08\xa8\x08\xa8\xa2\x00\xa0\xf8o\x01\xf0\xf6\x8a\xe8])" +
	"\xa0\"\x0a*\x8a\x00\xca\x033\x00\xbc\xf7\x8a\xe8}\\" +
	"@9\xea\xbfGG'\x08\xe8\x04\xac\\\x1e\x8atE" +
	"\xb1\x00\x04,\x004\xe9\xaf\x80?j\x00\x00^\x03\xd8" +
	".\"\x87\xae\x01\\\xd1\xe17\x08\xb1\x861>\x9c\xb4" +
	"^LX?+\x14\xe8\x8a\xde\xa6G\xe6/\x0f\xcd_" +
	"\x1ej\x0f\xc40\x9a\xe6\x87i\x09?\x8c\x11\xb0\xa9o" +
	" U\xa7\xc7\xe6m\xc0!\xda-\xef\xde\x16\xf2w-" +
	"\x08\xfaC\xc1\xb8w\xf3DG\x81ir\xb5\xe3\x0b\x01" +
	"\xbccD\xf4\xd6\x0a\xe8\xc6\xcf\xcc\xb8\x87&\xd2\xe88" +
	"\x11\xbd\x93\x05D\x0d\\\xd8\x01\xae\x0c\x93\xdb:{C" +
	"\x93\xf4\xce\xde\xd0\x98v-\xa2\xf5E!\xd5\xda\x12;" +
	"j\xa2?\x98tTz\xd0\xda\xa4\xce\xdeP|\xa1N" +
	"\x80dI\x8eVi\xa8(\xd5 (NI\xa6y\x9a" +
	"\xb1\x1d1g\xe6\xcc\x93B!#\xb1:D\x07\"*" +
	"\xe3\x97\xda\xcb\xf0$\x82\x7f#-m\xb2\x88\xdef\x01" +
	"Mm\xa1\xdf\xe8m\xd5\xbbA\xd6b\x01\x03=vE" +
	"\x08\x88\x1e\xee,\xac\x06@-\x03\xca\xe2c=\xd2\xd6" +
	"\x176\x06 \x9b\x91\x9d\xa1`\xd4\x98\xc33\x84t&" +
	"\x03\x97<\x08x\xe0@\xc1\"%\x0f\xe5w\xa4\xbcR" +
	"\xfaQ\x96m\x92\xaf\x04\xf5v#r\xd9m\x126\"" +
	"\xe8\xb1\xf7k\x9a\xc1\xd9Sn\x8e?\x8a\xc6\xdf\x91r" +
	"\xc9\x0a/G\xca\xb5\xea\xdd\xe4\xd3(\xb7S\x8d\xebD" +
	"T\xee\xa3\xfd\xd8\x9f\xd8f|C\"*\xabh\xf0~" +
	"\x11\xbd\x0f\x0b\x88\x82\x8a\x02\xa2\xb2\x866\xe9j\x11\xbd" +
	"\xebh?\xa2\x8a\"\xa2\xb2\x96V\xf9p|?*\x0e" +
	"A\xa50+\x8f\xd2\xdb\x8f\x88\xe8}J@\xd9\xd0\xfb" +
	"\x8dD\xb6\x81\x82URw($wi\x86\x86n\x10" +
	"\xd0Mc%R\x87\x16\xa9\xec\x0e\x844\x03\x87\x83p" +
	"v\xf8/\xce\xcdj\x06\x94\xfcA\x83\xb8\xe5\xacc\x95" +
	"i\x9a\x80r\x8c\x06\xf2@P\xf2\xaa\xb3,oaD" +
	"\x0b\xc7\xc3\x9d\x1e\x88\x17\x00\xbc\x1e\x11\xbde\x02\x9a}" +
	"\xfe\x9e^\xe3\xd6\x90\x813\xf4y\xba\x16\x08\x0cT\xf2" +
	"w\xd0c_\x01s\x04\xc7\xde\\\xf3\xf4(\xf7#\xe4" +
	"\x8av(fd\xec\xaf!y\xd7\x16\x8c\xf5\xc5\xf3N" +
	"\xb6O[@\xa7\x8cYv\xa4\xafR\x0fv\xc5Y4" +
	"\xbe'-*G\xab\xce\xa5=\x09-\x05\xd8R\x86\xca" +
	"DI\x8e\xea\xc1.\x05+\xbd\x0e\x01\xed\x1b\x18\xdfj" +
	"\xd9\x06\xf9\x1enq\xa0\x82\x858?\xe7^nI\xf2" +
	"Tb\xc1\xe3\xabl\x9a\xb2h<\x95\xa4RO\x06\xec" +
	"@\x8f\xdd\x8fH\xf3\xaf\xc3:-\xb4@\xc0\xa7\xdf\x1d" +
	"\xd3\x83\x9d\xfa\xa4\x1e\xdd\xb85\xd6\xd7\xa1G\xc6\xcc\xd3" +
	"+\xb9\xb7S}]h\xfb\x1a\x83\x94\x11\x98\x97\xc5\xd3" +
	"\x14\xb0\x19ZTOO\x87j\xfbmNb\xa8\xd8}" +
	"\x05@T\xb2\xa8J\xda&\x05;u;\x10\xd6\x89\x8f" +
	"\xd6MTQ\xe6\x81\xa0\x0c\x93L\xcb~\xc0\xc8P\x8e" +
	"L\xdf\xea_\x09\xea\xad\x9a\xa1\xcd\xf1\x8b\xd1\xbfg\xaf" +
	"\xa72\xc95Yrf\x96\x142z/\xb3\xee\x0e-" +
	"\xaa\xa3\xc7\xbe \xe7`P\xe2G\x9f\x11\x89uV\x1a" +
	"7i\xe1`\x0e\x82\x1b#\xa0\xb4L\xef\xb4\xadKV" +
	"M9\x98h\x9e\xde\x13\xd1\xa3Q\x7f\x08\xb9\xca\xe2\xa4" +
	"\xca'\xc8\xc6u\"z7\xd8I\xb5\x9e\x0e\xae\xc7E" +
	"\xf4nJ\xa9\x0d~H\x82O\x89\xe8})\xa56\xd8" +
	"N\x1e{^D\xefk\xc4E\xa8\xa2\x03@9@V" +
	"\xee\x15\xd1\xfb\xba\x80\x8aSP\xd1\x09\xa0\x1c\xa4\xc1\xfd" +
	"\"z\x8f\xd8\xbeH\xdeZ\xe2\xbe\x10;j1\x1f\x04" +
	"\xcc\x07\x94;tC\xb3V\x97\x1f/\x17\x9a\xc2\x01-" +
	"\xa8G\xed5'K\xec\xf8\x9a\xa5\x81\xbe\x98\xf5\xbe4" +
	"\x10\xed\xb2\x9e3\x12!N\xf7\x94\x03Te\x18\x11H" +
	"\xab\x96\xaa\xecjII\x96KUv\xb9\xc4\xd9\x99\xaa" +
	"%\xf2H\x97\x88\xde\xb0\xc5\xce\x00J_u\xa2\x842" +
	"(DZ\x00E\x10P\x04\x94\xbab!\xabp\x92\xc3" +
	"F\xa4.\xf3p\xa2\xe1\xfa\xcb\x9cYV\xa6\xdd!O" +
	"\xea\x89\x84\x89\x18\xe8<\xaf&f\xa8\xb7\x99A!\xf3" +
	"j\x88\x1a\xa6\xd9\xd4P\xd9\xed\x8fD\x0d\x1c\x06\x02\x0e" +
	"\x03l\x8a\xea\x9d\xa1`\x97\xf5g\x86\x83Z\x02\x81P" +
	"\xe7\x0c=\xd8\xd9\xdb\xa7E\xee\x9at\xb3_\xd2\x03]" +
	"i\x99\xd8\x01\xe0-\x10\xd1[,\xa0\x195\"\xfe`" +
	"\xcfm\x1aH\x81\x98\x9eA\xc3\x16\xdb\xb4\xfb\xc3z\xc0" +
	"\x1f\xd4#\x93\x82\xfa\xf2\xe4\x1fc\xda5\x99\x0a\xa7\xcf" +
	"+\x9e$\xa7\x14^\x1c\xb2z\x8b\x18\xe7\x01x'\x88" +
	"\xe8\x9d*`\xa5\xdeoD4,\x04\x01\x0b\x01\xcdp" +
	"B\x19`\x04\x15\xfb\x9e\x9dFD\xb6\xb7\xe9\xe8\xbc\xcc" +
	"\xc6N9Y3]\xe9\xe3\x07\xc9$:\x1f\xe2\x87\x98" +
	"hD\xb3\x154\x89LLg\xfc\xeal+\xab\xb6\xe3" +
	"z\x95\x99\x94\xa5\xfa\xb9\x1aJL^\xb2rP\xe2\x1d" +
	"MQ=\xb2\xcc:G3Rg\x9c\x80\xe6r\xcdo" +
	"\xf8\x83=KA\x0au\xa4l\xedd\xd7!\x87\xe6\x19" +
	"\xd2\x94\x86)W&\xdb4\x82\xc9\xe1\xf8\xf9\xcbCr" +
	"{ \x16M#\xc6*\x9b\x18\x93\xbe__e3\xa3" +
	"E\x03Ib|&\x85\x06~D\x83\x1bD\xf4n\xb1" +
	"\x8a4\x00e3\xbd\xbdID\xef\xf3)\xc4\xb8\x95$" +
	"\x9f\x11\xd1\xbb\xf7\xca\x84\x91Zo\xa6\x849mX2" +
	"\"\xc9;\x9a\x1c\x88\x1a\x0d\x96_\x9dW\xbew\xb5\x1b" +
	"\x91\xbf\xb7\x08N6\xf8r\xc5J\xd4z\xd2\xd4\xcd\xb0" +
	"C\xb5\xa23~cE\x8f\xfdI$G\xb4\x92$`" +
	"\x95\x9bT\x10X\xfdM\xb4\xda\x99\x8a\xb24^\x10X" +
	"\xb4\x012\xbd\xd3\x8c^\x07\xa6\xf4\x9c\x012\xf5\xd3\xf9" +
	"\xc2\xcb\x17\xc8}F\xda\xa9P\x9fH\x85\x17\xedT\xd8" +
	"F~\xdab\x9d\x91\xcdig\xe4\xae\x94T\xd8A7" +
	"\xed\x97\xe2QW\x9cb<\x15\xf6\xd0\xe0\xcf\xe3\xa7\xa9" +
	"\x1c\xd4\xfa\x92\\Z\xd9\x1b\xea\xb3O\xbe!\x05,?" +
	"\x19#\x1am\"+\xe6M\x9dZ\xf0\xe6\xc0\x00\xbff" +
	"Su\xdb\xa9\x85\xb5N?U\xe9`\x89\x98}Z\xbf" +
	"/\xac\xeb]4\x96~NZ\x81k\x91\x1a\xeak\xaf" +
	"~\x93%Y@Z\x1a\xea\xc8]\xc9f\xf2Z\xab\x80" +
	"Rg_\x97\xb5xY\x8b\xf4D\xd3:\x0a\x19\xb1K" +
	"\x9eV\xd8\xf29\xea\x9b[Rv\xacU\xdf\xfc\xa8>" +
	"e\xc7Z\xf5\xcd\xe6[\x12\x9b\xf3E\x8a\xdd\x92x\xec" +
	"\x86D\xd9\xda\xc6\xdb\xeb\xed(\x0f\x89\x9d\xd9\xe1\x8f\x18" +
	"\xbd\xadZ\xaa\xfb+\xc3\xbd\xa1\xa0-\x11\xf5w\x04\xfc" +
	"\xc1\x9e(I$\xea\xf7\xa6h8\x14\x8b\xeaV\x0c+" +
	"\xfbBA} g\xa4\xf8\x19\xc5\xab\xe4\x82\xe4\xc2\xdb" +
	"h\xe1\xcd\"z\xe7$j\x02\x1a\x9cMV\xb6\x8a\xe8" +
	"m\xa7\x95\x8b\xf1\x95\xcf\xa5h\xcc\x12\xd1;_@y" +
	"@\xd7\"\x16\x05\xd1\xacF/\xba@@\x17\x11\x926" +
	"`=\xe7\xa4\x10~\xb5K\xde\xf1?/\x85\xa4^\x04" +
	"\xb3Q\xc8\xc2\xa6\x88\x16\xae\xef\xaf\xbf\xaa[f\x1a;" +
	"f(\xbfY\xack\xbc\xfa,\xcfr\xbb\xb8\x0a\x0eM" +
	"~\xb8\xccQ\xbe\xb7$\xfe\xb6JU\xabs\x95\xda\xd9" +
	"\xb3;Wz\xb5]\xac\xba\x85Kff\xb9\xea\x16/" +
	"\x9a\x89z\xb5\xca\xaeW\xe5e!\x7f\x17\xb8\xe4\x8e)" +
	"\x0dS\xd0c\x7f4I\x9c6ZC}-\xd9j}" +
	"=H\x9c6\xddu\x8d\xe8\xb1\x1b\xe99\xbc\xdc\xd2\xe4" +
	"\x8f\x84C\x11\xee\x94\xb2x\xdaU\xf3\x92\xab\xad\x0a\x00" +
	"\x05e:\xfd\x12\x95\x1b\xe8\x97C\x99H\xbf\x9c\xcaX" +
	"\xfa\xe5R\xca\xab\x01\xe4`(\xa8KK\xbb\xef\x92\x02" +
	"Z\xbf\x14\xed\x0eI\x81\xd82\xa9\xab{\xb9l\xe8Q" +
	"#\xc3a<\x1c\xf3\xf5\xfeD\x1e\xa6l\x8b\xaa\xd4m" +
	"\x91 \x84\xd9U\x89m\xb1\x84\xb6E\x82\xcc\x17S\xc0" +
	"n\x8fwi$#\xd9QA)`G.AGM" +
	"\x81\xa8\x912z\x05\xaeZ\x18O\xe6p@\x8cE\xaf" +
	"*\xa3S;\x9d\x9e\\\x0d\x8fV\xcd\x88\x1fdi\x1d" +
	"6\x0f\x80'\xde]\xcb\xa4\x91\xb8\xb3\xf6&\xf3\x8b\xcd" +
	"uV\x03\xf8f9E\xf4\xcdw\xa6\xa4\x18\xf3:K" +
	"\x00|s\x08\xb8\xdd)`\xb9p\xc9\x8c\xf3([\xe0" +
	"\xac\x02\xf0\xb5\x13\xf2UB\xc4\x8bf\x9cL\xd9\"\x8e" +
	"\xcc'd\x09!\x8eO\xcd\xf8\x8d\x91-\xe6\xc8\xed\x84" +
	"t\x11\xe2\xfc\x9b\x19\xa7U\xa6q\xe4\xab\x84\xf4\x12\xe2" +
	"\xba`:Tt\x010\x9d#K\x08\x09\x10\"\x9d7" +
	"\xf3\xd4\xf87\x1en[\x17!aB\xf2>\xa1y\xf2" +
	"\x00X\x1f\x7f\xa7\x97\x10\x83\x90a\xffC\xf3\x0c\x03`" +
	"ws$@H?!\xc3\xcf\xd1<\xc3\x01X\x8c#" +
	"aB\xee%$\xff\xaf4O>\x00\x1b\xe0\xf3\x18\x84" +
	"\xdcOH\xc1_\xccf\x15\x0b\x00\xd8}\xdcm\xfd\x84" +
	"\xac$\xb7\xb9?6Ut\x03\xb0\x078p/\x01\xab" +
	"\x09\xb8\xe6\xac\xa9\xe25\x00l\x15\x07\xee'\xe0a\x02" +
	"\xe4\x8fL\x15e\x00\xf6\x90s\x1a\x80o%\x01\x1b\x08" +
	"\xf0\xfc\xd9T)\x86l=\x07\x1e'\xe0E\x02\x94\xff" +
	"6UT\x00\xd86\x0el!`?\x01\x85gL\x15" +
	"\x0b\x01\xd8>\x0e\xfc\x9c\x80\xb7\x08`\x1f\x9a*2\x00" +
	"v\x8c\x03G\x08\xf8\x88\x00\xf5O\xa6\x8a*\x00;\xe3" +
	"\xac\x07\xf0\xfd\x91\x00\x87K@\xf7\x88\xd3\xa6\x8a#\x00" +
	"\x18\xba\xe8\x8d\x8b\x04\x14\x130\xf2\x03S\xc5\x91\x00l" +
	"\x04\x07<.\x11}\x13\x08(\xfa\xa3\xa9b\x11\x00\x1b" +
	"\xcf\x811\x044\x13P\xfc\x07S\xc5b\x006\xddE" +
	"sL%`>\x01e\xef\x9b*\x8e\xa2\x14s\x91K" +
	"\xe6\x10\xd0K@\xf9)S\xc5\x12\x8a\xbck\x06E\x9e" +
	"\x80\x87\x09\xa8\xf8/S\xc5R\xf2\x15W\xb5\x92\x80G" +
	"\x08\xa8|\xcfT\xb1\x0c\x80\xad\xe1\xc0j\x02\xd6\x11p" +
	"\xedIS\xc5r\x00\xb6\xd6\xd5\x01\xe0{\x84\x80-\x04" +
	"\x8c~\xd7T\xb1\x02\x80mv\xdd\x02\xe0{\x86\x80\x17" +
	"\x09\xa8\xfa\xbd\xa9b%y\xd7u\x07\x80\xefy\x02v" +
	"\x11\xf0\x85wL\x15\xaf\x05`;\\\xf3\x00|/\x11" +
	"\xb0\xd7%`\xf9\x98\x13\x94A\xa3\x01\xd8\x1en\xef." +
	"B\xf6\xd3+c\xdf6U\xac\xa2\x80\xf0\x15\xfe\x9c\x80" +
	"\xd7\x08\xb8\xee-S\xc5/\x00\xb0\x03\x1c\xd8K\xc0\xeb" +
	"\x04|\xf1w\xa6\x8ac\x00\xd8A\x17%\xe3~\x02\x8e" +
	"\x100\xee\xb8\xa9\xe2X\x00v\x88\xdb\xfb:\x01\x1f\x12" +
	"0\xfe\x98\xa9\xe2u\x00\xec\x03\x0e\xfc\x91\x00\x87$\xa0" +
	"{\xd4oM\x15\xbfH!\x94\xc8\xaa\x8b\x04\x14\x13P" +
	"\xf2\xa6\xa9\xe28\x0a!\x07<\x12\x85\x90\x80\xd27L" +
	"\x15\xc7S\x0890\x86\x80f\x02\xaa\x8f\x9a\x98\xf2\x7f" +
	"\x0bl\xbaT\x05\x82\xbb\xe6\x88\xa9\xe2\x04\x006V\xa2" +
	"E\\\x9b\xd43\xe1?M\x15'r=\xd3\x86\xe8\x99" +
	"x\xd8Tq\x12\xa5\x02\x07\xa6\x12\xd0J\xc0\xa4C\xa6" +
	"\x8a\xd7\x03\xb0\x16\x89|\xdbL\xc0\x1c\x02\xae\x7f\xddT" +
	"\xb1\x16\x80\xcd\xe6&\xb5\x12\xd0N@\xedoL\x15\xeb" +
	"\x88\xb8\xa4\x08%\x0f\x01\xb7K\xc9\x93M\xbc\xe7\x1e\xf4" +
	"\xd8\x1f/\xad\x03\xacqr\xb2o\xd4\xddP\x8f\xc3A" +
	"\xc0\xe1\x80\x92\xbfq\xb2U\xb0I\xfe\x86z\xab4\x93" +
	"\xfcu\x8dV\x85$\xfa\xa7\xa2\x00\x02\x0a\x80R\xacq" +
	"\xb2\xd5Q\x91b\x0d\xf5V\x93T\x8a\xd55\xa2\x04\x02" +
	"J\x80bl\xaaUA\xc9\x1d\xa1P\xc0*\xefR;" +
	"\xf6(w\x04B\x1dVC\xa1\xa9\xbbqrJ\xa3\xcf" +
	"j\x85u7\xd4\xa7\x8c\x0eO\x8c\xfa\x87\xc8:\xad\xd1" +
	"!\xb2\x0ek\xb4\xae1eT\x8c\x8fV\xfa\xa7\xa6\x0c" +
	"\x0a\x09\xd1\xd8\x10\xb5\xc3\xac\xd1!j\xf3\xac\xd1!j" +
	"\xa5\x84\xdaX\xaaZW|P\xbegH\x0335(" +
	"\xd7\x00\xae 4E \x97\\\xe5=T\xf9f\x1cq" +
	"\xf1q\x0d=\xf6?\xb1\xa4\x9d\x950\xb4\x7f\x9a\xd6K" +
	"\xb4\xc5\x00\xd2PR\x12ItSA\x0c\x05\xd1c\xff" +
	"[P\x02\xe6\x8d\xca\x0e-\x0a\x98\xa5r\\\xa1\xc5\x0b" +
	"\xa1\xb4k\x9cL\x81\xff?\xa8\xbb\xb8?\x96\xe9\x9d)" +
	"_a\xd3\xbf\xb0\xc5\x85\xb4t\xa1TO\xf1\x8f\xb6\xa1" +
	"P \xc5G\x89\x8f\xb6+\x12\xafZ\xc3\xee\xc40e" +
	"p\xcap\xa2\xf6\x91z\"\xe1\x1c\x1d\xff&\x1a\xb6/" +
	"\xb5CqJ%-8\xd0nD\x92];-8\xc0" +
	"\xfb\xe2\x80\x06\x16:\x10\x90FWhA~\xdb\xc0B" +
	"\x87\x10\x1f!\xb9\x9b\xb4\xb0\xd6\x01\x95\xfe\x80\xdf\x18\xc0" +
	"B\x87h!\xe9E\xb5\xd5\xe6\xac\xe47G\xde\x1f\xb0" +
	"\xff\xb7\x0a\xeb+o\xf6\xeb\x81\xae\\%|7\x81)" +
	"-\xab\xe4\x9b9J\xf8[\xf5\xa8\xa1G\xean\xd2\xc4" +
	"\x8c\xae~\xb5\xadV\x8e\x1a\x91\x9c\x97\xdd+|\xb7I" +
	"\xef\xa4\x0a\xe9\xfdn\xd4>\xcf5\xbc*\xe5\x8bR\x8e" +
	"~T\xe6\xe7\x85\x85\xf3\xf5\xa8q\x93\x16\xc6\xf4\xb5\xdd" +
	"\x91h\xf6M\x15\xd0\x0c\xeaQc\xaefD@\xf4\xf7" +
	"gl\xec+}\xc1H~\xb9A\xed2_}S\x0c" +
	"\xbel/\x96\x7f\xad\xc7\x9c\x9f\xb8\x0c,\xc4\x94\x8fv" +
	"\x00\x94@\xff\x1b\x00\x00\xff\xffU\xa8\xab\xe5"

func init() {
	schemas.Register(schema_832bcc6686a26d56,
		0x85257b30d6edf8c5,
		0x8748bc095e10cb5d,
		0x87c33f2330feb3d8,
		0x8821cdb23640783a,
		0x8a165fb4d71bf3a2,
		0x8e5322c1e9282534,
		0x8fae7b41c61fc890,
		0x93c99951eacc72ff,
		0x9430ab12c496d40c,
		0x94bf7df83408218d,
		0x95befe3f14606e6b,
		0x97e38948c61f878d,
		0x9ab599979b02ac59,
		0x9b37d729b9dd7b9d,
		0x9b8f27ba05e255c8,
		0x9c0550a706af8bd2,
		0x9d3032ff86043b75,
		0xa465f9502fd11e97,
		0xa8bf13fef2674866,
		0xabaedf5f7817c820,
		0xabd055422a4d7df1,
		0xad87da456fb0ebb9,
		0xb1ac056ed7647011,
		0xb1f0385d845e367f,
		0xb61ee2ecff34ca73,
		0xb72b6dc625baa6a4,
		0xb8fb64b8ed846ae6,
		0xbaa7b3b1ca91f833,
		0xbbcdbf4b4ae501fa,
		0xc7da65f9a2f20ba2,
		0xc8a79f2635d71e94,
		0xc95babe3bd394d2d,
		0xcbdc765fd5dff7ba,
		0xcc4411e60ba9c498,
		0xccb3b2e3603826e0,
		0xce44aee2d9e25049,
		0xcf9beaca1cc180c8,
		0xd636fba4f188dabe,
		0xd6514008f0f84ebc,
		0xd8bccf6e60a73791,
		0xd98c608877d9cb8d,
		0xddd1416669fb7613,
		0xde2a1a960863c11c,
		0xde50aebbad57549d,
		0xde9ed43cfaa83093,
		0xe1a2d1d51107bead,
		0xe1c9eac512335361,
		0xe508a29c83a059f8,
		0xe54e10aede55c7b1,
		0xe55d85fc1bf82f21,
		0xe5817f849ff906dc,
		0xe684eb3aef1a6859,
		0xe7711aada4bed56b,
		0xea26e9973bd6a0d9,
		0xecea3e9ebcbe5655,
		0xf14fad09425d081c,
		0xf58782f48a121998,
		0xf705dc45c94766fd,
		0xf7ff4414476c186a,
		0xfca3742893be4cde,
		0xfd3eb2db747ca085)
}

var x_832bcc6686a26d56 = []byte{
	0, 0, 0, 0, 2, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 0, 0,
	223, 7, 8, 27, 0, 0, 0, 0,
	0, 0, 0, 0, 4, 0, 0, 0,
	1, 0, 0, 0, 23, 0, 0, 0,
	8, 0, 0, 0, 1, 0, 0, 0,
	223, 7, 8, 27, 0, 0, 0, 0,
	223, 7, 8, 28, 0, 0, 0, 0,
	0, 0, 0, 0, 3, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 1, 0,
	42, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 3, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 1, 0,
	42, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
}
