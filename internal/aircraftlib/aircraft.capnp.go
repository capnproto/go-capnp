// Code generated by capnpc-go. DO NOT EDIT.

package aircraftlib

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	math "math"
	strconv "strconv"
)

// Constants defined in aircraft.capnp.
const (
	ConstEnum = Airport_jfk
)

// Constants defined in aircraft.capnp.
var (
	ConstDate = Zdate(capnp.MustUnmarshalRoot(x_832bcc6686a26d56[0:24]).Struct())
	ConstList = Zdate_List(capnp.MustUnmarshalRoot(x_832bcc6686a26d56[24:64]).List())
)

type Zdate capnp.Struct

// Zdate_TypeID is the unique identifier for the type Zdate.
const Zdate_TypeID = 0xde50aebbad57549d

func NewZdate(s *capnp.Segment) (Zdate, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Zdate(st), err
}

func NewRootZdate(s *capnp.Segment) (Zdate, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Zdate(st), err
}

func ReadRootZdate(msg *capnp.Message) (Zdate, error) {
	root, err := msg.Root()
	return Zdate(root.Struct()), err
}

func (s Zdate) String() string {
	str, _ := text.Marshal(0xde50aebbad57549d, capnp.Struct(s))
	return str
}

func (s Zdate) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Zdate) DecodeFromPtr(p capnp.Ptr) Zdate {
	return Zdate(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Zdate) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Zdate) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Zdate) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Zdate) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Zdate) Year() int16 {
	return int16(capnp.Struct(s).Uint16(0))
}

func (s Zdate) SetYear(v int16) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Zdate) Month() uint8 {
	return capnp.Struct(s).Uint8(2)
}

func (s Zdate) SetMonth(v uint8) {
	capnp.Struct(s).SetUint8(2, v)
}

func (s Zdate) Day() uint8 {
	return capnp.Struct(s).Uint8(3)
}

func (s Zdate) SetDay(v uint8) {
	capnp.Struct(s).SetUint8(3, v)
}

// Zdate_List is a list of Zdate.
type Zdate_List = capnp.StructList[Zdate]

// NewZdate creates a new list of Zdate.
func NewZdate_List(s *capnp.Segment, sz int32) (Zdate_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Zdate](l), err
}

// Zdate_Future is a wrapper for a Zdate promised by a client call.
type Zdate_Future struct{ *capnp.Future }

func (f Zdate_Future) Struct() (Zdate, error) {
	p, err := f.Future.Ptr()
	return Zdate(p.Struct()), err
}

type Zdata capnp.Struct

// Zdata_TypeID is the unique identifier for the type Zdata.
const Zdata_TypeID = 0xc7da65f9a2f20ba2

func NewZdata(s *capnp.Segment) (Zdata, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Zdata(st), err
}

func NewRootZdata(s *capnp.Segment) (Zdata, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Zdata(st), err
}

func ReadRootZdata(msg *capnp.Message) (Zdata, error) {
	root, err := msg.Root()
	return Zdata(root.Struct()), err
}

func (s Zdata) String() string {
	str, _ := text.Marshal(0xc7da65f9a2f20ba2, capnp.Struct(s))
	return str
}

func (s Zdata) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Zdata) DecodeFromPtr(p capnp.Ptr) Zdata {
	return Zdata(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Zdata) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Zdata) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Zdata) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Zdata) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Zdata) Data() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Zdata) HasData() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Zdata) SetData(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// Zdata_List is a list of Zdata.
type Zdata_List = capnp.StructList[Zdata]

// NewZdata creates a new list of Zdata.
func NewZdata_List(s *capnp.Segment, sz int32) (Zdata_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Zdata](l), err
}

// Zdata_Future is a wrapper for a Zdata promised by a client call.
type Zdata_Future struct{ *capnp.Future }

func (f Zdata_Future) Struct() (Zdata, error) {
	p, err := f.Future.Ptr()
	return Zdata(p.Struct()), err
}

type Airport uint16

// Airport_TypeID is the unique identifier for the type Airport.
const Airport_TypeID = 0xe55d85fc1bf82f21

// Values of Airport.
const (
	Airport_none Airport = 0
	Airport_jfk  Airport = 1
	Airport_lax  Airport = 2
	Airport_sfo  Airport = 3
	Airport_luv  Airport = 4
	Airport_dfw  Airport = 5
	Airport_test Airport = 6
)

// String returns the enum's constant name.
func (c Airport) String() string {
	switch c {
	case Airport_none:
		return "none"
	case Airport_jfk:
		return "jfk"
	case Airport_lax:
		return "lax"
	case Airport_sfo:
		return "sfo"
	case Airport_luv:
		return "luv"
	case Airport_dfw:
		return "dfw"
	case Airport_test:
		return "test"

	default:
		return ""
	}
}

// AirportFromString returns the enum value with a name,
// or the zero value if there's no such value.
func AirportFromString(c string) Airport {
	switch c {
	case "none":
		return Airport_none
	case "jfk":
		return Airport_jfk
	case "lax":
		return Airport_lax
	case "sfo":
		return Airport_sfo
	case "luv":
		return Airport_luv
	case "dfw":
		return Airport_dfw
	case "test":
		return Airport_test

	default:
		return 0
	}
}

type Airport_List = capnp.EnumList[Airport]

func NewAirport_List(s *capnp.Segment, sz int32) (Airport_List, error) {
	return capnp.NewEnumList[Airport](s, sz)
}

type PlaneBase capnp.Struct

// PlaneBase_TypeID is the unique identifier for the type PlaneBase.
const PlaneBase_TypeID = 0xd8bccf6e60a73791

func NewPlaneBase(s *capnp.Segment) (PlaneBase, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 2})
	return PlaneBase(st), err
}

func NewRootPlaneBase(s *capnp.Segment) (PlaneBase, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 2})
	return PlaneBase(st), err
}

func ReadRootPlaneBase(msg *capnp.Message) (PlaneBase, error) {
	root, err := msg.Root()
	return PlaneBase(root.Struct()), err
}

func (s PlaneBase) String() string {
	str, _ := text.Marshal(0xd8bccf6e60a73791, capnp.Struct(s))
	return str
}

func (s PlaneBase) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (PlaneBase) DecodeFromPtr(p capnp.Ptr) PlaneBase {
	return PlaneBase(capnp.Struct{}.DecodeFromPtr(p))
}

func (s PlaneBase) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s PlaneBase) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s PlaneBase) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s PlaneBase) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s PlaneBase) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s PlaneBase) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s PlaneBase) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s PlaneBase) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s PlaneBase) Homes() (Airport_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Airport_List(p.List()), err
}

func (s PlaneBase) HasHomes() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s PlaneBase) SetHomes(v Airport_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewHomes sets the homes field to a newly
// allocated Airport_List, preferring placement in s's segment.
func (s PlaneBase) NewHomes(n int32) (Airport_List, error) {
	l, err := NewAirport_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Airport_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s PlaneBase) Rating() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s PlaneBase) SetRating(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s PlaneBase) CanFly() bool {
	return capnp.Struct(s).Bit(64)
}

func (s PlaneBase) SetCanFly(v bool) {
	capnp.Struct(s).SetBit(64, v)
}

func (s PlaneBase) Capacity() int64 {
	return int64(capnp.Struct(s).Uint64(16))
}

func (s PlaneBase) SetCapacity(v int64) {
	capnp.Struct(s).SetUint64(16, uint64(v))
}

func (s PlaneBase) MaxSpeed() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s PlaneBase) SetMaxSpeed(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

// PlaneBase_List is a list of PlaneBase.
type PlaneBase_List = capnp.StructList[PlaneBase]

// NewPlaneBase creates a new list of PlaneBase.
func NewPlaneBase_List(s *capnp.Segment, sz int32) (PlaneBase_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 32, PointerCount: 2}, sz)
	return capnp.StructList[PlaneBase](l), err
}

// PlaneBase_Future is a wrapper for a PlaneBase promised by a client call.
type PlaneBase_Future struct{ *capnp.Future }

func (f PlaneBase_Future) Struct() (PlaneBase, error) {
	p, err := f.Future.Ptr()
	return PlaneBase(p.Struct()), err
}

type B737 capnp.Struct

// B737_TypeID is the unique identifier for the type B737.
const B737_TypeID = 0xccb3b2e3603826e0

func NewB737(s *capnp.Segment) (B737, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return B737(st), err
}

func NewRootB737(s *capnp.Segment) (B737, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return B737(st), err
}

func ReadRootB737(msg *capnp.Message) (B737, error) {
	root, err := msg.Root()
	return B737(root.Struct()), err
}

func (s B737) String() string {
	str, _ := text.Marshal(0xccb3b2e3603826e0, capnp.Struct(s))
	return str
}

func (s B737) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (B737) DecodeFromPtr(p capnp.Ptr) B737 {
	return B737(capnp.Struct{}.DecodeFromPtr(p))
}

func (s B737) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s B737) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s B737) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s B737) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s B737) Base() (PlaneBase, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return PlaneBase(p.Struct()), err
}

func (s B737) HasBase() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s B737) SetBase(v PlaneBase) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewBase sets the base field to a newly
// allocated PlaneBase struct, preferring placement in s's segment.
func (s B737) NewBase() (PlaneBase, error) {
	ss, err := NewPlaneBase(capnp.Struct(s).Segment())
	if err != nil {
		return PlaneBase{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// B737_List is a list of B737.
type B737_List = capnp.StructList[B737]

// NewB737 creates a new list of B737.
func NewB737_List(s *capnp.Segment, sz int32) (B737_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[B737](l), err
}

// B737_Future is a wrapper for a B737 promised by a client call.
type B737_Future struct{ *capnp.Future }

func (f B737_Future) Struct() (B737, error) {
	p, err := f.Future.Ptr()
	return B737(p.Struct()), err
}
func (p B737_Future) Base() PlaneBase_Future {
	return PlaneBase_Future{Future: p.Future.Field(0, nil)}
}

type A320 capnp.Struct

// A320_TypeID is the unique identifier for the type A320.
const A320_TypeID = 0xd98c608877d9cb8d

func NewA320(s *capnp.Segment) (A320, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return A320(st), err
}

func NewRootA320(s *capnp.Segment) (A320, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return A320(st), err
}

func ReadRootA320(msg *capnp.Message) (A320, error) {
	root, err := msg.Root()
	return A320(root.Struct()), err
}

func (s A320) String() string {
	str, _ := text.Marshal(0xd98c608877d9cb8d, capnp.Struct(s))
	return str
}

func (s A320) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (A320) DecodeFromPtr(p capnp.Ptr) A320 {
	return A320(capnp.Struct{}.DecodeFromPtr(p))
}

func (s A320) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s A320) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s A320) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s A320) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s A320) Base() (PlaneBase, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return PlaneBase(p.Struct()), err
}

func (s A320) HasBase() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s A320) SetBase(v PlaneBase) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewBase sets the base field to a newly
// allocated PlaneBase struct, preferring placement in s's segment.
func (s A320) NewBase() (PlaneBase, error) {
	ss, err := NewPlaneBase(capnp.Struct(s).Segment())
	if err != nil {
		return PlaneBase{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// A320_List is a list of A320.
type A320_List = capnp.StructList[A320]

// NewA320 creates a new list of A320.
func NewA320_List(s *capnp.Segment, sz int32) (A320_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[A320](l), err
}

// A320_Future is a wrapper for a A320 promised by a client call.
type A320_Future struct{ *capnp.Future }

func (f A320_Future) Struct() (A320, error) {
	p, err := f.Future.Ptr()
	return A320(p.Struct()), err
}
func (p A320_Future) Base() PlaneBase_Future {
	return PlaneBase_Future{Future: p.Future.Field(0, nil)}
}

type F16 capnp.Struct

// F16_TypeID is the unique identifier for the type F16.
const F16_TypeID = 0xe1c9eac512335361

func NewF16(s *capnp.Segment) (F16, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return F16(st), err
}

func NewRootF16(s *capnp.Segment) (F16, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return F16(st), err
}

func ReadRootF16(msg *capnp.Message) (F16, error) {
	root, err := msg.Root()
	return F16(root.Struct()), err
}

func (s F16) String() string {
	str, _ := text.Marshal(0xe1c9eac512335361, capnp.Struct(s))
	return str
}

func (s F16) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (F16) DecodeFromPtr(p capnp.Ptr) F16 {
	return F16(capnp.Struct{}.DecodeFromPtr(p))
}

func (s F16) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s F16) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s F16) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s F16) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s F16) Base() (PlaneBase, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return PlaneBase(p.Struct()), err
}

func (s F16) HasBase() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s F16) SetBase(v PlaneBase) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewBase sets the base field to a newly
// allocated PlaneBase struct, preferring placement in s's segment.
func (s F16) NewBase() (PlaneBase, error) {
	ss, err := NewPlaneBase(capnp.Struct(s).Segment())
	if err != nil {
		return PlaneBase{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// F16_List is a list of F16.
type F16_List = capnp.StructList[F16]

// NewF16 creates a new list of F16.
func NewF16_List(s *capnp.Segment, sz int32) (F16_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[F16](l), err
}

// F16_Future is a wrapper for a F16 promised by a client call.
type F16_Future struct{ *capnp.Future }

func (f F16_Future) Struct() (F16, error) {
	p, err := f.Future.Ptr()
	return F16(p.Struct()), err
}
func (p F16_Future) Base() PlaneBase_Future {
	return PlaneBase_Future{Future: p.Future.Field(0, nil)}
}

type Regression capnp.Struct

// Regression_TypeID is the unique identifier for the type Regression.
const Regression_TypeID = 0xb1f0385d845e367f

func NewRegression(s *capnp.Segment) (Regression, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3})
	return Regression(st), err
}

func NewRootRegression(s *capnp.Segment) (Regression, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3})
	return Regression(st), err
}

func ReadRootRegression(msg *capnp.Message) (Regression, error) {
	root, err := msg.Root()
	return Regression(root.Struct()), err
}

func (s Regression) String() string {
	str, _ := text.Marshal(0xb1f0385d845e367f, capnp.Struct(s))
	return str
}

func (s Regression) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Regression) DecodeFromPtr(p capnp.Ptr) Regression {
	return Regression(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Regression) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Regression) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Regression) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Regression) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Regression) Base() (PlaneBase, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return PlaneBase(p.Struct()), err
}

func (s Regression) HasBase() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Regression) SetBase(v PlaneBase) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewBase sets the base field to a newly
// allocated PlaneBase struct, preferring placement in s's segment.
func (s Regression) NewBase() (PlaneBase, error) {
	ss, err := NewPlaneBase(capnp.Struct(s).Segment())
	if err != nil {
		return PlaneBase{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Regression) B0() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Regression) SetB0(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Regression) Beta() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.Float64List(p.List()), err
}

func (s Regression) HasBeta() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Regression) SetBeta(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewBeta sets the beta field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Regression) NewBeta(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Regression) Planes() (Aircraft_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Aircraft_List(p.List()), err
}

func (s Regression) HasPlanes() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Regression) SetPlanes(v Aircraft_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewPlanes sets the planes field to a newly
// allocated Aircraft_List, preferring placement in s's segment.
func (s Regression) NewPlanes(n int32) (Aircraft_List, error) {
	l, err := NewAircraft_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Aircraft_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Regression) Ymu() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Regression) SetYmu(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Regression) Ysd() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Regression) SetYsd(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// Regression_List is a list of Regression.
type Regression_List = capnp.StructList[Regression]

// NewRegression creates a new list of Regression.
func NewRegression_List(s *capnp.Segment, sz int32) (Regression_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3}, sz)
	return capnp.StructList[Regression](l), err
}

// Regression_Future is a wrapper for a Regression promised by a client call.
type Regression_Future struct{ *capnp.Future }

func (f Regression_Future) Struct() (Regression, error) {
	p, err := f.Future.Ptr()
	return Regression(p.Struct()), err
}
func (p Regression_Future) Base() PlaneBase_Future {
	return PlaneBase_Future{Future: p.Future.Field(0, nil)}
}

type Aircraft capnp.Struct
type Aircraft_Which uint16

const (
	Aircraft_Which_void Aircraft_Which = 0
	Aircraft_Which_b737 Aircraft_Which = 1
	Aircraft_Which_a320 Aircraft_Which = 2
	Aircraft_Which_f16  Aircraft_Which = 3
)

func (w Aircraft_Which) String() string {
	const s = "voidb737a320f16"
	switch w {
	case Aircraft_Which_void:
		return s[0:4]
	case Aircraft_Which_b737:
		return s[4:8]
	case Aircraft_Which_a320:
		return s[8:12]
	case Aircraft_Which_f16:
		return s[12:15]

	}
	return "Aircraft_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Aircraft_TypeID is the unique identifier for the type Aircraft.
const Aircraft_TypeID = 0xe54e10aede55c7b1

func NewAircraft(s *capnp.Segment) (Aircraft, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Aircraft(st), err
}

func NewRootAircraft(s *capnp.Segment) (Aircraft, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Aircraft(st), err
}

func ReadRootAircraft(msg *capnp.Message) (Aircraft, error) {
	root, err := msg.Root()
	return Aircraft(root.Struct()), err
}

func (s Aircraft) String() string {
	str, _ := text.Marshal(0xe54e10aede55c7b1, capnp.Struct(s))
	return str
}

func (s Aircraft) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Aircraft) DecodeFromPtr(p capnp.Ptr) Aircraft {
	return Aircraft(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Aircraft) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Aircraft) Which() Aircraft_Which {
	return Aircraft_Which(capnp.Struct(s).Uint16(0))
}
func (s Aircraft) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Aircraft) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Aircraft) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Aircraft) SetVoid() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Aircraft) B737() (B737, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != b737")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return B737(p.Struct()), err
}

func (s Aircraft) HasB737() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Aircraft) SetB737(v B737) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewB737 sets the b737 field to a newly
// allocated B737 struct, preferring placement in s's segment.
func (s Aircraft) NewB737() (B737, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewB737(capnp.Struct(s).Segment())
	if err != nil {
		return B737{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Aircraft) A320() (A320, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != a320")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return A320(p.Struct()), err
}

func (s Aircraft) HasA320() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Aircraft) SetA320(v A320) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewA320 sets the a320 field to a newly
// allocated A320 struct, preferring placement in s's segment.
func (s Aircraft) NewA320() (A320, error) {
	capnp.Struct(s).SetUint16(0, 2)
	ss, err := NewA320(capnp.Struct(s).Segment())
	if err != nil {
		return A320{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Aircraft) F16() (F16, error) {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != f16")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return F16(p.Struct()), err
}

func (s Aircraft) HasF16() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Aircraft) SetF16(v F16) error {
	capnp.Struct(s).SetUint16(0, 3)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewF16 sets the f16 field to a newly
// allocated F16 struct, preferring placement in s's segment.
func (s Aircraft) NewF16() (F16, error) {
	capnp.Struct(s).SetUint16(0, 3)
	ss, err := NewF16(capnp.Struct(s).Segment())
	if err != nil {
		return F16{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Aircraft_List is a list of Aircraft.
type Aircraft_List = capnp.StructList[Aircraft]

// NewAircraft creates a new list of Aircraft.
func NewAircraft_List(s *capnp.Segment, sz int32) (Aircraft_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Aircraft](l), err
}

// Aircraft_Future is a wrapper for a Aircraft promised by a client call.
type Aircraft_Future struct{ *capnp.Future }

func (f Aircraft_Future) Struct() (Aircraft, error) {
	p, err := f.Future.Ptr()
	return Aircraft(p.Struct()), err
}
func (p Aircraft_Future) B737() B737_Future {
	return B737_Future{Future: p.Future.Field(0, nil)}
}
func (p Aircraft_Future) A320() A320_Future {
	return A320_Future{Future: p.Future.Field(0, nil)}
}
func (p Aircraft_Future) F16() F16_Future {
	return F16_Future{Future: p.Future.Field(0, nil)}
}

type Z capnp.Struct
type Z_grp Z
type Z_Which uint16

const (
	Z_Which_void          Z_Which = 0
	Z_Which_zz            Z_Which = 1
	Z_Which_f64           Z_Which = 2
	Z_Which_f32           Z_Which = 3
	Z_Which_i64           Z_Which = 4
	Z_Which_i32           Z_Which = 5
	Z_Which_i16           Z_Which = 6
	Z_Which_i8            Z_Which = 7
	Z_Which_u64           Z_Which = 8
	Z_Which_u32           Z_Which = 9
	Z_Which_u16           Z_Which = 10
	Z_Which_u8            Z_Which = 11
	Z_Which_bool          Z_Which = 12
	Z_Which_text          Z_Which = 13
	Z_Which_blob          Z_Which = 14
	Z_Which_f64vec        Z_Which = 15
	Z_Which_f32vec        Z_Which = 16
	Z_Which_i64vec        Z_Which = 17
	Z_Which_i32vec        Z_Which = 18
	Z_Which_i16vec        Z_Which = 19
	Z_Which_i8vec         Z_Which = 20
	Z_Which_u64vec        Z_Which = 21
	Z_Which_u32vec        Z_Which = 22
	Z_Which_u16vec        Z_Which = 23
	Z_Which_u8vec         Z_Which = 24
	Z_Which_boolvec       Z_Which = 39
	Z_Which_datavec       Z_Which = 40
	Z_Which_textvec       Z_Which = 41
	Z_Which_zvec          Z_Which = 25
	Z_Which_zvecvec       Z_Which = 26
	Z_Which_zdate         Z_Which = 27
	Z_Which_zdata         Z_Which = 28
	Z_Which_aircraftvec   Z_Which = 29
	Z_Which_aircraft      Z_Which = 30
	Z_Which_regression    Z_Which = 31
	Z_Which_planebase     Z_Which = 32
	Z_Which_airport       Z_Which = 33
	Z_Which_b737          Z_Which = 34
	Z_Which_a320          Z_Which = 35
	Z_Which_f16           Z_Which = 36
	Z_Which_zdatevec      Z_Which = 37
	Z_Which_zdatavec      Z_Which = 38
	Z_Which_grp           Z_Which = 42
	Z_Which_echo          Z_Which = 43
	Z_Which_echoes        Z_Which = 44
	Z_Which_anyPtr        Z_Which = 45
	Z_Which_anyStruct     Z_Which = 46
	Z_Which_anyList       Z_Which = 47
	Z_Which_anyCapability Z_Which = 48
)

func (w Z_Which) String() string {
	const s = "voidzzf64f32i64i32i16i8u64u32u16u8booltextblobf64vecf32veci64veci32veci16veci8vecu64vecu32vecu16vecu8vecboolvecdatavectextveczveczvecveczdatezdataaircraftvecaircraftregressionplanebaseairportb737a320f16zdateveczdatavecgrpechoechoesanyPtranyStructanyListanyCapability"
	switch w {
	case Z_Which_void:
		return s[0:4]
	case Z_Which_zz:
		return s[4:6]
	case Z_Which_f64:
		return s[6:9]
	case Z_Which_f32:
		return s[9:12]
	case Z_Which_i64:
		return s[12:15]
	case Z_Which_i32:
		return s[15:18]
	case Z_Which_i16:
		return s[18:21]
	case Z_Which_i8:
		return s[21:23]
	case Z_Which_u64:
		return s[23:26]
	case Z_Which_u32:
		return s[26:29]
	case Z_Which_u16:
		return s[29:32]
	case Z_Which_u8:
		return s[32:34]
	case Z_Which_bool:
		return s[34:38]
	case Z_Which_text:
		return s[38:42]
	case Z_Which_blob:
		return s[42:46]
	case Z_Which_f64vec:
		return s[46:52]
	case Z_Which_f32vec:
		return s[52:58]
	case Z_Which_i64vec:
		return s[58:64]
	case Z_Which_i32vec:
		return s[64:70]
	case Z_Which_i16vec:
		return s[70:76]
	case Z_Which_i8vec:
		return s[76:81]
	case Z_Which_u64vec:
		return s[81:87]
	case Z_Which_u32vec:
		return s[87:93]
	case Z_Which_u16vec:
		return s[93:99]
	case Z_Which_u8vec:
		return s[99:104]
	case Z_Which_boolvec:
		return s[104:111]
	case Z_Which_datavec:
		return s[111:118]
	case Z_Which_textvec:
		return s[118:125]
	case Z_Which_zvec:
		return s[125:129]
	case Z_Which_zvecvec:
		return s[129:136]
	case Z_Which_zdate:
		return s[136:141]
	case Z_Which_zdata:
		return s[141:146]
	case Z_Which_aircraftvec:
		return s[146:157]
	case Z_Which_aircraft:
		return s[157:165]
	case Z_Which_regression:
		return s[165:175]
	case Z_Which_planebase:
		return s[175:184]
	case Z_Which_airport:
		return s[184:191]
	case Z_Which_b737:
		return s[191:195]
	case Z_Which_a320:
		return s[195:199]
	case Z_Which_f16:
		return s[199:202]
	case Z_Which_zdatevec:
		return s[202:210]
	case Z_Which_zdatavec:
		return s[210:218]
	case Z_Which_grp:
		return s[218:221]
	case Z_Which_echo:
		return s[221:225]
	case Z_Which_echoes:
		return s[225:231]
	case Z_Which_anyPtr:
		return s[231:237]
	case Z_Which_anyStruct:
		return s[237:246]
	case Z_Which_anyList:
		return s[246:253]
	case Z_Which_anyCapability:
		return s[253:266]

	}
	return "Z_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Z_TypeID is the unique identifier for the type Z.
const Z_TypeID = 0xea26e9973bd6a0d9

func NewZ(s *capnp.Segment) (Z, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return Z(st), err
}

func NewRootZ(s *capnp.Segment) (Z, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return Z(st), err
}

func ReadRootZ(msg *capnp.Message) (Z, error) {
	root, err := msg.Root()
	return Z(root.Struct()), err
}

func (s Z) String() string {
	str, _ := text.Marshal(0xea26e9973bd6a0d9, capnp.Struct(s))
	return str
}

func (s Z) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Z) DecodeFromPtr(p capnp.Ptr) Z {
	return Z(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Z) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Z) Which() Z_Which {
	return Z_Which(capnp.Struct(s).Uint16(0))
}
func (s Z) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Z) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Z) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Z) SetVoid() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Z) Zz() (Z, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != zz")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Z(p.Struct()), err
}

func (s Z) HasZz() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetZz(v Z) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewZz sets the zz field to a newly
// allocated Z struct, preferring placement in s's segment.
func (s Z) NewZz() (Z, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewZ(capnp.Struct(s).Segment())
	if err != nil {
		return Z{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Z) F64() float64 {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != f64")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Z) SetF64(v float64) {
	capnp.Struct(s).SetUint16(0, 2)
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Z) F32() float32 {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != f32")
	}
	return math.Float32frombits(capnp.Struct(s).Uint32(8))
}

func (s Z) SetF32(v float32) {
	capnp.Struct(s).SetUint16(0, 3)
	capnp.Struct(s).SetUint32(8, math.Float32bits(v))
}

func (s Z) I64() int64 {
	if capnp.Struct(s).Uint16(0) != 4 {
		panic("Which() != i64")
	}
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Z) SetI64(v int64) {
	capnp.Struct(s).SetUint16(0, 4)
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s Z) I32() int32 {
	if capnp.Struct(s).Uint16(0) != 5 {
		panic("Which() != i32")
	}
	return int32(capnp.Struct(s).Uint32(8))
}

func (s Z) SetI32(v int32) {
	capnp.Struct(s).SetUint16(0, 5)
	capnp.Struct(s).SetUint32(8, uint32(v))
}

func (s Z) I16() int16 {
	if capnp.Struct(s).Uint16(0) != 6 {
		panic("Which() != i16")
	}
	return int16(capnp.Struct(s).Uint16(8))
}

func (s Z) SetI16(v int16) {
	capnp.Struct(s).SetUint16(0, 6)
	capnp.Struct(s).SetUint16(8, uint16(v))
}

func (s Z) I8() int8 {
	if capnp.Struct(s).Uint16(0) != 7 {
		panic("Which() != i8")
	}
	return int8(capnp.Struct(s).Uint8(8))
}

func (s Z) SetI8(v int8) {
	capnp.Struct(s).SetUint16(0, 7)
	capnp.Struct(s).SetUint8(8, uint8(v))
}

func (s Z) U64() uint64 {
	if capnp.Struct(s).Uint16(0) != 8 {
		panic("Which() != u64")
	}
	return capnp.Struct(s).Uint64(8)
}

func (s Z) SetU64(v uint64) {
	capnp.Struct(s).SetUint16(0, 8)
	capnp.Struct(s).SetUint64(8, v)
}

func (s Z) U32() uint32 {
	if capnp.Struct(s).Uint16(0) != 9 {
		panic("Which() != u32")
	}
	return capnp.Struct(s).Uint32(8)
}

func (s Z) SetU32(v uint32) {
	capnp.Struct(s).SetUint16(0, 9)
	capnp.Struct(s).SetUint32(8, v)
}

func (s Z) U16() uint16 {
	if capnp.Struct(s).Uint16(0) != 10 {
		panic("Which() != u16")
	}
	return capnp.Struct(s).Uint16(8)
}

func (s Z) SetU16(v uint16) {
	capnp.Struct(s).SetUint16(0, 10)
	capnp.Struct(s).SetUint16(8, v)
}

func (s Z) U8() uint8 {
	if capnp.Struct(s).Uint16(0) != 11 {
		panic("Which() != u8")
	}
	return capnp.Struct(s).Uint8(8)
}

func (s Z) SetU8(v uint8) {
	capnp.Struct(s).SetUint16(0, 11)
	capnp.Struct(s).SetUint8(8, v)
}

func (s Z) Bool() bool {
	if capnp.Struct(s).Uint16(0) != 12 {
		panic("Which() != bool")
	}
	return capnp.Struct(s).Bit(64)
}

func (s Z) SetBool(v bool) {
	capnp.Struct(s).SetUint16(0, 12)
	capnp.Struct(s).SetBit(64, v)
}

func (s Z) Text() (string, error) {
	if capnp.Struct(s).Uint16(0) != 13 {
		panic("Which() != text")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Z) HasText() bool {
	if capnp.Struct(s).Uint16(0) != 13 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) TextBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Z) SetText(v string) error {
	capnp.Struct(s).SetUint16(0, 13)
	return capnp.Struct(s).SetText(0, v)
}

func (s Z) Blob() ([]byte, error) {
	if capnp.Struct(s).Uint16(0) != 14 {
		panic("Which() != blob")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Z) HasBlob() bool {
	if capnp.Struct(s).Uint16(0) != 14 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetBlob(v []byte) error {
	capnp.Struct(s).SetUint16(0, 14)
	return capnp.Struct(s).SetData(0, v)
}

func (s Z) F64vec() (capnp.Float64List, error) {
	if capnp.Struct(s).Uint16(0) != 15 {
		panic("Which() != f64vec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Float64List(p.List()), err
}

func (s Z) HasF64vec() bool {
	if capnp.Struct(s).Uint16(0) != 15 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetF64vec(v capnp.Float64List) error {
	capnp.Struct(s).SetUint16(0, 15)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewF64vec sets the f64vec field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Z) NewF64vec(n int32) (capnp.Float64List, error) {
	capnp.Struct(s).SetUint16(0, 15)
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) F32vec() (capnp.Float32List, error) {
	if capnp.Struct(s).Uint16(0) != 16 {
		panic("Which() != f32vec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Float32List(p.List()), err
}

func (s Z) HasF32vec() bool {
	if capnp.Struct(s).Uint16(0) != 16 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetF32vec(v capnp.Float32List) error {
	capnp.Struct(s).SetUint16(0, 16)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewF32vec sets the f32vec field to a newly
// allocated capnp.Float32List, preferring placement in s's segment.
func (s Z) NewF32vec(n int32) (capnp.Float32List, error) {
	capnp.Struct(s).SetUint16(0, 16)
	l, err := capnp.NewFloat32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float32List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) I64vec() (capnp.Int64List, error) {
	if capnp.Struct(s).Uint16(0) != 17 {
		panic("Which() != i64vec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Int64List(p.List()), err
}

func (s Z) HasI64vec() bool {
	if capnp.Struct(s).Uint16(0) != 17 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetI64vec(v capnp.Int64List) error {
	capnp.Struct(s).SetUint16(0, 17)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewI64vec sets the i64vec field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s Z) NewI64vec(n int32) (capnp.Int64List, error) {
	capnp.Struct(s).SetUint16(0, 17)
	l, err := capnp.NewInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) I32vec() (capnp.Int32List, error) {
	if capnp.Struct(s).Uint16(0) != 18 {
		panic("Which() != i32vec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Int32List(p.List()), err
}

func (s Z) HasI32vec() bool {
	if capnp.Struct(s).Uint16(0) != 18 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetI32vec(v capnp.Int32List) error {
	capnp.Struct(s).SetUint16(0, 18)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewI32vec sets the i32vec field to a newly
// allocated capnp.Int32List, preferring placement in s's segment.
func (s Z) NewI32vec(n int32) (capnp.Int32List, error) {
	capnp.Struct(s).SetUint16(0, 18)
	l, err := capnp.NewInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int32List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) I16vec() (capnp.Int16List, error) {
	if capnp.Struct(s).Uint16(0) != 19 {
		panic("Which() != i16vec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Int16List(p.List()), err
}

func (s Z) HasI16vec() bool {
	if capnp.Struct(s).Uint16(0) != 19 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetI16vec(v capnp.Int16List) error {
	capnp.Struct(s).SetUint16(0, 19)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewI16vec sets the i16vec field to a newly
// allocated capnp.Int16List, preferring placement in s's segment.
func (s Z) NewI16vec(n int32) (capnp.Int16List, error) {
	capnp.Struct(s).SetUint16(0, 19)
	l, err := capnp.NewInt16List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int16List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) I8vec() (capnp.Int8List, error) {
	if capnp.Struct(s).Uint16(0) != 20 {
		panic("Which() != i8vec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Int8List(p.List()), err
}

func (s Z) HasI8vec() bool {
	if capnp.Struct(s).Uint16(0) != 20 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetI8vec(v capnp.Int8List) error {
	capnp.Struct(s).SetUint16(0, 20)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewI8vec sets the i8vec field to a newly
// allocated capnp.Int8List, preferring placement in s's segment.
func (s Z) NewI8vec(n int32) (capnp.Int8List, error) {
	capnp.Struct(s).SetUint16(0, 20)
	l, err := capnp.NewInt8List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int8List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) U64vec() (capnp.UInt64List, error) {
	if capnp.Struct(s).Uint16(0) != 21 {
		panic("Which() != u64vec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.UInt64List(p.List()), err
}

func (s Z) HasU64vec() bool {
	if capnp.Struct(s).Uint16(0) != 21 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetU64vec(v capnp.UInt64List) error {
	capnp.Struct(s).SetUint16(0, 21)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewU64vec sets the u64vec field to a newly
// allocated capnp.UInt64List, preferring placement in s's segment.
func (s Z) NewU64vec(n int32) (capnp.UInt64List, error) {
	capnp.Struct(s).SetUint16(0, 21)
	l, err := capnp.NewUInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt64List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) U32vec() (capnp.UInt32List, error) {
	if capnp.Struct(s).Uint16(0) != 22 {
		panic("Which() != u32vec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.UInt32List(p.List()), err
}

func (s Z) HasU32vec() bool {
	if capnp.Struct(s).Uint16(0) != 22 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetU32vec(v capnp.UInt32List) error {
	capnp.Struct(s).SetUint16(0, 22)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewU32vec sets the u32vec field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s Z) NewU32vec(n int32) (capnp.UInt32List, error) {
	capnp.Struct(s).SetUint16(0, 22)
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) U16vec() (capnp.UInt16List, error) {
	if capnp.Struct(s).Uint16(0) != 23 {
		panic("Which() != u16vec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.UInt16List(p.List()), err
}

func (s Z) HasU16vec() bool {
	if capnp.Struct(s).Uint16(0) != 23 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetU16vec(v capnp.UInt16List) error {
	capnp.Struct(s).SetUint16(0, 23)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewU16vec sets the u16vec field to a newly
// allocated capnp.UInt16List, preferring placement in s's segment.
func (s Z) NewU16vec(n int32) (capnp.UInt16List, error) {
	capnp.Struct(s).SetUint16(0, 23)
	l, err := capnp.NewUInt16List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt16List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) U8vec() (capnp.UInt8List, error) {
	if capnp.Struct(s).Uint16(0) != 24 {
		panic("Which() != u8vec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.UInt8List(p.List()), err
}

func (s Z) HasU8vec() bool {
	if capnp.Struct(s).Uint16(0) != 24 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetU8vec(v capnp.UInt8List) error {
	capnp.Struct(s).SetUint16(0, 24)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewU8vec sets the u8vec field to a newly
// allocated capnp.UInt8List, preferring placement in s's segment.
func (s Z) NewU8vec(n int32) (capnp.UInt8List, error) {
	capnp.Struct(s).SetUint16(0, 24)
	l, err := capnp.NewUInt8List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt8List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) Boolvec() (capnp.BitList, error) {
	if capnp.Struct(s).Uint16(0) != 39 {
		panic("Which() != boolvec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.BitList(p.List()), err
}

func (s Z) HasBoolvec() bool {
	if capnp.Struct(s).Uint16(0) != 39 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetBoolvec(v capnp.BitList) error {
	capnp.Struct(s).SetUint16(0, 39)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewBoolvec sets the boolvec field to a newly
// allocated capnp.BitList, preferring placement in s's segment.
func (s Z) NewBoolvec(n int32) (capnp.BitList, error) {
	capnp.Struct(s).SetUint16(0, 39)
	l, err := capnp.NewBitList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.BitList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) Datavec() (capnp.DataList, error) {
	if capnp.Struct(s).Uint16(0) != 40 {
		panic("Which() != datavec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.DataList(p.List()), err
}

func (s Z) HasDatavec() bool {
	if capnp.Struct(s).Uint16(0) != 40 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetDatavec(v capnp.DataList) error {
	capnp.Struct(s).SetUint16(0, 40)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewDatavec sets the datavec field to a newly
// allocated capnp.DataList, preferring placement in s's segment.
func (s Z) NewDatavec(n int32) (capnp.DataList, error) {
	capnp.Struct(s).SetUint16(0, 40)
	l, err := capnp.NewDataList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.DataList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) Textvec() (capnp.TextList, error) {
	if capnp.Struct(s).Uint16(0) != 41 {
		panic("Which() != textvec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s Z) HasTextvec() bool {
	if capnp.Struct(s).Uint16(0) != 41 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetTextvec(v capnp.TextList) error {
	capnp.Struct(s).SetUint16(0, 41)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewTextvec sets the textvec field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Z) NewTextvec(n int32) (capnp.TextList, error) {
	capnp.Struct(s).SetUint16(0, 41)
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) Zvec() (Z_List, error) {
	if capnp.Struct(s).Uint16(0) != 25 {
		panic("Which() != zvec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Z_List(p.List()), err
}

func (s Z) HasZvec() bool {
	if capnp.Struct(s).Uint16(0) != 25 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetZvec(v Z_List) error {
	capnp.Struct(s).SetUint16(0, 25)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewZvec sets the zvec field to a newly
// allocated Z_List, preferring placement in s's segment.
func (s Z) NewZvec(n int32) (Z_List, error) {
	capnp.Struct(s).SetUint16(0, 25)
	l, err := NewZ_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Z_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) Zvecvec() (capnp.PointerList, error) {
	if capnp.Struct(s).Uint16(0) != 26 {
		panic("Which() != zvecvec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.PointerList(p.List()), err
}

func (s Z) HasZvecvec() bool {
	if capnp.Struct(s).Uint16(0) != 26 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetZvecvec(v capnp.PointerList) error {
	capnp.Struct(s).SetUint16(0, 26)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewZvecvec sets the zvecvec field to a newly
// allocated capnp.PointerList, preferring placement in s's segment.
func (s Z) NewZvecvec(n int32) (capnp.PointerList, error) {
	capnp.Struct(s).SetUint16(0, 26)
	l, err := capnp.NewPointerList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.PointerList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) Zdate() (Zdate, error) {
	if capnp.Struct(s).Uint16(0) != 27 {
		panic("Which() != zdate")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Zdate(p.Struct()), err
}

func (s Z) HasZdate() bool {
	if capnp.Struct(s).Uint16(0) != 27 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetZdate(v Zdate) error {
	capnp.Struct(s).SetUint16(0, 27)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewZdate sets the zdate field to a newly
// allocated Zdate struct, preferring placement in s's segment.
func (s Z) NewZdate() (Zdate, error) {
	capnp.Struct(s).SetUint16(0, 27)
	ss, err := NewZdate(capnp.Struct(s).Segment())
	if err != nil {
		return Zdate{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Z) Zdata() (Zdata, error) {
	if capnp.Struct(s).Uint16(0) != 28 {
		panic("Which() != zdata")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Zdata(p.Struct()), err
}

func (s Z) HasZdata() bool {
	if capnp.Struct(s).Uint16(0) != 28 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetZdata(v Zdata) error {
	capnp.Struct(s).SetUint16(0, 28)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewZdata sets the zdata field to a newly
// allocated Zdata struct, preferring placement in s's segment.
func (s Z) NewZdata() (Zdata, error) {
	capnp.Struct(s).SetUint16(0, 28)
	ss, err := NewZdata(capnp.Struct(s).Segment())
	if err != nil {
		return Zdata{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Z) Aircraftvec() (Aircraft_List, error) {
	if capnp.Struct(s).Uint16(0) != 29 {
		panic("Which() != aircraftvec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Aircraft_List(p.List()), err
}

func (s Z) HasAircraftvec() bool {
	if capnp.Struct(s).Uint16(0) != 29 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetAircraftvec(v Aircraft_List) error {
	capnp.Struct(s).SetUint16(0, 29)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewAircraftvec sets the aircraftvec field to a newly
// allocated Aircraft_List, preferring placement in s's segment.
func (s Z) NewAircraftvec(n int32) (Aircraft_List, error) {
	capnp.Struct(s).SetUint16(0, 29)
	l, err := NewAircraft_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Aircraft_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) Aircraft() (Aircraft, error) {
	if capnp.Struct(s).Uint16(0) != 30 {
		panic("Which() != aircraft")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Aircraft(p.Struct()), err
}

func (s Z) HasAircraft() bool {
	if capnp.Struct(s).Uint16(0) != 30 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetAircraft(v Aircraft) error {
	capnp.Struct(s).SetUint16(0, 30)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewAircraft sets the aircraft field to a newly
// allocated Aircraft struct, preferring placement in s's segment.
func (s Z) NewAircraft() (Aircraft, error) {
	capnp.Struct(s).SetUint16(0, 30)
	ss, err := NewAircraft(capnp.Struct(s).Segment())
	if err != nil {
		return Aircraft{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Z) Regression() (Regression, error) {
	if capnp.Struct(s).Uint16(0) != 31 {
		panic("Which() != regression")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Regression(p.Struct()), err
}

func (s Z) HasRegression() bool {
	if capnp.Struct(s).Uint16(0) != 31 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetRegression(v Regression) error {
	capnp.Struct(s).SetUint16(0, 31)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewRegression sets the regression field to a newly
// allocated Regression struct, preferring placement in s's segment.
func (s Z) NewRegression() (Regression, error) {
	capnp.Struct(s).SetUint16(0, 31)
	ss, err := NewRegression(capnp.Struct(s).Segment())
	if err != nil {
		return Regression{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Z) Planebase() (PlaneBase, error) {
	if capnp.Struct(s).Uint16(0) != 32 {
		panic("Which() != planebase")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return PlaneBase(p.Struct()), err
}

func (s Z) HasPlanebase() bool {
	if capnp.Struct(s).Uint16(0) != 32 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetPlanebase(v PlaneBase) error {
	capnp.Struct(s).SetUint16(0, 32)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewPlanebase sets the planebase field to a newly
// allocated PlaneBase struct, preferring placement in s's segment.
func (s Z) NewPlanebase() (PlaneBase, error) {
	capnp.Struct(s).SetUint16(0, 32)
	ss, err := NewPlaneBase(capnp.Struct(s).Segment())
	if err != nil {
		return PlaneBase{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Z) Airport() Airport {
	if capnp.Struct(s).Uint16(0) != 33 {
		panic("Which() != airport")
	}
	return Airport(capnp.Struct(s).Uint16(8))
}

func (s Z) SetAirport(v Airport) {
	capnp.Struct(s).SetUint16(0, 33)
	capnp.Struct(s).SetUint16(8, uint16(v))
}

func (s Z) B737() (B737, error) {
	if capnp.Struct(s).Uint16(0) != 34 {
		panic("Which() != b737")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return B737(p.Struct()), err
}

func (s Z) HasB737() bool {
	if capnp.Struct(s).Uint16(0) != 34 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetB737(v B737) error {
	capnp.Struct(s).SetUint16(0, 34)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewB737 sets the b737 field to a newly
// allocated B737 struct, preferring placement in s's segment.
func (s Z) NewB737() (B737, error) {
	capnp.Struct(s).SetUint16(0, 34)
	ss, err := NewB737(capnp.Struct(s).Segment())
	if err != nil {
		return B737{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Z) A320() (A320, error) {
	if capnp.Struct(s).Uint16(0) != 35 {
		panic("Which() != a320")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return A320(p.Struct()), err
}

func (s Z) HasA320() bool {
	if capnp.Struct(s).Uint16(0) != 35 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetA320(v A320) error {
	capnp.Struct(s).SetUint16(0, 35)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewA320 sets the a320 field to a newly
// allocated A320 struct, preferring placement in s's segment.
func (s Z) NewA320() (A320, error) {
	capnp.Struct(s).SetUint16(0, 35)
	ss, err := NewA320(capnp.Struct(s).Segment())
	if err != nil {
		return A320{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Z) F16() (F16, error) {
	if capnp.Struct(s).Uint16(0) != 36 {
		panic("Which() != f16")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return F16(p.Struct()), err
}

func (s Z) HasF16() bool {
	if capnp.Struct(s).Uint16(0) != 36 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetF16(v F16) error {
	capnp.Struct(s).SetUint16(0, 36)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewF16 sets the f16 field to a newly
// allocated F16 struct, preferring placement in s's segment.
func (s Z) NewF16() (F16, error) {
	capnp.Struct(s).SetUint16(0, 36)
	ss, err := NewF16(capnp.Struct(s).Segment())
	if err != nil {
		return F16{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Z) Zdatevec() (Zdate_List, error) {
	if capnp.Struct(s).Uint16(0) != 37 {
		panic("Which() != zdatevec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Zdate_List(p.List()), err
}

func (s Z) HasZdatevec() bool {
	if capnp.Struct(s).Uint16(0) != 37 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetZdatevec(v Zdate_List) error {
	capnp.Struct(s).SetUint16(0, 37)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewZdatevec sets the zdatevec field to a newly
// allocated Zdate_List, preferring placement in s's segment.
func (s Z) NewZdatevec(n int32) (Zdate_List, error) {
	capnp.Struct(s).SetUint16(0, 37)
	l, err := NewZdate_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Zdate_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) Zdatavec() (Zdata_List, error) {
	if capnp.Struct(s).Uint16(0) != 38 {
		panic("Which() != zdatavec")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Zdata_List(p.List()), err
}

func (s Z) HasZdatavec() bool {
	if capnp.Struct(s).Uint16(0) != 38 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetZdatavec(v Zdata_List) error {
	capnp.Struct(s).SetUint16(0, 38)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewZdatavec sets the zdatavec field to a newly
// allocated Zdata_List, preferring placement in s's segment.
func (s Z) NewZdatavec(n int32) (Zdata_List, error) {
	capnp.Struct(s).SetUint16(0, 38)
	l, err := NewZdata_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Zdata_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) Grp() Z_grp { return Z_grp(s) }

func (s Z) SetGrp() {
	capnp.Struct(s).SetUint16(0, 42)
}

func (s Z_grp) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Z_grp) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Z_grp) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Z_grp) First() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s Z_grp) SetFirst(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s Z_grp) Second() uint64 {
	return capnp.Struct(s).Uint64(16)
}

func (s Z_grp) SetSecond(v uint64) {
	capnp.Struct(s).SetUint64(16, v)
}

func (s Z) Echo() Echo {
	if capnp.Struct(s).Uint16(0) != 43 {
		panic("Which() != echo")
	}
	p, _ := capnp.Struct(s).Ptr(0)
	return Echo(p.Interface().Client())
}

func (s Z) HasEcho() bool {
	if capnp.Struct(s).Uint16(0) != 43 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetEcho(v Echo) error {
	capnp.Struct(s).SetUint16(0, 43)
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s Z) Echoes() (Echo_List, error) {
	if capnp.Struct(s).Uint16(0) != 44 {
		panic("Which() != echoes")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Echo_List(p.List()), err
}

func (s Z) HasEchoes() bool {
	if capnp.Struct(s).Uint16(0) != 44 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetEchoes(v Echo_List) error {
	capnp.Struct(s).SetUint16(0, 44)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewEchoes sets the echoes field to a newly
// allocated Echo_List, preferring placement in s's segment.
func (s Z) NewEchoes(n int32) (Echo_List, error) {
	capnp.Struct(s).SetUint16(0, 44)
	l, err := NewEcho_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Echo_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Z) AnyPtr() (capnp.Ptr, error) {
	if capnp.Struct(s).Uint16(0) != 45 {
		panic("Which() != anyPtr")
	}
	return capnp.Struct(s).Ptr(0)
}

func (s Z) HasAnyPtr() bool {
	if capnp.Struct(s).Uint16(0) != 45 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetAnyPtr(v capnp.Ptr) error {
	capnp.Struct(s).SetUint16(0, 45)
	return capnp.Struct(s).SetPtr(0, v)
}
func (s Z) AnyStruct() (capnp.Struct, error) {
	if capnp.Struct(s).Uint16(0) != 46 {
		panic("Which() != anyStruct")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Struct(), err
}

func (s Z) HasAnyStruct() bool {
	if capnp.Struct(s).Uint16(0) != 46 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetAnyStruct(v capnp.Struct) error {
	capnp.Struct(s).SetUint16(0, 46)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}
func (s Z) AnyList() (capnp.List, error) {
	if capnp.Struct(s).Uint16(0) != 47 {
		panic("Which() != anyList")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.List(), err
}

func (s Z) HasAnyList() bool {
	if capnp.Struct(s).Uint16(0) != 47 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetAnyList(v capnp.List) error {
	capnp.Struct(s).SetUint16(0, 47)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}
func (s Z) AnyCapability() capnp.Client {
	if capnp.Struct(s).Uint16(0) != 48 {
		panic("Which() != anyCapability")
	}
	p, _ := capnp.Struct(s).Ptr(0)
	return p.Interface().Client()
}

func (s Z) HasAnyCapability() bool {
	if capnp.Struct(s).Uint16(0) != 48 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Z) SetAnyCapability(c capnp.Client) error {
	capnp.Struct(s).SetUint16(0, 48)
	if !c.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(c))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Z_List is a list of Z.
type Z_List = capnp.StructList[Z]

// NewZ creates a new list of Z.
func NewZ_List(s *capnp.Segment, sz int32) (Z_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[Z](l), err
}

// Z_Future is a wrapper for a Z promised by a client call.
type Z_Future struct{ *capnp.Future }

func (f Z_Future) Struct() (Z, error) {
	p, err := f.Future.Ptr()
	return Z(p.Struct()), err
}
func (p Z_Future) Zz() Z_Future {
	return Z_Future{Future: p.Future.Field(0, nil)}
}
func (p Z_Future) Zdate() Zdate_Future {
	return Zdate_Future{Future: p.Future.Field(0, nil)}
}
func (p Z_Future) Zdata() Zdata_Future {
	return Zdata_Future{Future: p.Future.Field(0, nil)}
}
func (p Z_Future) Aircraft() Aircraft_Future {
	return Aircraft_Future{Future: p.Future.Field(0, nil)}
}
func (p Z_Future) Regression() Regression_Future {
	return Regression_Future{Future: p.Future.Field(0, nil)}
}
func (p Z_Future) Planebase() PlaneBase_Future {
	return PlaneBase_Future{Future: p.Future.Field(0, nil)}
}
func (p Z_Future) B737() B737_Future {
	return B737_Future{Future: p.Future.Field(0, nil)}
}
func (p Z_Future) A320() A320_Future {
	return A320_Future{Future: p.Future.Field(0, nil)}
}
func (p Z_Future) F16() F16_Future {
	return F16_Future{Future: p.Future.Field(0, nil)}
}
func (p Z_Future) Grp() Z_grp_Future { return Z_grp_Future{p.Future} }

// Z_grp_Future is a wrapper for a Z_grp promised by a client call.
type Z_grp_Future struct{ *capnp.Future }

func (f Z_grp_Future) Struct() (Z_grp, error) {
	p, err := f.Future.Ptr()
	return Z_grp(p.Struct()), err
}
func (p Z_Future) Echo() Echo {
	return Echo(p.Future.Field(0, nil).Client())
}

func (p Z_Future) AnyPtr() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p Z_Future) AnyStruct() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p Z_Future) AnyList() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p Z_Future) AnyCapability() capnp.Client {
	return p.Future.Field(0, nil).Client()
}

type Counter capnp.Struct

// Counter_TypeID is the unique identifier for the type Counter.
const Counter_TypeID = 0x8748bc095e10cb5d

func NewCounter(s *capnp.Segment) (Counter, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return Counter(st), err
}

func NewRootCounter(s *capnp.Segment) (Counter, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return Counter(st), err
}

func ReadRootCounter(msg *capnp.Message) (Counter, error) {
	root, err := msg.Root()
	return Counter(root.Struct()), err
}

func (s Counter) String() string {
	str, _ := text.Marshal(0x8748bc095e10cb5d, capnp.Struct(s))
	return str
}

func (s Counter) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Counter) DecodeFromPtr(p capnp.Ptr) Counter {
	return Counter(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Counter) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Counter) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Counter) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Counter) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Counter) Size() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Counter) SetSize(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Counter) Words() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Counter) HasWords() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Counter) WordsBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Counter) SetWords(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Counter) Wordlist() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s Counter) HasWordlist() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Counter) SetWordlist(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewWordlist sets the wordlist field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Counter) NewWordlist(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Counter) Bitlist() (capnp.BitList, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.BitList(p.List()), err
}

func (s Counter) HasBitlist() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Counter) SetBitlist(v capnp.BitList) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewBitlist sets the bitlist field to a newly
// allocated capnp.BitList, preferring placement in s's segment.
func (s Counter) NewBitlist(n int32) (capnp.BitList, error) {
	l, err := capnp.NewBitList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.BitList{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// Counter_List is a list of Counter.
type Counter_List = capnp.StructList[Counter]

// NewCounter creates a new list of Counter.
func NewCounter_List(s *capnp.Segment, sz int32) (Counter_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3}, sz)
	return capnp.StructList[Counter](l), err
}

// Counter_Future is a wrapper for a Counter promised by a client call.
type Counter_Future struct{ *capnp.Future }

func (f Counter_Future) Struct() (Counter, error) {
	p, err := f.Future.Ptr()
	return Counter(p.Struct()), err
}

type Bag capnp.Struct

// Bag_TypeID is the unique identifier for the type Bag.
const Bag_TypeID = 0xd636fba4f188dabe

func NewBag(s *capnp.Segment) (Bag, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Bag(st), err
}

func NewRootBag(s *capnp.Segment) (Bag, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Bag(st), err
}

func ReadRootBag(msg *capnp.Message) (Bag, error) {
	root, err := msg.Root()
	return Bag(root.Struct()), err
}

func (s Bag) String() string {
	str, _ := text.Marshal(0xd636fba4f188dabe, capnp.Struct(s))
	return str
}

func (s Bag) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Bag) DecodeFromPtr(p capnp.Ptr) Bag {
	return Bag(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Bag) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Bag) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Bag) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Bag) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Bag) Counter() (Counter, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Counter(p.Struct()), err
}

func (s Bag) HasCounter() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Bag) SetCounter(v Counter) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewCounter sets the counter field to a newly
// allocated Counter struct, preferring placement in s's segment.
func (s Bag) NewCounter() (Counter, error) {
	ss, err := NewCounter(capnp.Struct(s).Segment())
	if err != nil {
		return Counter{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Bag_List is a list of Bag.
type Bag_List = capnp.StructList[Bag]

// NewBag creates a new list of Bag.
func NewBag_List(s *capnp.Segment, sz int32) (Bag_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Bag](l), err
}

// Bag_Future is a wrapper for a Bag promised by a client call.
type Bag_Future struct{ *capnp.Future }

func (f Bag_Future) Struct() (Bag, error) {
	p, err := f.Future.Ptr()
	return Bag(p.Struct()), err
}
func (p Bag_Future) Counter() Counter_Future {
	return Counter_Future{Future: p.Future.Field(0, nil)}
}

type Zserver capnp.Struct

// Zserver_TypeID is the unique identifier for the type Zserver.
const Zserver_TypeID = 0xcc4411e60ba9c498

func NewZserver(s *capnp.Segment) (Zserver, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Zserver(st), err
}

func NewRootZserver(s *capnp.Segment) (Zserver, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Zserver(st), err
}

func ReadRootZserver(msg *capnp.Message) (Zserver, error) {
	root, err := msg.Root()
	return Zserver(root.Struct()), err
}

func (s Zserver) String() string {
	str, _ := text.Marshal(0xcc4411e60ba9c498, capnp.Struct(s))
	return str
}

func (s Zserver) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Zserver) DecodeFromPtr(p capnp.Ptr) Zserver {
	return Zserver(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Zserver) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Zserver) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Zserver) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Zserver) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Zserver) Waitingjobs() (Zjob_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Zjob_List(p.List()), err
}

func (s Zserver) HasWaitingjobs() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Zserver) SetWaitingjobs(v Zjob_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewWaitingjobs sets the waitingjobs field to a newly
// allocated Zjob_List, preferring placement in s's segment.
func (s Zserver) NewWaitingjobs(n int32) (Zjob_List, error) {
	l, err := NewZjob_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Zjob_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Zserver_List is a list of Zserver.
type Zserver_List = capnp.StructList[Zserver]

// NewZserver creates a new list of Zserver.
func NewZserver_List(s *capnp.Segment, sz int32) (Zserver_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Zserver](l), err
}

// Zserver_Future is a wrapper for a Zserver promised by a client call.
type Zserver_Future struct{ *capnp.Future }

func (f Zserver_Future) Struct() (Zserver, error) {
	p, err := f.Future.Ptr()
	return Zserver(p.Struct()), err
}

type Zjob capnp.Struct

// Zjob_TypeID is the unique identifier for the type Zjob.
const Zjob_TypeID = 0xddd1416669fb7613

func NewZjob(s *capnp.Segment) (Zjob, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Zjob(st), err
}

func NewRootZjob(s *capnp.Segment) (Zjob, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Zjob(st), err
}

func ReadRootZjob(msg *capnp.Message) (Zjob, error) {
	root, err := msg.Root()
	return Zjob(root.Struct()), err
}

func (s Zjob) String() string {
	str, _ := text.Marshal(0xddd1416669fb7613, capnp.Struct(s))
	return str
}

func (s Zjob) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Zjob) DecodeFromPtr(p capnp.Ptr) Zjob {
	return Zjob(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Zjob) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Zjob) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Zjob) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Zjob) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Zjob) Cmd() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Zjob) HasCmd() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Zjob) CmdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Zjob) SetCmd(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Zjob) Args() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s Zjob) HasArgs() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Zjob) SetArgs(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewArgs sets the args field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Zjob) NewArgs(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Zjob_List is a list of Zjob.
type Zjob_List = capnp.StructList[Zjob]

// NewZjob creates a new list of Zjob.
func NewZjob_List(s *capnp.Segment, sz int32) (Zjob_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Zjob](l), err
}

// Zjob_Future is a wrapper for a Zjob promised by a client call.
type Zjob_Future struct{ *capnp.Future }

func (f Zjob_Future) Struct() (Zjob, error) {
	p, err := f.Future.Ptr()
	return Zjob(p.Struct()), err
}

type VerEmpty capnp.Struct

// VerEmpty_TypeID is the unique identifier for the type VerEmpty.
const VerEmpty_TypeID = 0x93c99951eacc72ff

func NewVerEmpty(s *capnp.Segment) (VerEmpty, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return VerEmpty(st), err
}

func NewRootVerEmpty(s *capnp.Segment) (VerEmpty, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return VerEmpty(st), err
}

func ReadRootVerEmpty(msg *capnp.Message) (VerEmpty, error) {
	root, err := msg.Root()
	return VerEmpty(root.Struct()), err
}

func (s VerEmpty) String() string {
	str, _ := text.Marshal(0x93c99951eacc72ff, capnp.Struct(s))
	return str
}

func (s VerEmpty) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VerEmpty) DecodeFromPtr(p capnp.Ptr) VerEmpty {
	return VerEmpty(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VerEmpty) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VerEmpty) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VerEmpty) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VerEmpty) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// VerEmpty_List is a list of VerEmpty.
type VerEmpty_List = capnp.StructList[VerEmpty]

// NewVerEmpty creates a new list of VerEmpty.
func NewVerEmpty_List(s *capnp.Segment, sz int32) (VerEmpty_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[VerEmpty](l), err
}

// VerEmpty_Future is a wrapper for a VerEmpty promised by a client call.
type VerEmpty_Future struct{ *capnp.Future }

func (f VerEmpty_Future) Struct() (VerEmpty, error) {
	p, err := f.Future.Ptr()
	return VerEmpty(p.Struct()), err
}

type VerOneData capnp.Struct

// VerOneData_TypeID is the unique identifier for the type VerOneData.
const VerOneData_TypeID = 0xfca3742893be4cde

func NewVerOneData(s *capnp.Segment) (VerOneData, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return VerOneData(st), err
}

func NewRootVerOneData(s *capnp.Segment) (VerOneData, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return VerOneData(st), err
}

func ReadRootVerOneData(msg *capnp.Message) (VerOneData, error) {
	root, err := msg.Root()
	return VerOneData(root.Struct()), err
}

func (s VerOneData) String() string {
	str, _ := text.Marshal(0xfca3742893be4cde, capnp.Struct(s))
	return str
}

func (s VerOneData) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VerOneData) DecodeFromPtr(p capnp.Ptr) VerOneData {
	return VerOneData(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VerOneData) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VerOneData) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VerOneData) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VerOneData) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VerOneData) Val() int16 {
	return int16(capnp.Struct(s).Uint16(0))
}

func (s VerOneData) SetVal(v int16) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

// VerOneData_List is a list of VerOneData.
type VerOneData_List = capnp.StructList[VerOneData]

// NewVerOneData creates a new list of VerOneData.
func NewVerOneData_List(s *capnp.Segment, sz int32) (VerOneData_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[VerOneData](l), err
}

// VerOneData_Future is a wrapper for a VerOneData promised by a client call.
type VerOneData_Future struct{ *capnp.Future }

func (f VerOneData_Future) Struct() (VerOneData, error) {
	p, err := f.Future.Ptr()
	return VerOneData(p.Struct()), err
}

type VerTwoData capnp.Struct

// VerTwoData_TypeID is the unique identifier for the type VerTwoData.
const VerTwoData_TypeID = 0xf705dc45c94766fd

func NewVerTwoData(s *capnp.Segment) (VerTwoData, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return VerTwoData(st), err
}

func NewRootVerTwoData(s *capnp.Segment) (VerTwoData, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return VerTwoData(st), err
}

func ReadRootVerTwoData(msg *capnp.Message) (VerTwoData, error) {
	root, err := msg.Root()
	return VerTwoData(root.Struct()), err
}

func (s VerTwoData) String() string {
	str, _ := text.Marshal(0xf705dc45c94766fd, capnp.Struct(s))
	return str
}

func (s VerTwoData) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VerTwoData) DecodeFromPtr(p capnp.Ptr) VerTwoData {
	return VerTwoData(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VerTwoData) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VerTwoData) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VerTwoData) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VerTwoData) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VerTwoData) Val() int16 {
	return int16(capnp.Struct(s).Uint16(0))
}

func (s VerTwoData) SetVal(v int16) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s VerTwoData) Duo() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s VerTwoData) SetDuo(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

// VerTwoData_List is a list of VerTwoData.
type VerTwoData_List = capnp.StructList[VerTwoData]

// NewVerTwoData creates a new list of VerTwoData.
func NewVerTwoData_List(s *capnp.Segment, sz int32) (VerTwoData_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[VerTwoData](l), err
}

// VerTwoData_Future is a wrapper for a VerTwoData promised by a client call.
type VerTwoData_Future struct{ *capnp.Future }

func (f VerTwoData_Future) Struct() (VerTwoData, error) {
	p, err := f.Future.Ptr()
	return VerTwoData(p.Struct()), err
}

type VerOnePtr capnp.Struct

// VerOnePtr_TypeID is the unique identifier for the type VerOnePtr.
const VerOnePtr_TypeID = 0x94bf7df83408218d

func NewVerOnePtr(s *capnp.Segment) (VerOnePtr, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return VerOnePtr(st), err
}

func NewRootVerOnePtr(s *capnp.Segment) (VerOnePtr, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return VerOnePtr(st), err
}

func ReadRootVerOnePtr(msg *capnp.Message) (VerOnePtr, error) {
	root, err := msg.Root()
	return VerOnePtr(root.Struct()), err
}

func (s VerOnePtr) String() string {
	str, _ := text.Marshal(0x94bf7df83408218d, capnp.Struct(s))
	return str
}

func (s VerOnePtr) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VerOnePtr) DecodeFromPtr(p capnp.Ptr) VerOnePtr {
	return VerOnePtr(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VerOnePtr) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VerOnePtr) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VerOnePtr) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VerOnePtr) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VerOnePtr) Ptr() (VerOneData, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerOneData(p.Struct()), err
}

func (s VerOnePtr) HasPtr() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s VerOnePtr) SetPtr(v VerOneData) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewPtr sets the ptr field to a newly
// allocated VerOneData struct, preferring placement in s's segment.
func (s VerOnePtr) NewPtr() (VerOneData, error) {
	ss, err := NewVerOneData(capnp.Struct(s).Segment())
	if err != nil {
		return VerOneData{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// VerOnePtr_List is a list of VerOnePtr.
type VerOnePtr_List = capnp.StructList[VerOnePtr]

// NewVerOnePtr creates a new list of VerOnePtr.
func NewVerOnePtr_List(s *capnp.Segment, sz int32) (VerOnePtr_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[VerOnePtr](l), err
}

// VerOnePtr_Future is a wrapper for a VerOnePtr promised by a client call.
type VerOnePtr_Future struct{ *capnp.Future }

func (f VerOnePtr_Future) Struct() (VerOnePtr, error) {
	p, err := f.Future.Ptr()
	return VerOnePtr(p.Struct()), err
}
func (p VerOnePtr_Future) Ptr() VerOneData_Future {
	return VerOneData_Future{Future: p.Future.Field(0, nil)}
}

type VerTwoPtr capnp.Struct

// VerTwoPtr_TypeID is the unique identifier for the type VerTwoPtr.
const VerTwoPtr_TypeID = 0xc95babe3bd394d2d

func NewVerTwoPtr(s *capnp.Segment) (VerTwoPtr, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return VerTwoPtr(st), err
}

func NewRootVerTwoPtr(s *capnp.Segment) (VerTwoPtr, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return VerTwoPtr(st), err
}

func ReadRootVerTwoPtr(msg *capnp.Message) (VerTwoPtr, error) {
	root, err := msg.Root()
	return VerTwoPtr(root.Struct()), err
}

func (s VerTwoPtr) String() string {
	str, _ := text.Marshal(0xc95babe3bd394d2d, capnp.Struct(s))
	return str
}

func (s VerTwoPtr) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VerTwoPtr) DecodeFromPtr(p capnp.Ptr) VerTwoPtr {
	return VerTwoPtr(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VerTwoPtr) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VerTwoPtr) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VerTwoPtr) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VerTwoPtr) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VerTwoPtr) Ptr1() (VerOneData, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerOneData(p.Struct()), err
}

func (s VerTwoPtr) HasPtr1() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s VerTwoPtr) SetPtr1(v VerOneData) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewPtr1 sets the ptr1 field to a newly
// allocated VerOneData struct, preferring placement in s's segment.
func (s VerTwoPtr) NewPtr1() (VerOneData, error) {
	ss, err := NewVerOneData(capnp.Struct(s).Segment())
	if err != nil {
		return VerOneData{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s VerTwoPtr) Ptr2() (VerOneData, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return VerOneData(p.Struct()), err
}

func (s VerTwoPtr) HasPtr2() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s VerTwoPtr) SetPtr2(v VerOneData) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewPtr2 sets the ptr2 field to a newly
// allocated VerOneData struct, preferring placement in s's segment.
func (s VerTwoPtr) NewPtr2() (VerOneData, error) {
	ss, err := NewVerOneData(capnp.Struct(s).Segment())
	if err != nil {
		return VerOneData{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// VerTwoPtr_List is a list of VerTwoPtr.
type VerTwoPtr_List = capnp.StructList[VerTwoPtr]

// NewVerTwoPtr creates a new list of VerTwoPtr.
func NewVerTwoPtr_List(s *capnp.Segment, sz int32) (VerTwoPtr_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[VerTwoPtr](l), err
}

// VerTwoPtr_Future is a wrapper for a VerTwoPtr promised by a client call.
type VerTwoPtr_Future struct{ *capnp.Future }

func (f VerTwoPtr_Future) Struct() (VerTwoPtr, error) {
	p, err := f.Future.Ptr()
	return VerTwoPtr(p.Struct()), err
}
func (p VerTwoPtr_Future) Ptr1() VerOneData_Future {
	return VerOneData_Future{Future: p.Future.Field(0, nil)}
}
func (p VerTwoPtr_Future) Ptr2() VerOneData_Future {
	return VerOneData_Future{Future: p.Future.Field(1, nil)}
}

type VerTwoDataTwoPtr capnp.Struct

// VerTwoDataTwoPtr_TypeID is the unique identifier for the type VerTwoDataTwoPtr.
const VerTwoDataTwoPtr_TypeID = 0xb61ee2ecff34ca73

func NewVerTwoDataTwoPtr(s *capnp.Segment) (VerTwoDataTwoPtr, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return VerTwoDataTwoPtr(st), err
}

func NewRootVerTwoDataTwoPtr(s *capnp.Segment) (VerTwoDataTwoPtr, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return VerTwoDataTwoPtr(st), err
}

func ReadRootVerTwoDataTwoPtr(msg *capnp.Message) (VerTwoDataTwoPtr, error) {
	root, err := msg.Root()
	return VerTwoDataTwoPtr(root.Struct()), err
}

func (s VerTwoDataTwoPtr) String() string {
	str, _ := text.Marshal(0xb61ee2ecff34ca73, capnp.Struct(s))
	return str
}

func (s VerTwoDataTwoPtr) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VerTwoDataTwoPtr) DecodeFromPtr(p capnp.Ptr) VerTwoDataTwoPtr {
	return VerTwoDataTwoPtr(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VerTwoDataTwoPtr) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VerTwoDataTwoPtr) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VerTwoDataTwoPtr) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VerTwoDataTwoPtr) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VerTwoDataTwoPtr) Val() int16 {
	return int16(capnp.Struct(s).Uint16(0))
}

func (s VerTwoDataTwoPtr) SetVal(v int16) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s VerTwoDataTwoPtr) Duo() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s VerTwoDataTwoPtr) SetDuo(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s VerTwoDataTwoPtr) Ptr1() (VerOneData, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerOneData(p.Struct()), err
}

func (s VerTwoDataTwoPtr) HasPtr1() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s VerTwoDataTwoPtr) SetPtr1(v VerOneData) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewPtr1 sets the ptr1 field to a newly
// allocated VerOneData struct, preferring placement in s's segment.
func (s VerTwoDataTwoPtr) NewPtr1() (VerOneData, error) {
	ss, err := NewVerOneData(capnp.Struct(s).Segment())
	if err != nil {
		return VerOneData{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s VerTwoDataTwoPtr) Ptr2() (VerOneData, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return VerOneData(p.Struct()), err
}

func (s VerTwoDataTwoPtr) HasPtr2() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s VerTwoDataTwoPtr) SetPtr2(v VerOneData) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewPtr2 sets the ptr2 field to a newly
// allocated VerOneData struct, preferring placement in s's segment.
func (s VerTwoDataTwoPtr) NewPtr2() (VerOneData, error) {
	ss, err := NewVerOneData(capnp.Struct(s).Segment())
	if err != nil {
		return VerOneData{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// VerTwoDataTwoPtr_List is a list of VerTwoDataTwoPtr.
type VerTwoDataTwoPtr_List = capnp.StructList[VerTwoDataTwoPtr]

// NewVerTwoDataTwoPtr creates a new list of VerTwoDataTwoPtr.
func NewVerTwoDataTwoPtr_List(s *capnp.Segment, sz int32) (VerTwoDataTwoPtr_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[VerTwoDataTwoPtr](l), err
}

// VerTwoDataTwoPtr_Future is a wrapper for a VerTwoDataTwoPtr promised by a client call.
type VerTwoDataTwoPtr_Future struct{ *capnp.Future }

func (f VerTwoDataTwoPtr_Future) Struct() (VerTwoDataTwoPtr, error) {
	p, err := f.Future.Ptr()
	return VerTwoDataTwoPtr(p.Struct()), err
}
func (p VerTwoDataTwoPtr_Future) Ptr1() VerOneData_Future {
	return VerOneData_Future{Future: p.Future.Field(0, nil)}
}
func (p VerTwoDataTwoPtr_Future) Ptr2() VerOneData_Future {
	return VerOneData_Future{Future: p.Future.Field(1, nil)}
}

type HoldsVerEmptyList capnp.Struct

// HoldsVerEmptyList_TypeID is the unique identifier for the type HoldsVerEmptyList.
const HoldsVerEmptyList_TypeID = 0xde9ed43cfaa83093

func NewHoldsVerEmptyList(s *capnp.Segment) (HoldsVerEmptyList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerEmptyList(st), err
}

func NewRootHoldsVerEmptyList(s *capnp.Segment) (HoldsVerEmptyList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerEmptyList(st), err
}

func ReadRootHoldsVerEmptyList(msg *capnp.Message) (HoldsVerEmptyList, error) {
	root, err := msg.Root()
	return HoldsVerEmptyList(root.Struct()), err
}

func (s HoldsVerEmptyList) String() string {
	str, _ := text.Marshal(0xde9ed43cfaa83093, capnp.Struct(s))
	return str
}

func (s HoldsVerEmptyList) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HoldsVerEmptyList) DecodeFromPtr(p capnp.Ptr) HoldsVerEmptyList {
	return HoldsVerEmptyList(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HoldsVerEmptyList) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HoldsVerEmptyList) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HoldsVerEmptyList) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HoldsVerEmptyList) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HoldsVerEmptyList) Mylist() (VerEmpty_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerEmpty_List(p.List()), err
}

func (s HoldsVerEmptyList) HasMylist() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HoldsVerEmptyList) SetMylist(v VerEmpty_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerEmpty_List, preferring placement in s's segment.
func (s HoldsVerEmptyList) NewMylist(n int32) (VerEmpty_List, error) {
	l, err := NewVerEmpty_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return VerEmpty_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// HoldsVerEmptyList_List is a list of HoldsVerEmptyList.
type HoldsVerEmptyList_List = capnp.StructList[HoldsVerEmptyList]

// NewHoldsVerEmptyList creates a new list of HoldsVerEmptyList.
func NewHoldsVerEmptyList_List(s *capnp.Segment, sz int32) (HoldsVerEmptyList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerEmptyList](l), err
}

// HoldsVerEmptyList_Future is a wrapper for a HoldsVerEmptyList promised by a client call.
type HoldsVerEmptyList_Future struct{ *capnp.Future }

func (f HoldsVerEmptyList_Future) Struct() (HoldsVerEmptyList, error) {
	p, err := f.Future.Ptr()
	return HoldsVerEmptyList(p.Struct()), err
}

type HoldsVerOneDataList capnp.Struct

// HoldsVerOneDataList_TypeID is the unique identifier for the type HoldsVerOneDataList.
const HoldsVerOneDataList_TypeID = 0xabd055422a4d7df1

func NewHoldsVerOneDataList(s *capnp.Segment) (HoldsVerOneDataList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerOneDataList(st), err
}

func NewRootHoldsVerOneDataList(s *capnp.Segment) (HoldsVerOneDataList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerOneDataList(st), err
}

func ReadRootHoldsVerOneDataList(msg *capnp.Message) (HoldsVerOneDataList, error) {
	root, err := msg.Root()
	return HoldsVerOneDataList(root.Struct()), err
}

func (s HoldsVerOneDataList) String() string {
	str, _ := text.Marshal(0xabd055422a4d7df1, capnp.Struct(s))
	return str
}

func (s HoldsVerOneDataList) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HoldsVerOneDataList) DecodeFromPtr(p capnp.Ptr) HoldsVerOneDataList {
	return HoldsVerOneDataList(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HoldsVerOneDataList) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HoldsVerOneDataList) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HoldsVerOneDataList) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HoldsVerOneDataList) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HoldsVerOneDataList) Mylist() (VerOneData_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerOneData_List(p.List()), err
}

func (s HoldsVerOneDataList) HasMylist() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HoldsVerOneDataList) SetMylist(v VerOneData_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerOneData_List, preferring placement in s's segment.
func (s HoldsVerOneDataList) NewMylist(n int32) (VerOneData_List, error) {
	l, err := NewVerOneData_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return VerOneData_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// HoldsVerOneDataList_List is a list of HoldsVerOneDataList.
type HoldsVerOneDataList_List = capnp.StructList[HoldsVerOneDataList]

// NewHoldsVerOneDataList creates a new list of HoldsVerOneDataList.
func NewHoldsVerOneDataList_List(s *capnp.Segment, sz int32) (HoldsVerOneDataList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerOneDataList](l), err
}

// HoldsVerOneDataList_Future is a wrapper for a HoldsVerOneDataList promised by a client call.
type HoldsVerOneDataList_Future struct{ *capnp.Future }

func (f HoldsVerOneDataList_Future) Struct() (HoldsVerOneDataList, error) {
	p, err := f.Future.Ptr()
	return HoldsVerOneDataList(p.Struct()), err
}

type HoldsVerTwoDataList capnp.Struct

// HoldsVerTwoDataList_TypeID is the unique identifier for the type HoldsVerTwoDataList.
const HoldsVerTwoDataList_TypeID = 0xcbdc765fd5dff7ba

func NewHoldsVerTwoDataList(s *capnp.Segment) (HoldsVerTwoDataList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoDataList(st), err
}

func NewRootHoldsVerTwoDataList(s *capnp.Segment) (HoldsVerTwoDataList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoDataList(st), err
}

func ReadRootHoldsVerTwoDataList(msg *capnp.Message) (HoldsVerTwoDataList, error) {
	root, err := msg.Root()
	return HoldsVerTwoDataList(root.Struct()), err
}

func (s HoldsVerTwoDataList) String() string {
	str, _ := text.Marshal(0xcbdc765fd5dff7ba, capnp.Struct(s))
	return str
}

func (s HoldsVerTwoDataList) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HoldsVerTwoDataList) DecodeFromPtr(p capnp.Ptr) HoldsVerTwoDataList {
	return HoldsVerTwoDataList(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HoldsVerTwoDataList) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HoldsVerTwoDataList) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HoldsVerTwoDataList) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HoldsVerTwoDataList) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HoldsVerTwoDataList) Mylist() (VerTwoData_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerTwoData_List(p.List()), err
}

func (s HoldsVerTwoDataList) HasMylist() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HoldsVerTwoDataList) SetMylist(v VerTwoData_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerTwoData_List, preferring placement in s's segment.
func (s HoldsVerTwoDataList) NewMylist(n int32) (VerTwoData_List, error) {
	l, err := NewVerTwoData_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return VerTwoData_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// HoldsVerTwoDataList_List is a list of HoldsVerTwoDataList.
type HoldsVerTwoDataList_List = capnp.StructList[HoldsVerTwoDataList]

// NewHoldsVerTwoDataList creates a new list of HoldsVerTwoDataList.
func NewHoldsVerTwoDataList_List(s *capnp.Segment, sz int32) (HoldsVerTwoDataList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerTwoDataList](l), err
}

// HoldsVerTwoDataList_Future is a wrapper for a HoldsVerTwoDataList promised by a client call.
type HoldsVerTwoDataList_Future struct{ *capnp.Future }

func (f HoldsVerTwoDataList_Future) Struct() (HoldsVerTwoDataList, error) {
	p, err := f.Future.Ptr()
	return HoldsVerTwoDataList(p.Struct()), err
}

type HoldsVerOnePtrList capnp.Struct

// HoldsVerOnePtrList_TypeID is the unique identifier for the type HoldsVerOnePtrList.
const HoldsVerOnePtrList_TypeID = 0xe508a29c83a059f8

func NewHoldsVerOnePtrList(s *capnp.Segment) (HoldsVerOnePtrList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerOnePtrList(st), err
}

func NewRootHoldsVerOnePtrList(s *capnp.Segment) (HoldsVerOnePtrList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerOnePtrList(st), err
}

func ReadRootHoldsVerOnePtrList(msg *capnp.Message) (HoldsVerOnePtrList, error) {
	root, err := msg.Root()
	return HoldsVerOnePtrList(root.Struct()), err
}

func (s HoldsVerOnePtrList) String() string {
	str, _ := text.Marshal(0xe508a29c83a059f8, capnp.Struct(s))
	return str
}

func (s HoldsVerOnePtrList) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HoldsVerOnePtrList) DecodeFromPtr(p capnp.Ptr) HoldsVerOnePtrList {
	return HoldsVerOnePtrList(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HoldsVerOnePtrList) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HoldsVerOnePtrList) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HoldsVerOnePtrList) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HoldsVerOnePtrList) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HoldsVerOnePtrList) Mylist() (VerOnePtr_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerOnePtr_List(p.List()), err
}

func (s HoldsVerOnePtrList) HasMylist() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HoldsVerOnePtrList) SetMylist(v VerOnePtr_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerOnePtr_List, preferring placement in s's segment.
func (s HoldsVerOnePtrList) NewMylist(n int32) (VerOnePtr_List, error) {
	l, err := NewVerOnePtr_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return VerOnePtr_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// HoldsVerOnePtrList_List is a list of HoldsVerOnePtrList.
type HoldsVerOnePtrList_List = capnp.StructList[HoldsVerOnePtrList]

// NewHoldsVerOnePtrList creates a new list of HoldsVerOnePtrList.
func NewHoldsVerOnePtrList_List(s *capnp.Segment, sz int32) (HoldsVerOnePtrList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerOnePtrList](l), err
}

// HoldsVerOnePtrList_Future is a wrapper for a HoldsVerOnePtrList promised by a client call.
type HoldsVerOnePtrList_Future struct{ *capnp.Future }

func (f HoldsVerOnePtrList_Future) Struct() (HoldsVerOnePtrList, error) {
	p, err := f.Future.Ptr()
	return HoldsVerOnePtrList(p.Struct()), err
}

type HoldsVerTwoPtrList capnp.Struct

// HoldsVerTwoPtrList_TypeID is the unique identifier for the type HoldsVerTwoPtrList.
const HoldsVerTwoPtrList_TypeID = 0xcf9beaca1cc180c8

func NewHoldsVerTwoPtrList(s *capnp.Segment) (HoldsVerTwoPtrList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoPtrList(st), err
}

func NewRootHoldsVerTwoPtrList(s *capnp.Segment) (HoldsVerTwoPtrList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoPtrList(st), err
}

func ReadRootHoldsVerTwoPtrList(msg *capnp.Message) (HoldsVerTwoPtrList, error) {
	root, err := msg.Root()
	return HoldsVerTwoPtrList(root.Struct()), err
}

func (s HoldsVerTwoPtrList) String() string {
	str, _ := text.Marshal(0xcf9beaca1cc180c8, capnp.Struct(s))
	return str
}

func (s HoldsVerTwoPtrList) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HoldsVerTwoPtrList) DecodeFromPtr(p capnp.Ptr) HoldsVerTwoPtrList {
	return HoldsVerTwoPtrList(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HoldsVerTwoPtrList) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HoldsVerTwoPtrList) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HoldsVerTwoPtrList) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HoldsVerTwoPtrList) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HoldsVerTwoPtrList) Mylist() (VerTwoPtr_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerTwoPtr_List(p.List()), err
}

func (s HoldsVerTwoPtrList) HasMylist() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HoldsVerTwoPtrList) SetMylist(v VerTwoPtr_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerTwoPtr_List, preferring placement in s's segment.
func (s HoldsVerTwoPtrList) NewMylist(n int32) (VerTwoPtr_List, error) {
	l, err := NewVerTwoPtr_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return VerTwoPtr_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// HoldsVerTwoPtrList_List is a list of HoldsVerTwoPtrList.
type HoldsVerTwoPtrList_List = capnp.StructList[HoldsVerTwoPtrList]

// NewHoldsVerTwoPtrList creates a new list of HoldsVerTwoPtrList.
func NewHoldsVerTwoPtrList_List(s *capnp.Segment, sz int32) (HoldsVerTwoPtrList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerTwoPtrList](l), err
}

// HoldsVerTwoPtrList_Future is a wrapper for a HoldsVerTwoPtrList promised by a client call.
type HoldsVerTwoPtrList_Future struct{ *capnp.Future }

func (f HoldsVerTwoPtrList_Future) Struct() (HoldsVerTwoPtrList, error) {
	p, err := f.Future.Ptr()
	return HoldsVerTwoPtrList(p.Struct()), err
}

type HoldsVerTwoTwoList capnp.Struct

// HoldsVerTwoTwoList_TypeID is the unique identifier for the type HoldsVerTwoTwoList.
const HoldsVerTwoTwoList_TypeID = 0x95befe3f14606e6b

func NewHoldsVerTwoTwoList(s *capnp.Segment) (HoldsVerTwoTwoList, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoTwoList(st), err
}

func NewRootHoldsVerTwoTwoList(s *capnp.Segment) (HoldsVerTwoTwoList, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoTwoList(st), err
}

func ReadRootHoldsVerTwoTwoList(msg *capnp.Message) (HoldsVerTwoTwoList, error) {
	root, err := msg.Root()
	return HoldsVerTwoTwoList(root.Struct()), err
}

func (s HoldsVerTwoTwoList) String() string {
	str, _ := text.Marshal(0x95befe3f14606e6b, capnp.Struct(s))
	return str
}

func (s HoldsVerTwoTwoList) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HoldsVerTwoTwoList) DecodeFromPtr(p capnp.Ptr) HoldsVerTwoTwoList {
	return HoldsVerTwoTwoList(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HoldsVerTwoTwoList) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HoldsVerTwoTwoList) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HoldsVerTwoTwoList) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HoldsVerTwoTwoList) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HoldsVerTwoTwoList) Mylist() (VerTwoDataTwoPtr_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerTwoDataTwoPtr_List(p.List()), err
}

func (s HoldsVerTwoTwoList) HasMylist() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HoldsVerTwoTwoList) SetMylist(v VerTwoDataTwoPtr_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerTwoDataTwoPtr_List, preferring placement in s's segment.
func (s HoldsVerTwoTwoList) NewMylist(n int32) (VerTwoDataTwoPtr_List, error) {
	l, err := NewVerTwoDataTwoPtr_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return VerTwoDataTwoPtr_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// HoldsVerTwoTwoList_List is a list of HoldsVerTwoTwoList.
type HoldsVerTwoTwoList_List = capnp.StructList[HoldsVerTwoTwoList]

// NewHoldsVerTwoTwoList creates a new list of HoldsVerTwoTwoList.
func NewHoldsVerTwoTwoList_List(s *capnp.Segment, sz int32) (HoldsVerTwoTwoList_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerTwoTwoList](l), err
}

// HoldsVerTwoTwoList_Future is a wrapper for a HoldsVerTwoTwoList promised by a client call.
type HoldsVerTwoTwoList_Future struct{ *capnp.Future }

func (f HoldsVerTwoTwoList_Future) Struct() (HoldsVerTwoTwoList, error) {
	p, err := f.Future.Ptr()
	return HoldsVerTwoTwoList(p.Struct()), err
}

type HoldsVerTwoTwoPlus capnp.Struct

// HoldsVerTwoTwoPlus_TypeID is the unique identifier for the type HoldsVerTwoTwoPlus.
const HoldsVerTwoTwoPlus_TypeID = 0x87c33f2330feb3d8

func NewHoldsVerTwoTwoPlus(s *capnp.Segment) (HoldsVerTwoTwoPlus, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoTwoPlus(st), err
}

func NewRootHoldsVerTwoTwoPlus(s *capnp.Segment) (HoldsVerTwoTwoPlus, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HoldsVerTwoTwoPlus(st), err
}

func ReadRootHoldsVerTwoTwoPlus(msg *capnp.Message) (HoldsVerTwoTwoPlus, error) {
	root, err := msg.Root()
	return HoldsVerTwoTwoPlus(root.Struct()), err
}

func (s HoldsVerTwoTwoPlus) String() string {
	str, _ := text.Marshal(0x87c33f2330feb3d8, capnp.Struct(s))
	return str
}

func (s HoldsVerTwoTwoPlus) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HoldsVerTwoTwoPlus) DecodeFromPtr(p capnp.Ptr) HoldsVerTwoTwoPlus {
	return HoldsVerTwoTwoPlus(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HoldsVerTwoTwoPlus) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HoldsVerTwoTwoPlus) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HoldsVerTwoTwoPlus) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HoldsVerTwoTwoPlus) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HoldsVerTwoTwoPlus) Mylist() (VerTwoTwoPlus_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerTwoTwoPlus_List(p.List()), err
}

func (s HoldsVerTwoTwoPlus) HasMylist() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HoldsVerTwoTwoPlus) SetMylist(v VerTwoTwoPlus_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewMylist sets the mylist field to a newly
// allocated VerTwoTwoPlus_List, preferring placement in s's segment.
func (s HoldsVerTwoTwoPlus) NewMylist(n int32) (VerTwoTwoPlus_List, error) {
	l, err := NewVerTwoTwoPlus_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return VerTwoTwoPlus_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// HoldsVerTwoTwoPlus_List is a list of HoldsVerTwoTwoPlus.
type HoldsVerTwoTwoPlus_List = capnp.StructList[HoldsVerTwoTwoPlus]

// NewHoldsVerTwoTwoPlus creates a new list of HoldsVerTwoTwoPlus.
func NewHoldsVerTwoTwoPlus_List(s *capnp.Segment, sz int32) (HoldsVerTwoTwoPlus_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HoldsVerTwoTwoPlus](l), err
}

// HoldsVerTwoTwoPlus_Future is a wrapper for a HoldsVerTwoTwoPlus promised by a client call.
type HoldsVerTwoTwoPlus_Future struct{ *capnp.Future }

func (f HoldsVerTwoTwoPlus_Future) Struct() (HoldsVerTwoTwoPlus, error) {
	p, err := f.Future.Ptr()
	return HoldsVerTwoTwoPlus(p.Struct()), err
}

type VerTwoTwoPlus capnp.Struct

// VerTwoTwoPlus_TypeID is the unique identifier for the type VerTwoTwoPlus.
const VerTwoTwoPlus_TypeID = 0xce44aee2d9e25049

func NewVerTwoTwoPlus(s *capnp.Segment) (VerTwoTwoPlus, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3})
	return VerTwoTwoPlus(st), err
}

func NewRootVerTwoTwoPlus(s *capnp.Segment) (VerTwoTwoPlus, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3})
	return VerTwoTwoPlus(st), err
}

func ReadRootVerTwoTwoPlus(msg *capnp.Message) (VerTwoTwoPlus, error) {
	root, err := msg.Root()
	return VerTwoTwoPlus(root.Struct()), err
}

func (s VerTwoTwoPlus) String() string {
	str, _ := text.Marshal(0xce44aee2d9e25049, capnp.Struct(s))
	return str
}

func (s VerTwoTwoPlus) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VerTwoTwoPlus) DecodeFromPtr(p capnp.Ptr) VerTwoTwoPlus {
	return VerTwoTwoPlus(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VerTwoTwoPlus) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VerTwoTwoPlus) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VerTwoTwoPlus) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VerTwoTwoPlus) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VerTwoTwoPlus) Val() int16 {
	return int16(capnp.Struct(s).Uint16(0))
}

func (s VerTwoTwoPlus) SetVal(v int16) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s VerTwoTwoPlus) Duo() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s VerTwoTwoPlus) SetDuo(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s VerTwoTwoPlus) Ptr1() (VerTwoDataTwoPtr, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerTwoDataTwoPtr(p.Struct()), err
}

func (s VerTwoTwoPlus) HasPtr1() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s VerTwoTwoPlus) SetPtr1(v VerTwoDataTwoPtr) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewPtr1 sets the ptr1 field to a newly
// allocated VerTwoDataTwoPtr struct, preferring placement in s's segment.
func (s VerTwoTwoPlus) NewPtr1() (VerTwoDataTwoPtr, error) {
	ss, err := NewVerTwoDataTwoPtr(capnp.Struct(s).Segment())
	if err != nil {
		return VerTwoDataTwoPtr{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s VerTwoTwoPlus) Ptr2() (VerTwoDataTwoPtr, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return VerTwoDataTwoPtr(p.Struct()), err
}

func (s VerTwoTwoPlus) HasPtr2() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s VerTwoTwoPlus) SetPtr2(v VerTwoDataTwoPtr) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewPtr2 sets the ptr2 field to a newly
// allocated VerTwoDataTwoPtr struct, preferring placement in s's segment.
func (s VerTwoTwoPlus) NewPtr2() (VerTwoDataTwoPtr, error) {
	ss, err := NewVerTwoDataTwoPtr(capnp.Struct(s).Segment())
	if err != nil {
		return VerTwoDataTwoPtr{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s VerTwoTwoPlus) Tre() int64 {
	return int64(capnp.Struct(s).Uint64(16))
}

func (s VerTwoTwoPlus) SetTre(v int64) {
	capnp.Struct(s).SetUint64(16, uint64(v))
}

func (s VerTwoTwoPlus) Lst3() (capnp.Int64List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.Int64List(p.List()), err
}

func (s VerTwoTwoPlus) HasLst3() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s VerTwoTwoPlus) SetLst3(v capnp.Int64List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewLst3 sets the lst3 field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s VerTwoTwoPlus) NewLst3(n int32) (capnp.Int64List, error) {
	l, err := capnp.NewInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// VerTwoTwoPlus_List is a list of VerTwoTwoPlus.
type VerTwoTwoPlus_List = capnp.StructList[VerTwoTwoPlus]

// NewVerTwoTwoPlus creates a new list of VerTwoTwoPlus.
func NewVerTwoTwoPlus_List(s *capnp.Segment, sz int32) (VerTwoTwoPlus_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3}, sz)
	return capnp.StructList[VerTwoTwoPlus](l), err
}

// VerTwoTwoPlus_Future is a wrapper for a VerTwoTwoPlus promised by a client call.
type VerTwoTwoPlus_Future struct{ *capnp.Future }

func (f VerTwoTwoPlus_Future) Struct() (VerTwoTwoPlus, error) {
	p, err := f.Future.Ptr()
	return VerTwoTwoPlus(p.Struct()), err
}
func (p VerTwoTwoPlus_Future) Ptr1() VerTwoDataTwoPtr_Future {
	return VerTwoDataTwoPtr_Future{Future: p.Future.Field(0, nil)}
}
func (p VerTwoTwoPlus_Future) Ptr2() VerTwoDataTwoPtr_Future {
	return VerTwoDataTwoPtr_Future{Future: p.Future.Field(1, nil)}
}

type HoldsText capnp.Struct

// HoldsText_TypeID is the unique identifier for the type HoldsText.
const HoldsText_TypeID = 0xe5817f849ff906dc

func NewHoldsText(s *capnp.Segment) (HoldsText, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return HoldsText(st), err
}

func NewRootHoldsText(s *capnp.Segment) (HoldsText, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return HoldsText(st), err
}

func ReadRootHoldsText(msg *capnp.Message) (HoldsText, error) {
	root, err := msg.Root()
	return HoldsText(root.Struct()), err
}

func (s HoldsText) String() string {
	str, _ := text.Marshal(0xe5817f849ff906dc, capnp.Struct(s))
	return str
}

func (s HoldsText) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HoldsText) DecodeFromPtr(p capnp.Ptr) HoldsText {
	return HoldsText(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HoldsText) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HoldsText) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HoldsText) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HoldsText) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HoldsText) Txt() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s HoldsText) HasTxt() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HoldsText) TxtBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s HoldsText) SetTxt(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s HoldsText) Lst() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s HoldsText) HasLst() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s HoldsText) SetLst(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewLst sets the lst field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s HoldsText) NewLst(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s HoldsText) Lstlst() (capnp.PointerList, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.PointerList(p.List()), err
}

func (s HoldsText) HasLstlst() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s HoldsText) SetLstlst(v capnp.PointerList) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewLstlst sets the lstlst field to a newly
// allocated capnp.PointerList, preferring placement in s's segment.
func (s HoldsText) NewLstlst(n int32) (capnp.PointerList, error) {
	l, err := capnp.NewPointerList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.PointerList{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// HoldsText_List is a list of HoldsText.
type HoldsText_List = capnp.StructList[HoldsText]

// NewHoldsText creates a new list of HoldsText.
func NewHoldsText_List(s *capnp.Segment, sz int32) (HoldsText_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[HoldsText](l), err
}

// HoldsText_Future is a wrapper for a HoldsText promised by a client call.
type HoldsText_Future struct{ *capnp.Future }

func (f HoldsText_Future) Struct() (HoldsText, error) {
	p, err := f.Future.Ptr()
	return HoldsText(p.Struct()), err
}

type WrapEmpty capnp.Struct

// WrapEmpty_TypeID is the unique identifier for the type WrapEmpty.
const WrapEmpty_TypeID = 0x9ab599979b02ac59

func NewWrapEmpty(s *capnp.Segment) (WrapEmpty, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return WrapEmpty(st), err
}

func NewRootWrapEmpty(s *capnp.Segment) (WrapEmpty, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return WrapEmpty(st), err
}

func ReadRootWrapEmpty(msg *capnp.Message) (WrapEmpty, error) {
	root, err := msg.Root()
	return WrapEmpty(root.Struct()), err
}

func (s WrapEmpty) String() string {
	str, _ := text.Marshal(0x9ab599979b02ac59, capnp.Struct(s))
	return str
}

func (s WrapEmpty) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (WrapEmpty) DecodeFromPtr(p capnp.Ptr) WrapEmpty {
	return WrapEmpty(capnp.Struct{}.DecodeFromPtr(p))
}

func (s WrapEmpty) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s WrapEmpty) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s WrapEmpty) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s WrapEmpty) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s WrapEmpty) MightNotBeReallyEmpty() (VerEmpty, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerEmpty(p.Struct()), err
}

func (s WrapEmpty) HasMightNotBeReallyEmpty() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s WrapEmpty) SetMightNotBeReallyEmpty(v VerEmpty) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewMightNotBeReallyEmpty sets the mightNotBeReallyEmpty field to a newly
// allocated VerEmpty struct, preferring placement in s's segment.
func (s WrapEmpty) NewMightNotBeReallyEmpty() (VerEmpty, error) {
	ss, err := NewVerEmpty(capnp.Struct(s).Segment())
	if err != nil {
		return VerEmpty{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// WrapEmpty_List is a list of WrapEmpty.
type WrapEmpty_List = capnp.StructList[WrapEmpty]

// NewWrapEmpty creates a new list of WrapEmpty.
func NewWrapEmpty_List(s *capnp.Segment, sz int32) (WrapEmpty_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[WrapEmpty](l), err
}

// WrapEmpty_Future is a wrapper for a WrapEmpty promised by a client call.
type WrapEmpty_Future struct{ *capnp.Future }

func (f WrapEmpty_Future) Struct() (WrapEmpty, error) {
	p, err := f.Future.Ptr()
	return WrapEmpty(p.Struct()), err
}
func (p WrapEmpty_Future) MightNotBeReallyEmpty() VerEmpty_Future {
	return VerEmpty_Future{Future: p.Future.Field(0, nil)}
}

type Wrap2x2 capnp.Struct

// Wrap2x2_TypeID is the unique identifier for the type Wrap2x2.
const Wrap2x2_TypeID = 0xe1a2d1d51107bead

func NewWrap2x2(s *capnp.Segment) (Wrap2x2, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Wrap2x2(st), err
}

func NewRootWrap2x2(s *capnp.Segment) (Wrap2x2, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Wrap2x2(st), err
}

func ReadRootWrap2x2(msg *capnp.Message) (Wrap2x2, error) {
	root, err := msg.Root()
	return Wrap2x2(root.Struct()), err
}

func (s Wrap2x2) String() string {
	str, _ := text.Marshal(0xe1a2d1d51107bead, capnp.Struct(s))
	return str
}

func (s Wrap2x2) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Wrap2x2) DecodeFromPtr(p capnp.Ptr) Wrap2x2 {
	return Wrap2x2(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Wrap2x2) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Wrap2x2) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Wrap2x2) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Wrap2x2) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Wrap2x2) MightNotBeReallyEmpty() (VerTwoDataTwoPtr, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerTwoDataTwoPtr(p.Struct()), err
}

func (s Wrap2x2) HasMightNotBeReallyEmpty() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Wrap2x2) SetMightNotBeReallyEmpty(v VerTwoDataTwoPtr) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewMightNotBeReallyEmpty sets the mightNotBeReallyEmpty field to a newly
// allocated VerTwoDataTwoPtr struct, preferring placement in s's segment.
func (s Wrap2x2) NewMightNotBeReallyEmpty() (VerTwoDataTwoPtr, error) {
	ss, err := NewVerTwoDataTwoPtr(capnp.Struct(s).Segment())
	if err != nil {
		return VerTwoDataTwoPtr{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Wrap2x2_List is a list of Wrap2x2.
type Wrap2x2_List = capnp.StructList[Wrap2x2]

// NewWrap2x2 creates a new list of Wrap2x2.
func NewWrap2x2_List(s *capnp.Segment, sz int32) (Wrap2x2_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Wrap2x2](l), err
}

// Wrap2x2_Future is a wrapper for a Wrap2x2 promised by a client call.
type Wrap2x2_Future struct{ *capnp.Future }

func (f Wrap2x2_Future) Struct() (Wrap2x2, error) {
	p, err := f.Future.Ptr()
	return Wrap2x2(p.Struct()), err
}
func (p Wrap2x2_Future) MightNotBeReallyEmpty() VerTwoDataTwoPtr_Future {
	return VerTwoDataTwoPtr_Future{Future: p.Future.Field(0, nil)}
}

type Wrap2x2plus capnp.Struct

// Wrap2x2plus_TypeID is the unique identifier for the type Wrap2x2plus.
const Wrap2x2plus_TypeID = 0xe684eb3aef1a6859

func NewWrap2x2plus(s *capnp.Segment) (Wrap2x2plus, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Wrap2x2plus(st), err
}

func NewRootWrap2x2plus(s *capnp.Segment) (Wrap2x2plus, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Wrap2x2plus(st), err
}

func ReadRootWrap2x2plus(msg *capnp.Message) (Wrap2x2plus, error) {
	root, err := msg.Root()
	return Wrap2x2plus(root.Struct()), err
}

func (s Wrap2x2plus) String() string {
	str, _ := text.Marshal(0xe684eb3aef1a6859, capnp.Struct(s))
	return str
}

func (s Wrap2x2plus) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Wrap2x2plus) DecodeFromPtr(p capnp.Ptr) Wrap2x2plus {
	return Wrap2x2plus(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Wrap2x2plus) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Wrap2x2plus) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Wrap2x2plus) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Wrap2x2plus) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Wrap2x2plus) MightNotBeReallyEmpty() (VerTwoTwoPlus, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VerTwoTwoPlus(p.Struct()), err
}

func (s Wrap2x2plus) HasMightNotBeReallyEmpty() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Wrap2x2plus) SetMightNotBeReallyEmpty(v VerTwoTwoPlus) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewMightNotBeReallyEmpty sets the mightNotBeReallyEmpty field to a newly
// allocated VerTwoTwoPlus struct, preferring placement in s's segment.
func (s Wrap2x2plus) NewMightNotBeReallyEmpty() (VerTwoTwoPlus, error) {
	ss, err := NewVerTwoTwoPlus(capnp.Struct(s).Segment())
	if err != nil {
		return VerTwoTwoPlus{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Wrap2x2plus_List is a list of Wrap2x2plus.
type Wrap2x2plus_List = capnp.StructList[Wrap2x2plus]

// NewWrap2x2plus creates a new list of Wrap2x2plus.
func NewWrap2x2plus_List(s *capnp.Segment, sz int32) (Wrap2x2plus_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Wrap2x2plus](l), err
}

// Wrap2x2plus_Future is a wrapper for a Wrap2x2plus promised by a client call.
type Wrap2x2plus_Future struct{ *capnp.Future }

func (f Wrap2x2plus_Future) Struct() (Wrap2x2plus, error) {
	p, err := f.Future.Ptr()
	return Wrap2x2plus(p.Struct()), err
}
func (p Wrap2x2plus_Future) MightNotBeReallyEmpty() VerTwoTwoPlus_Future {
	return VerTwoTwoPlus_Future{Future: p.Future.Field(0, nil)}
}

type VoidUnion capnp.Struct
type VoidUnion_Which uint16

const (
	VoidUnion_Which_a VoidUnion_Which = 0
	VoidUnion_Which_b VoidUnion_Which = 1
)

func (w VoidUnion_Which) String() string {
	const s = "ab"
	switch w {
	case VoidUnion_Which_a:
		return s[0:1]
	case VoidUnion_Which_b:
		return s[1:2]

	}
	return "VoidUnion_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// VoidUnion_TypeID is the unique identifier for the type VoidUnion.
const VoidUnion_TypeID = 0x8821cdb23640783a

func NewVoidUnion(s *capnp.Segment) (VoidUnion, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return VoidUnion(st), err
}

func NewRootVoidUnion(s *capnp.Segment) (VoidUnion, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return VoidUnion(st), err
}

func ReadRootVoidUnion(msg *capnp.Message) (VoidUnion, error) {
	root, err := msg.Root()
	return VoidUnion(root.Struct()), err
}

func (s VoidUnion) String() string {
	str, _ := text.Marshal(0x8821cdb23640783a, capnp.Struct(s))
	return str
}

func (s VoidUnion) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VoidUnion) DecodeFromPtr(p capnp.Ptr) VoidUnion {
	return VoidUnion(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VoidUnion) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s VoidUnion) Which() VoidUnion_Which {
	return VoidUnion_Which(capnp.Struct(s).Uint16(0))
}
func (s VoidUnion) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VoidUnion) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VoidUnion) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VoidUnion) SetA() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s VoidUnion) SetB() {
	capnp.Struct(s).SetUint16(0, 1)

}

// VoidUnion_List is a list of VoidUnion.
type VoidUnion_List = capnp.StructList[VoidUnion]

// NewVoidUnion creates a new list of VoidUnion.
func NewVoidUnion_List(s *capnp.Segment, sz int32) (VoidUnion_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[VoidUnion](l), err
}

// VoidUnion_Future is a wrapper for a VoidUnion promised by a client call.
type VoidUnion_Future struct{ *capnp.Future }

func (f VoidUnion_Future) Struct() (VoidUnion, error) {
	p, err := f.Future.Ptr()
	return VoidUnion(p.Struct()), err
}

type Nester1Capn capnp.Struct

// Nester1Capn_TypeID is the unique identifier for the type Nester1Capn.
const Nester1Capn_TypeID = 0xf14fad09425d081c

func NewNester1Capn(s *capnp.Segment) (Nester1Capn, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Nester1Capn(st), err
}

func NewRootNester1Capn(s *capnp.Segment) (Nester1Capn, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Nester1Capn(st), err
}

func ReadRootNester1Capn(msg *capnp.Message) (Nester1Capn, error) {
	root, err := msg.Root()
	return Nester1Capn(root.Struct()), err
}

func (s Nester1Capn) String() string {
	str, _ := text.Marshal(0xf14fad09425d081c, capnp.Struct(s))
	return str
}

func (s Nester1Capn) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Nester1Capn) DecodeFromPtr(p capnp.Ptr) Nester1Capn {
	return Nester1Capn(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Nester1Capn) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Nester1Capn) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Nester1Capn) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Nester1Capn) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Nester1Capn) Strs() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s Nester1Capn) HasStrs() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Nester1Capn) SetStrs(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewStrs sets the strs field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Nester1Capn) NewStrs(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Nester1Capn_List is a list of Nester1Capn.
type Nester1Capn_List = capnp.StructList[Nester1Capn]

// NewNester1Capn creates a new list of Nester1Capn.
func NewNester1Capn_List(s *capnp.Segment, sz int32) (Nester1Capn_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Nester1Capn](l), err
}

// Nester1Capn_Future is a wrapper for a Nester1Capn promised by a client call.
type Nester1Capn_Future struct{ *capnp.Future }

func (f Nester1Capn_Future) Struct() (Nester1Capn, error) {
	p, err := f.Future.Ptr()
	return Nester1Capn(p.Struct()), err
}

type RWTestCapn capnp.Struct

// RWTestCapn_TypeID is the unique identifier for the type RWTestCapn.
const RWTestCapn_TypeID = 0xf7ff4414476c186a

func NewRWTestCapn(s *capnp.Segment) (RWTestCapn, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RWTestCapn(st), err
}

func NewRootRWTestCapn(s *capnp.Segment) (RWTestCapn, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return RWTestCapn(st), err
}

func ReadRootRWTestCapn(msg *capnp.Message) (RWTestCapn, error) {
	root, err := msg.Root()
	return RWTestCapn(root.Struct()), err
}

func (s RWTestCapn) String() string {
	str, _ := text.Marshal(0xf7ff4414476c186a, capnp.Struct(s))
	return str
}

func (s RWTestCapn) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (RWTestCapn) DecodeFromPtr(p capnp.Ptr) RWTestCapn {
	return RWTestCapn(capnp.Struct{}.DecodeFromPtr(p))
}

func (s RWTestCapn) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s RWTestCapn) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s RWTestCapn) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s RWTestCapn) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s RWTestCapn) NestMatrix() (capnp.PointerList, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.PointerList(p.List()), err
}

func (s RWTestCapn) HasNestMatrix() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s RWTestCapn) SetNestMatrix(v capnp.PointerList) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewNestMatrix sets the nestMatrix field to a newly
// allocated capnp.PointerList, preferring placement in s's segment.
func (s RWTestCapn) NewNestMatrix(n int32) (capnp.PointerList, error) {
	l, err := capnp.NewPointerList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.PointerList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// RWTestCapn_List is a list of RWTestCapn.
type RWTestCapn_List = capnp.StructList[RWTestCapn]

// NewRWTestCapn creates a new list of RWTestCapn.
func NewRWTestCapn_List(s *capnp.Segment, sz int32) (RWTestCapn_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[RWTestCapn](l), err
}

// RWTestCapn_Future is a wrapper for a RWTestCapn promised by a client call.
type RWTestCapn_Future struct{ *capnp.Future }

func (f RWTestCapn_Future) Struct() (RWTestCapn, error) {
	p, err := f.Future.Ptr()
	return RWTestCapn(p.Struct()), err
}

type ListStructCapn capnp.Struct

// ListStructCapn_TypeID is the unique identifier for the type ListStructCapn.
const ListStructCapn_TypeID = 0xb1ac056ed7647011

func NewListStructCapn(s *capnp.Segment) (ListStructCapn, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ListStructCapn(st), err
}

func NewRootListStructCapn(s *capnp.Segment) (ListStructCapn, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return ListStructCapn(st), err
}

func ReadRootListStructCapn(msg *capnp.Message) (ListStructCapn, error) {
	root, err := msg.Root()
	return ListStructCapn(root.Struct()), err
}

func (s ListStructCapn) String() string {
	str, _ := text.Marshal(0xb1ac056ed7647011, capnp.Struct(s))
	return str
}

func (s ListStructCapn) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (ListStructCapn) DecodeFromPtr(p capnp.Ptr) ListStructCapn {
	return ListStructCapn(capnp.Struct{}.DecodeFromPtr(p))
}

func (s ListStructCapn) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s ListStructCapn) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s ListStructCapn) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s ListStructCapn) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s ListStructCapn) Vec() (Nester1Capn_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Nester1Capn_List(p.List()), err
}

func (s ListStructCapn) HasVec() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s ListStructCapn) SetVec(v Nester1Capn_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewVec sets the vec field to a newly
// allocated Nester1Capn_List, preferring placement in s's segment.
func (s ListStructCapn) NewVec(n int32) (Nester1Capn_List, error) {
	l, err := NewNester1Capn_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Nester1Capn_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// ListStructCapn_List is a list of ListStructCapn.
type ListStructCapn_List = capnp.StructList[ListStructCapn]

// NewListStructCapn creates a new list of ListStructCapn.
func NewListStructCapn_List(s *capnp.Segment, sz int32) (ListStructCapn_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[ListStructCapn](l), err
}

// ListStructCapn_Future is a wrapper for a ListStructCapn promised by a client call.
type ListStructCapn_Future struct{ *capnp.Future }

func (f ListStructCapn_Future) Struct() (ListStructCapn, error) {
	p, err := f.Future.Ptr()
	return ListStructCapn(p.Struct()), err
}

type Echo capnp.Client

// Echo_TypeID is the unique identifier for the type Echo.
const Echo_TypeID = 0x8e5322c1e9282534

func (c Echo) Echo(ctx context.Context, params func(Echo_echo_Params) error) (Echo_echo_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8e5322c1e9282534,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:Echo",
			MethodName:    "echo",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Echo_echo_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Echo_echo_Results_Future{Future: ans.Future()}, release

}

func (c Echo) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Echo) String() string {
	return "Echo(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Echo) AddRef() Echo {
	return Echo(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Echo) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Echo) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Echo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Echo) DecodeFromPtr(p capnp.Ptr) Echo {
	return Echo(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Echo) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Echo) IsSame(other Echo) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Echo) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Echo) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Echo_Server is a Echo with a local implementation.
type Echo_Server interface {
	Echo(context.Context, Echo_echo) error
}

// Echo_NewServer creates a new Server from an implementation of Echo_Server.
func Echo_NewServer(s Echo_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Echo_Methods(nil, s), s, c)
}

// Echo_ServerToClient creates a new Client from an implementation of Echo_Server.
// The caller is responsible for calling Release on the returned Client.
func Echo_ServerToClient(s Echo_Server) Echo {
	return Echo(capnp.NewClient(Echo_NewServer(s)))
}

// Echo_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Echo_Methods(methods []server.Method, s Echo_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8e5322c1e9282534,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:Echo",
			MethodName:    "echo",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Echo(ctx, Echo_echo{call})
		},
	})

	return methods
}

// Echo_echo holds the state for a server call to Echo.echo.
// See server.Call for documentation.
type Echo_echo struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Echo_echo) Args() Echo_echo_Params {
	return Echo_echo_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Echo_echo) AllocResults() (Echo_echo_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Echo_echo_Results(r), err
}

// Echo_List is a list of Echo.
type Echo_List = capnp.CapList[Echo]

// NewEcho creates a new list of Echo.
func NewEcho_List(s *capnp.Segment, sz int32) (Echo_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Echo](l), err
}

type Echo_echo_Params capnp.Struct

// Echo_echo_Params_TypeID is the unique identifier for the type Echo_echo_Params.
const Echo_echo_Params_TypeID = 0x8a165fb4d71bf3a2

func NewEcho_echo_Params(s *capnp.Segment) (Echo_echo_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Echo_echo_Params(st), err
}

func NewRootEcho_echo_Params(s *capnp.Segment) (Echo_echo_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Echo_echo_Params(st), err
}

func ReadRootEcho_echo_Params(msg *capnp.Message) (Echo_echo_Params, error) {
	root, err := msg.Root()
	return Echo_echo_Params(root.Struct()), err
}

func (s Echo_echo_Params) String() string {
	str, _ := text.Marshal(0x8a165fb4d71bf3a2, capnp.Struct(s))
	return str
}

func (s Echo_echo_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Echo_echo_Params) DecodeFromPtr(p capnp.Ptr) Echo_echo_Params {
	return Echo_echo_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Echo_echo_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Echo_echo_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Echo_echo_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Echo_echo_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Echo_echo_Params) In() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Echo_echo_Params) HasIn() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Echo_echo_Params) InBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Echo_echo_Params) SetIn(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Echo_echo_Params_List is a list of Echo_echo_Params.
type Echo_echo_Params_List = capnp.StructList[Echo_echo_Params]

// NewEcho_echo_Params creates a new list of Echo_echo_Params.
func NewEcho_echo_Params_List(s *capnp.Segment, sz int32) (Echo_echo_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Echo_echo_Params](l), err
}

// Echo_echo_Params_Future is a wrapper for a Echo_echo_Params promised by a client call.
type Echo_echo_Params_Future struct{ *capnp.Future }

func (f Echo_echo_Params_Future) Struct() (Echo_echo_Params, error) {
	p, err := f.Future.Ptr()
	return Echo_echo_Params(p.Struct()), err
}

type Echo_echo_Results capnp.Struct

// Echo_echo_Results_TypeID is the unique identifier for the type Echo_echo_Results.
const Echo_echo_Results_TypeID = 0x9b37d729b9dd7b9d

func NewEcho_echo_Results(s *capnp.Segment) (Echo_echo_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Echo_echo_Results(st), err
}

func NewRootEcho_echo_Results(s *capnp.Segment) (Echo_echo_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Echo_echo_Results(st), err
}

func ReadRootEcho_echo_Results(msg *capnp.Message) (Echo_echo_Results, error) {
	root, err := msg.Root()
	return Echo_echo_Results(root.Struct()), err
}

func (s Echo_echo_Results) String() string {
	str, _ := text.Marshal(0x9b37d729b9dd7b9d, capnp.Struct(s))
	return str
}

func (s Echo_echo_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Echo_echo_Results) DecodeFromPtr(p capnp.Ptr) Echo_echo_Results {
	return Echo_echo_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Echo_echo_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Echo_echo_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Echo_echo_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Echo_echo_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Echo_echo_Results) Out() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Echo_echo_Results) HasOut() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Echo_echo_Results) OutBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Echo_echo_Results) SetOut(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Echo_echo_Results_List is a list of Echo_echo_Results.
type Echo_echo_Results_List = capnp.StructList[Echo_echo_Results]

// NewEcho_echo_Results creates a new list of Echo_echo_Results.
func NewEcho_echo_Results_List(s *capnp.Segment, sz int32) (Echo_echo_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Echo_echo_Results](l), err
}

// Echo_echo_Results_Future is a wrapper for a Echo_echo_Results promised by a client call.
type Echo_echo_Results_Future struct{ *capnp.Future }

func (f Echo_echo_Results_Future) Struct() (Echo_echo_Results, error) {
	p, err := f.Future.Ptr()
	return Echo_echo_Results(p.Struct()), err
}

type Hoth capnp.Struct

// Hoth_TypeID is the unique identifier for the type Hoth.
const Hoth_TypeID = 0xad87da456fb0ebb9

func NewHoth(s *capnp.Segment) (Hoth, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Hoth(st), err
}

func NewRootHoth(s *capnp.Segment) (Hoth, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Hoth(st), err
}

func ReadRootHoth(msg *capnp.Message) (Hoth, error) {
	root, err := msg.Root()
	return Hoth(root.Struct()), err
}

func (s Hoth) String() string {
	str, _ := text.Marshal(0xad87da456fb0ebb9, capnp.Struct(s))
	return str
}

func (s Hoth) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Hoth) DecodeFromPtr(p capnp.Ptr) Hoth {
	return Hoth(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Hoth) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Hoth) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Hoth) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Hoth) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Hoth) Base() (EchoBase, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return EchoBase(p.Struct()), err
}

func (s Hoth) HasBase() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Hoth) SetBase(v EchoBase) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewBase sets the base field to a newly
// allocated EchoBase struct, preferring placement in s's segment.
func (s Hoth) NewBase() (EchoBase, error) {
	ss, err := NewEchoBase(capnp.Struct(s).Segment())
	if err != nil {
		return EchoBase{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Hoth_List is a list of Hoth.
type Hoth_List = capnp.StructList[Hoth]

// NewHoth creates a new list of Hoth.
func NewHoth_List(s *capnp.Segment, sz int32) (Hoth_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Hoth](l), err
}

// Hoth_Future is a wrapper for a Hoth promised by a client call.
type Hoth_Future struct{ *capnp.Future }

func (f Hoth_Future) Struct() (Hoth, error) {
	p, err := f.Future.Ptr()
	return Hoth(p.Struct()), err
}
func (p Hoth_Future) Base() EchoBase_Future {
	return EchoBase_Future{Future: p.Future.Field(0, nil)}
}

type EchoBase capnp.Struct

// EchoBase_TypeID is the unique identifier for the type EchoBase.
const EchoBase_TypeID = 0xa8bf13fef2674866

func NewEchoBase(s *capnp.Segment) (EchoBase, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return EchoBase(st), err
}

func NewRootEchoBase(s *capnp.Segment) (EchoBase, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return EchoBase(st), err
}

func ReadRootEchoBase(msg *capnp.Message) (EchoBase, error) {
	root, err := msg.Root()
	return EchoBase(root.Struct()), err
}

func (s EchoBase) String() string {
	str, _ := text.Marshal(0xa8bf13fef2674866, capnp.Struct(s))
	return str
}

func (s EchoBase) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (EchoBase) DecodeFromPtr(p capnp.Ptr) EchoBase {
	return EchoBase(capnp.Struct{}.DecodeFromPtr(p))
}

func (s EchoBase) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s EchoBase) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s EchoBase) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s EchoBase) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s EchoBase) Echo() Echo {
	p, _ := capnp.Struct(s).Ptr(0)
	return Echo(p.Interface().Client())
}

func (s EchoBase) HasEcho() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s EchoBase) SetEcho(v Echo) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// EchoBase_List is a list of EchoBase.
type EchoBase_List = capnp.StructList[EchoBase]

// NewEchoBase creates a new list of EchoBase.
func NewEchoBase_List(s *capnp.Segment, sz int32) (EchoBase_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[EchoBase](l), err
}

// EchoBase_Future is a wrapper for a EchoBase promised by a client call.
type EchoBase_Future struct{ *capnp.Future }

func (f EchoBase_Future) Struct() (EchoBase, error) {
	p, err := f.Future.Ptr()
	return EchoBase(p.Struct()), err
}
func (p EchoBase_Future) Echo() Echo {
	return Echo(p.Future.Field(0, nil).Client())
}

type StackingRoot capnp.Struct

// StackingRoot_TypeID is the unique identifier for the type StackingRoot.
const StackingRoot_TypeID = 0x8fae7b41c61fc890

func NewStackingRoot(s *capnp.Segment) (StackingRoot, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return StackingRoot(st), err
}

func NewRootStackingRoot(s *capnp.Segment) (StackingRoot, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return StackingRoot(st), err
}

func ReadRootStackingRoot(msg *capnp.Message) (StackingRoot, error) {
	root, err := msg.Root()
	return StackingRoot(root.Struct()), err
}

func (s StackingRoot) String() string {
	str, _ := text.Marshal(0x8fae7b41c61fc890, capnp.Struct(s))
	return str
}

func (s StackingRoot) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (StackingRoot) DecodeFromPtr(p capnp.Ptr) StackingRoot {
	return StackingRoot(capnp.Struct{}.DecodeFromPtr(p))
}

func (s StackingRoot) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s StackingRoot) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s StackingRoot) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s StackingRoot) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s StackingRoot) A() (StackingA, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return StackingA(p.Struct()), err
}

func (s StackingRoot) HasA() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s StackingRoot) SetA(v StackingA) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewA sets the a field to a newly
// allocated StackingA struct, preferring placement in s's segment.
func (s StackingRoot) NewA() (StackingA, error) {
	ss, err := NewStackingA(capnp.Struct(s).Segment())
	if err != nil {
		return StackingA{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s StackingRoot) AWithDefault() (StackingA, error) {
	p, err := capnp.Struct(s).Ptr(0)
	if err != nil {
		return StackingA{}, err
	}
	ss, err := p.StructDefault(x_832bcc6686a26d56[64:96])
	return StackingA(ss), err
}

func (s StackingRoot) HasAWithDefault() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s StackingRoot) SetAWithDefault(v StackingA) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewAWithDefault sets the aWithDefault field to a newly
// allocated StackingA struct, preferring placement in s's segment.
func (s StackingRoot) NewAWithDefault() (StackingA, error) {
	ss, err := NewStackingA(capnp.Struct(s).Segment())
	if err != nil {
		return StackingA{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// StackingRoot_List is a list of StackingRoot.
type StackingRoot_List = capnp.StructList[StackingRoot]

// NewStackingRoot creates a new list of StackingRoot.
func NewStackingRoot_List(s *capnp.Segment, sz int32) (StackingRoot_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[StackingRoot](l), err
}

// StackingRoot_Future is a wrapper for a StackingRoot promised by a client call.
type StackingRoot_Future struct{ *capnp.Future }

func (f StackingRoot_Future) Struct() (StackingRoot, error) {
	p, err := f.Future.Ptr()
	return StackingRoot(p.Struct()), err
}
func (p StackingRoot_Future) A() StackingA_Future {
	return StackingA_Future{Future: p.Future.Field(1, nil)}
}
func (p StackingRoot_Future) AWithDefault() StackingA_Future {
	return StackingA_Future{Future: p.Future.Field(0, x_832bcc6686a26d56[96:128])}
}

type StackingA capnp.Struct

// StackingA_TypeID is the unique identifier for the type StackingA.
const StackingA_TypeID = 0x9d3032ff86043b75

func NewStackingA(s *capnp.Segment) (StackingA, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return StackingA(st), err
}

func NewRootStackingA(s *capnp.Segment) (StackingA, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return StackingA(st), err
}

func ReadRootStackingA(msg *capnp.Message) (StackingA, error) {
	root, err := msg.Root()
	return StackingA(root.Struct()), err
}

func (s StackingA) String() string {
	str, _ := text.Marshal(0x9d3032ff86043b75, capnp.Struct(s))
	return str
}

func (s StackingA) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (StackingA) DecodeFromPtr(p capnp.Ptr) StackingA {
	return StackingA(capnp.Struct{}.DecodeFromPtr(p))
}

func (s StackingA) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s StackingA) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s StackingA) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s StackingA) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s StackingA) Num() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s StackingA) SetNum(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

func (s StackingA) B() (StackingB, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return StackingB(p.Struct()), err
}

func (s StackingA) HasB() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s StackingA) SetB(v StackingB) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewB sets the b field to a newly
// allocated StackingB struct, preferring placement in s's segment.
func (s StackingA) NewB() (StackingB, error) {
	ss, err := NewStackingB(capnp.Struct(s).Segment())
	if err != nil {
		return StackingB{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// StackingA_List is a list of StackingA.
type StackingA_List = capnp.StructList[StackingA]

// NewStackingA creates a new list of StackingA.
func NewStackingA_List(s *capnp.Segment, sz int32) (StackingA_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[StackingA](l), err
}

// StackingA_Future is a wrapper for a StackingA promised by a client call.
type StackingA_Future struct{ *capnp.Future }

func (f StackingA_Future) Struct() (StackingA, error) {
	p, err := f.Future.Ptr()
	return StackingA(p.Struct()), err
}
func (p StackingA_Future) B() StackingB_Future {
	return StackingB_Future{Future: p.Future.Field(0, nil)}
}

type StackingB capnp.Struct

// StackingB_TypeID is the unique identifier for the type StackingB.
const StackingB_TypeID = 0x85257b30d6edf8c5

func NewStackingB(s *capnp.Segment) (StackingB, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return StackingB(st), err
}

func NewRootStackingB(s *capnp.Segment) (StackingB, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return StackingB(st), err
}

func ReadRootStackingB(msg *capnp.Message) (StackingB, error) {
	root, err := msg.Root()
	return StackingB(root.Struct()), err
}

func (s StackingB) String() string {
	str, _ := text.Marshal(0x85257b30d6edf8c5, capnp.Struct(s))
	return str
}

func (s StackingB) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (StackingB) DecodeFromPtr(p capnp.Ptr) StackingB {
	return StackingB(capnp.Struct{}.DecodeFromPtr(p))
}

func (s StackingB) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s StackingB) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s StackingB) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s StackingB) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s StackingB) Num() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s StackingB) SetNum(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

// StackingB_List is a list of StackingB.
type StackingB_List = capnp.StructList[StackingB]

// NewStackingB creates a new list of StackingB.
func NewStackingB_List(s *capnp.Segment, sz int32) (StackingB_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[StackingB](l), err
}

// StackingB_Future is a wrapper for a StackingB promised by a client call.
type StackingB_Future struct{ *capnp.Future }

func (f StackingB_Future) Struct() (StackingB, error) {
	p, err := f.Future.Ptr()
	return StackingB(p.Struct()), err
}

type CallSequence capnp.Client

// CallSequence_TypeID is the unique identifier for the type CallSequence.
const CallSequence_TypeID = 0xabaedf5f7817c820

func (c CallSequence) GetNumber(ctx context.Context, params func(CallSequence_getNumber_Params) error) (CallSequence_getNumber_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xabaedf5f7817c820,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:CallSequence",
			MethodName:    "getNumber",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(CallSequence_getNumber_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return CallSequence_getNumber_Results_Future{Future: ans.Future()}, release

}

func (c CallSequence) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c CallSequence) String() string {
	return "CallSequence(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c CallSequence) AddRef() CallSequence {
	return CallSequence(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c CallSequence) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c CallSequence) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c CallSequence) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (CallSequence) DecodeFromPtr(p capnp.Ptr) CallSequence {
	return CallSequence(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c CallSequence) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c CallSequence) IsSame(other CallSequence) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c CallSequence) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c CallSequence) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A CallSequence_Server is a CallSequence with a local implementation.
type CallSequence_Server interface {
	GetNumber(context.Context, CallSequence_getNumber) error
}

// CallSequence_NewServer creates a new Server from an implementation of CallSequence_Server.
func CallSequence_NewServer(s CallSequence_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(CallSequence_Methods(nil, s), s, c)
}

// CallSequence_ServerToClient creates a new Client from an implementation of CallSequence_Server.
// The caller is responsible for calling Release on the returned Client.
func CallSequence_ServerToClient(s CallSequence_Server) CallSequence {
	return CallSequence(capnp.NewClient(CallSequence_NewServer(s)))
}

// CallSequence_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func CallSequence_Methods(methods []server.Method, s CallSequence_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xabaedf5f7817c820,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:CallSequence",
			MethodName:    "getNumber",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.GetNumber(ctx, CallSequence_getNumber{call})
		},
	})

	return methods
}

// CallSequence_getNumber holds the state for a server call to CallSequence.getNumber.
// See server.Call for documentation.
type CallSequence_getNumber struct {
	*server.Call
}

// Args returns the call's arguments.
func (c CallSequence_getNumber) Args() CallSequence_getNumber_Params {
	return CallSequence_getNumber_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c CallSequence_getNumber) AllocResults() (CallSequence_getNumber_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return CallSequence_getNumber_Results(r), err
}

// CallSequence_List is a list of CallSequence.
type CallSequence_List = capnp.CapList[CallSequence]

// NewCallSequence creates a new list of CallSequence.
func NewCallSequence_List(s *capnp.Segment, sz int32) (CallSequence_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[CallSequence](l), err
}

type CallSequence_getNumber_Params capnp.Struct

// CallSequence_getNumber_Params_TypeID is the unique identifier for the type CallSequence_getNumber_Params.
const CallSequence_getNumber_Params_TypeID = 0xf58782f48a121998

func NewCallSequence_getNumber_Params(s *capnp.Segment) (CallSequence_getNumber_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return CallSequence_getNumber_Params(st), err
}

func NewRootCallSequence_getNumber_Params(s *capnp.Segment) (CallSequence_getNumber_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return CallSequence_getNumber_Params(st), err
}

func ReadRootCallSequence_getNumber_Params(msg *capnp.Message) (CallSequence_getNumber_Params, error) {
	root, err := msg.Root()
	return CallSequence_getNumber_Params(root.Struct()), err
}

func (s CallSequence_getNumber_Params) String() string {
	str, _ := text.Marshal(0xf58782f48a121998, capnp.Struct(s))
	return str
}

func (s CallSequence_getNumber_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (CallSequence_getNumber_Params) DecodeFromPtr(p capnp.Ptr) CallSequence_getNumber_Params {
	return CallSequence_getNumber_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s CallSequence_getNumber_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s CallSequence_getNumber_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s CallSequence_getNumber_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s CallSequence_getNumber_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// CallSequence_getNumber_Params_List is a list of CallSequence_getNumber_Params.
type CallSequence_getNumber_Params_List = capnp.StructList[CallSequence_getNumber_Params]

// NewCallSequence_getNumber_Params creates a new list of CallSequence_getNumber_Params.
func NewCallSequence_getNumber_Params_List(s *capnp.Segment, sz int32) (CallSequence_getNumber_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[CallSequence_getNumber_Params](l), err
}

// CallSequence_getNumber_Params_Future is a wrapper for a CallSequence_getNumber_Params promised by a client call.
type CallSequence_getNumber_Params_Future struct{ *capnp.Future }

func (f CallSequence_getNumber_Params_Future) Struct() (CallSequence_getNumber_Params, error) {
	p, err := f.Future.Ptr()
	return CallSequence_getNumber_Params(p.Struct()), err
}

type CallSequence_getNumber_Results capnp.Struct

// CallSequence_getNumber_Results_TypeID is the unique identifier for the type CallSequence_getNumber_Results.
const CallSequence_getNumber_Results_TypeID = 0xa465f9502fd11e97

func NewCallSequence_getNumber_Results(s *capnp.Segment) (CallSequence_getNumber_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return CallSequence_getNumber_Results(st), err
}

func NewRootCallSequence_getNumber_Results(s *capnp.Segment) (CallSequence_getNumber_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return CallSequence_getNumber_Results(st), err
}

func ReadRootCallSequence_getNumber_Results(msg *capnp.Message) (CallSequence_getNumber_Results, error) {
	root, err := msg.Root()
	return CallSequence_getNumber_Results(root.Struct()), err
}

func (s CallSequence_getNumber_Results) String() string {
	str, _ := text.Marshal(0xa465f9502fd11e97, capnp.Struct(s))
	return str
}

func (s CallSequence_getNumber_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (CallSequence_getNumber_Results) DecodeFromPtr(p capnp.Ptr) CallSequence_getNumber_Results {
	return CallSequence_getNumber_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s CallSequence_getNumber_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s CallSequence_getNumber_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s CallSequence_getNumber_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s CallSequence_getNumber_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s CallSequence_getNumber_Results) N() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s CallSequence_getNumber_Results) SetN(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

// CallSequence_getNumber_Results_List is a list of CallSequence_getNumber_Results.
type CallSequence_getNumber_Results_List = capnp.StructList[CallSequence_getNumber_Results]

// NewCallSequence_getNumber_Results creates a new list of CallSequence_getNumber_Results.
func NewCallSequence_getNumber_Results_List(s *capnp.Segment, sz int32) (CallSequence_getNumber_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[CallSequence_getNumber_Results](l), err
}

// CallSequence_getNumber_Results_Future is a wrapper for a CallSequence_getNumber_Results promised by a client call.
type CallSequence_getNumber_Results_Future struct{ *capnp.Future }

func (f CallSequence_getNumber_Results_Future) Struct() (CallSequence_getNumber_Results, error) {
	p, err := f.Future.Ptr()
	return CallSequence_getNumber_Results(p.Struct()), err
}

type Pipeliner capnp.Client

// Pipeliner_TypeID is the unique identifier for the type Pipeliner.
const Pipeliner_TypeID = 0xd6514008f0f84ebc

func (c Pipeliner) NewPipeliner(ctx context.Context, params func(Pipeliner_newPipeliner_Params) error) (Pipeliner_newPipeliner_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xd6514008f0f84ebc,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:Pipeliner",
			MethodName:    "newPipeliner",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Pipeliner_newPipeliner_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Pipeliner_newPipeliner_Results_Future{Future: ans.Future()}, release

}

func (c Pipeliner) GetNumber(ctx context.Context, params func(CallSequence_getNumber_Params) error) (CallSequence_getNumber_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xabaedf5f7817c820,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:CallSequence",
			MethodName:    "getNumber",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(CallSequence_getNumber_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return CallSequence_getNumber_Results_Future{Future: ans.Future()}, release

}

func (c Pipeliner) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Pipeliner) String() string {
	return "Pipeliner(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Pipeliner) AddRef() Pipeliner {
	return Pipeliner(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Pipeliner) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Pipeliner) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Pipeliner) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Pipeliner) DecodeFromPtr(p capnp.Ptr) Pipeliner {
	return Pipeliner(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Pipeliner) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Pipeliner) IsSame(other Pipeliner) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Pipeliner) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Pipeliner) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Pipeliner_Server is a Pipeliner with a local implementation.
type Pipeliner_Server interface {
	NewPipeliner(context.Context, Pipeliner_newPipeliner) error

	GetNumber(context.Context, CallSequence_getNumber) error
}

// Pipeliner_NewServer creates a new Server from an implementation of Pipeliner_Server.
func Pipeliner_NewServer(s Pipeliner_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Pipeliner_Methods(nil, s), s, c)
}

// Pipeliner_ServerToClient creates a new Client from an implementation of Pipeliner_Server.
// The caller is responsible for calling Release on the returned Client.
func Pipeliner_ServerToClient(s Pipeliner_Server) Pipeliner {
	return Pipeliner(capnp.NewClient(Pipeliner_NewServer(s)))
}

// Pipeliner_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Pipeliner_Methods(methods []server.Method, s Pipeliner_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xd6514008f0f84ebc,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:Pipeliner",
			MethodName:    "newPipeliner",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.NewPipeliner(ctx, Pipeliner_newPipeliner{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xabaedf5f7817c820,
			MethodID:      0,
			InterfaceName: "aircraft.capnp:CallSequence",
			MethodName:    "getNumber",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.GetNumber(ctx, CallSequence_getNumber{call})
		},
	})

	return methods
}

// Pipeliner_newPipeliner holds the state for a server call to Pipeliner.newPipeliner.
// See server.Call for documentation.
type Pipeliner_newPipeliner struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Pipeliner_newPipeliner) Args() Pipeliner_newPipeliner_Params {
	return Pipeliner_newPipeliner_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Pipeliner_newPipeliner) AllocResults() (Pipeliner_newPipeliner_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Pipeliner_newPipeliner_Results(r), err
}

// Pipeliner_List is a list of Pipeliner.
type Pipeliner_List = capnp.CapList[Pipeliner]

// NewPipeliner creates a new list of Pipeliner.
func NewPipeliner_List(s *capnp.Segment, sz int32) (Pipeliner_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Pipeliner](l), err
}

type Pipeliner_newPipeliner_Params capnp.Struct

// Pipeliner_newPipeliner_Params_TypeID is the unique identifier for the type Pipeliner_newPipeliner_Params.
const Pipeliner_newPipeliner_Params_TypeID = 0xbaa7b3b1ca91f833

func NewPipeliner_newPipeliner_Params(s *capnp.Segment) (Pipeliner_newPipeliner_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Pipeliner_newPipeliner_Params(st), err
}

func NewRootPipeliner_newPipeliner_Params(s *capnp.Segment) (Pipeliner_newPipeliner_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Pipeliner_newPipeliner_Params(st), err
}

func ReadRootPipeliner_newPipeliner_Params(msg *capnp.Message) (Pipeliner_newPipeliner_Params, error) {
	root, err := msg.Root()
	return Pipeliner_newPipeliner_Params(root.Struct()), err
}

func (s Pipeliner_newPipeliner_Params) String() string {
	str, _ := text.Marshal(0xbaa7b3b1ca91f833, capnp.Struct(s))
	return str
}

func (s Pipeliner_newPipeliner_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Pipeliner_newPipeliner_Params) DecodeFromPtr(p capnp.Ptr) Pipeliner_newPipeliner_Params {
	return Pipeliner_newPipeliner_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Pipeliner_newPipeliner_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Pipeliner_newPipeliner_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Pipeliner_newPipeliner_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Pipeliner_newPipeliner_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Pipeliner_newPipeliner_Params_List is a list of Pipeliner_newPipeliner_Params.
type Pipeliner_newPipeliner_Params_List = capnp.StructList[Pipeliner_newPipeliner_Params]

// NewPipeliner_newPipeliner_Params creates a new list of Pipeliner_newPipeliner_Params.
func NewPipeliner_newPipeliner_Params_List(s *capnp.Segment, sz int32) (Pipeliner_newPipeliner_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Pipeliner_newPipeliner_Params](l), err
}

// Pipeliner_newPipeliner_Params_Future is a wrapper for a Pipeliner_newPipeliner_Params promised by a client call.
type Pipeliner_newPipeliner_Params_Future struct{ *capnp.Future }

func (f Pipeliner_newPipeliner_Params_Future) Struct() (Pipeliner_newPipeliner_Params, error) {
	p, err := f.Future.Ptr()
	return Pipeliner_newPipeliner_Params(p.Struct()), err
}

type Pipeliner_newPipeliner_Results capnp.Struct

// Pipeliner_newPipeliner_Results_TypeID is the unique identifier for the type Pipeliner_newPipeliner_Results.
const Pipeliner_newPipeliner_Results_TypeID = 0xbbcdbf4b4ae501fa

func NewPipeliner_newPipeliner_Results(s *capnp.Segment) (Pipeliner_newPipeliner_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Pipeliner_newPipeliner_Results(st), err
}

func NewRootPipeliner_newPipeliner_Results(s *capnp.Segment) (Pipeliner_newPipeliner_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Pipeliner_newPipeliner_Results(st), err
}

func ReadRootPipeliner_newPipeliner_Results(msg *capnp.Message) (Pipeliner_newPipeliner_Results, error) {
	root, err := msg.Root()
	return Pipeliner_newPipeliner_Results(root.Struct()), err
}

func (s Pipeliner_newPipeliner_Results) String() string {
	str, _ := text.Marshal(0xbbcdbf4b4ae501fa, capnp.Struct(s))
	return str
}

func (s Pipeliner_newPipeliner_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Pipeliner_newPipeliner_Results) DecodeFromPtr(p capnp.Ptr) Pipeliner_newPipeliner_Results {
	return Pipeliner_newPipeliner_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Pipeliner_newPipeliner_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Pipeliner_newPipeliner_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Pipeliner_newPipeliner_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Pipeliner_newPipeliner_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Pipeliner_newPipeliner_Results) Extra() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Pipeliner_newPipeliner_Results) HasExtra() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Pipeliner_newPipeliner_Results) SetExtra(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}
func (s Pipeliner_newPipeliner_Results) Pipeliner() Pipeliner {
	p, _ := capnp.Struct(s).Ptr(1)
	return Pipeliner(p.Interface().Client())
}

func (s Pipeliner_newPipeliner_Results) HasPipeliner() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Pipeliner_newPipeliner_Results) SetPipeliner(v Pipeliner) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(1, in.ToPtr())
}

// Pipeliner_newPipeliner_Results_List is a list of Pipeliner_newPipeliner_Results.
type Pipeliner_newPipeliner_Results_List = capnp.StructList[Pipeliner_newPipeliner_Results]

// NewPipeliner_newPipeliner_Results creates a new list of Pipeliner_newPipeliner_Results.
func NewPipeliner_newPipeliner_Results_List(s *capnp.Segment, sz int32) (Pipeliner_newPipeliner_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Pipeliner_newPipeliner_Results](l), err
}

// Pipeliner_newPipeliner_Results_Future is a wrapper for a Pipeliner_newPipeliner_Results promised by a client call.
type Pipeliner_newPipeliner_Results_Future struct{ *capnp.Future }

func (f Pipeliner_newPipeliner_Results_Future) Struct() (Pipeliner_newPipeliner_Results, error) {
	p, err := f.Future.Ptr()
	return Pipeliner_newPipeliner_Results(p.Struct()), err
}
func (p Pipeliner_newPipeliner_Results_Future) Extra() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p Pipeliner_newPipeliner_Results_Future) Pipeliner() Pipeliner {
	return Pipeliner(p.Future.Field(1, nil).Client())
}

type Defaults capnp.Struct

// Defaults_TypeID is the unique identifier for the type Defaults.
const Defaults_TypeID = 0x97e38948c61f878d

func NewDefaults(s *capnp.Segment) (Defaults, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Defaults(st), err
}

func NewRootDefaults(s *capnp.Segment) (Defaults, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Defaults(st), err
}

func ReadRootDefaults(msg *capnp.Message) (Defaults, error) {
	root, err := msg.Root()
	return Defaults(root.Struct()), err
}

func (s Defaults) String() string {
	str, _ := text.Marshal(0x97e38948c61f878d, capnp.Struct(s))
	return str
}

func (s Defaults) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Defaults) DecodeFromPtr(p capnp.Ptr) Defaults {
	return Defaults(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Defaults) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Defaults) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Defaults) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Defaults) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Defaults) Text() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextDefault("foo"), err
}

func (s Defaults) HasText() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Defaults) TextBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytesDefault("foo"), err
}

func (s Defaults) SetText(v string) error {
	return capnp.Struct(s).SetNewText(0, v)
}

func (s Defaults) Data() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.DataDefault([]byte{0x62, 0x61, 0x72})), err
}

func (s Defaults) HasData() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Defaults) SetData(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return capnp.Struct(s).SetData(1, v)
}

func (s Defaults) Float() float32 {
	return math.Float32frombits(capnp.Struct(s).Uint32(0) ^ 0x4048f5c3)
}

func (s Defaults) SetFloat(v float32) {
	capnp.Struct(s).SetUint32(0, math.Float32bits(v)^0x4048f5c3)
}

func (s Defaults) Int() int32 {
	return int32(capnp.Struct(s).Uint32(4) ^ 4294967173)
}

func (s Defaults) SetInt(v int32) {
	capnp.Struct(s).SetUint32(4, uint32(v)^4294967173)
}

func (s Defaults) Uint() uint32 {
	return capnp.Struct(s).Uint32(8) ^ 42
}

func (s Defaults) SetUint(v uint32) {
	capnp.Struct(s).SetUint32(8, v^42)
}

// Defaults_List is a list of Defaults.
type Defaults_List = capnp.StructList[Defaults]

// NewDefaults creates a new list of Defaults.
func NewDefaults_List(s *capnp.Segment, sz int32) (Defaults_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Defaults](l), err
}

// Defaults_Future is a wrapper for a Defaults promised by a client call.
type Defaults_Future struct{ *capnp.Future }

func (f Defaults_Future) Struct() (Defaults, error) {
	p, err := f.Future.Ptr()
	return Defaults(p.Struct()), err
}

type BenchmarkA capnp.Struct

// BenchmarkA_TypeID is the unique identifier for the type BenchmarkA.
const BenchmarkA_TypeID = 0xde2a1a960863c11c

func NewBenchmarkA(s *capnp.Segment) (BenchmarkA, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return BenchmarkA(st), err
}

func NewRootBenchmarkA(s *capnp.Segment) (BenchmarkA, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return BenchmarkA(st), err
}

func ReadRootBenchmarkA(msg *capnp.Message) (BenchmarkA, error) {
	root, err := msg.Root()
	return BenchmarkA(root.Struct()), err
}

func (s BenchmarkA) String() string {
	str, _ := text.Marshal(0xde2a1a960863c11c, capnp.Struct(s))
	return str
}

func (s BenchmarkA) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (BenchmarkA) DecodeFromPtr(p capnp.Ptr) BenchmarkA {
	return BenchmarkA(capnp.Struct{}.DecodeFromPtr(p))
}

func (s BenchmarkA) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s BenchmarkA) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s BenchmarkA) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s BenchmarkA) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s BenchmarkA) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s BenchmarkA) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s BenchmarkA) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s BenchmarkA) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s BenchmarkA) BirthDay() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s BenchmarkA) SetBirthDay(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s BenchmarkA) Phone() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s BenchmarkA) HasPhone() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s BenchmarkA) PhoneBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s BenchmarkA) SetPhone(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s BenchmarkA) Siblings() int32 {
	return int32(capnp.Struct(s).Uint32(8))
}

func (s BenchmarkA) SetSiblings(v int32) {
	capnp.Struct(s).SetUint32(8, uint32(v))
}

func (s BenchmarkA) Spouse() bool {
	return capnp.Struct(s).Bit(96)
}

func (s BenchmarkA) SetSpouse(v bool) {
	capnp.Struct(s).SetBit(96, v)
}

func (s BenchmarkA) Money() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s BenchmarkA) SetMoney(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// BenchmarkA_List is a list of BenchmarkA.
type BenchmarkA_List = capnp.StructList[BenchmarkA]

// NewBenchmarkA creates a new list of BenchmarkA.
func NewBenchmarkA_List(s *capnp.Segment, sz int32) (BenchmarkA_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2}, sz)
	return capnp.StructList[BenchmarkA](l), err
}

// BenchmarkA_Future is a wrapper for a BenchmarkA promised by a client call.
type BenchmarkA_Future struct{ *capnp.Future }

func (f BenchmarkA_Future) Struct() (BenchmarkA, error) {
	p, err := f.Future.Ptr()
	return BenchmarkA(p.Struct()), err
}

type AllocBenchmark capnp.Struct

// AllocBenchmark_TypeID is the unique identifier for the type AllocBenchmark.
const AllocBenchmark_TypeID = 0xecea3e9ebcbe5655

func NewAllocBenchmark(s *capnp.Segment) (AllocBenchmark, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllocBenchmark(st), err
}

func NewRootAllocBenchmark(s *capnp.Segment) (AllocBenchmark, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllocBenchmark(st), err
}

func ReadRootAllocBenchmark(msg *capnp.Message) (AllocBenchmark, error) {
	root, err := msg.Root()
	return AllocBenchmark(root.Struct()), err
}

func (s AllocBenchmark) String() string {
	str, _ := text.Marshal(0xecea3e9ebcbe5655, capnp.Struct(s))
	return str
}

func (s AllocBenchmark) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (AllocBenchmark) DecodeFromPtr(p capnp.Ptr) AllocBenchmark {
	return AllocBenchmark(capnp.Struct{}.DecodeFromPtr(p))
}

func (s AllocBenchmark) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s AllocBenchmark) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s AllocBenchmark) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s AllocBenchmark) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s AllocBenchmark) Fields() (AllocBenchmark_Field_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return AllocBenchmark_Field_List(p.List()), err
}

func (s AllocBenchmark) HasFields() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s AllocBenchmark) SetFields(v AllocBenchmark_Field_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewFields sets the fields field to a newly
// allocated AllocBenchmark_Field_List, preferring placement in s's segment.
func (s AllocBenchmark) NewFields(n int32) (AllocBenchmark_Field_List, error) {
	l, err := NewAllocBenchmark_Field_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return AllocBenchmark_Field_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// AllocBenchmark_List is a list of AllocBenchmark.
type AllocBenchmark_List = capnp.StructList[AllocBenchmark]

// NewAllocBenchmark creates a new list of AllocBenchmark.
func NewAllocBenchmark_List(s *capnp.Segment, sz int32) (AllocBenchmark_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[AllocBenchmark](l), err
}

// AllocBenchmark_Future is a wrapper for a AllocBenchmark promised by a client call.
type AllocBenchmark_Future struct{ *capnp.Future }

func (f AllocBenchmark_Future) Struct() (AllocBenchmark, error) {
	p, err := f.Future.Ptr()
	return AllocBenchmark(p.Struct()), err
}

type AllocBenchmark_Field capnp.Struct

// AllocBenchmark_Field_TypeID is the unique identifier for the type AllocBenchmark_Field.
const AllocBenchmark_Field_TypeID = 0xb8fb64b8ed846ae6

func NewAllocBenchmark_Field(s *capnp.Segment) (AllocBenchmark_Field, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllocBenchmark_Field(st), err
}

func NewRootAllocBenchmark_Field(s *capnp.Segment) (AllocBenchmark_Field, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return AllocBenchmark_Field(st), err
}

func ReadRootAllocBenchmark_Field(msg *capnp.Message) (AllocBenchmark_Field, error) {
	root, err := msg.Root()
	return AllocBenchmark_Field(root.Struct()), err
}

func (s AllocBenchmark_Field) String() string {
	str, _ := text.Marshal(0xb8fb64b8ed846ae6, capnp.Struct(s))
	return str
}

func (s AllocBenchmark_Field) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (AllocBenchmark_Field) DecodeFromPtr(p capnp.Ptr) AllocBenchmark_Field {
	return AllocBenchmark_Field(capnp.Struct{}.DecodeFromPtr(p))
}

func (s AllocBenchmark_Field) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s AllocBenchmark_Field) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s AllocBenchmark_Field) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s AllocBenchmark_Field) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s AllocBenchmark_Field) StringValue() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s AllocBenchmark_Field) HasStringValue() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s AllocBenchmark_Field) StringValueBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s AllocBenchmark_Field) SetStringValue(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// AllocBenchmark_Field_List is a list of AllocBenchmark_Field.
type AllocBenchmark_Field_List = capnp.StructList[AllocBenchmark_Field]

// NewAllocBenchmark_Field creates a new list of AllocBenchmark_Field.
func NewAllocBenchmark_Field_List(s *capnp.Segment, sz int32) (AllocBenchmark_Field_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[AllocBenchmark_Field](l), err
}

// AllocBenchmark_Field_Future is a wrapper for a AllocBenchmark_Field promised by a client call.
type AllocBenchmark_Field_Future struct{ *capnp.Future }

func (f AllocBenchmark_Field_Future) Struct() (AllocBenchmark_Field, error) {
	p, err := f.Future.Ptr()
	return AllocBenchmark_Field(p.Struct()), err
}

const schema_832bcc6686a26d56 = "x\xda\xacZ}t\x14U\x96\xbf\xb7\xaa;\x15\x92t" +
	"\xba+\xaf\x80\x10\x12#\x11\x14\x1a\xc1\x900\x01\x99u" +
	"\x93`\xa2\xe0\x82\xa6h\x10ue\xa4\x92T\x92\xc6N" +
	"w\xd3]\x0d\x89\xcaAv`\x04\x8f\xec\xc8QGQ" +
	"\x99uX\xdc\xf1\x03\\\xf1cW\x18Dq\xc0\x81\xa8" +
	"\xab\xb2\xf8\x01\xab\xa8\xb8\xa8\xa0\xec\x883\xae\xa0`\xed" +
	"\xb9\xaf\xbb\xba*\x9dnQ\xce\xfeC\xaa\xdf\xef\xd6}" +
	"\xf7\xdd\xefw\x8b\xeaVO\x83k\x82g\xee`\x10\xd4" +
	"\x13\xee<s\xd7\x89coW\xdf<j\x05\xa8^D" +
	"\xf3\xea\xee\xf5\xbf\xeaxu\xec/\xc1%\x01\xb05\x05" +
	"}l]\x01=\xad-\xa8\x074\xe7\xbd\xe2\xfb\xc5\xa0" +
	"m\xd3n\xcb\xa0u\x8bD\xb2\xa5`+\xdb\xc1\x89\x9f" +
	"/\xf8\x14\xd0|\xf7\xe9\xef\xab\xcf\xab\xff\xe3m {" +
	"\x9d\xb4(\x01\xd4>[X\x82lW!\x11\xef($" +
	"\xceSz\x1a\xea\x9ezm\xc4\xca\x0c\xceM\x92\x00\xc0" +
	"\x8e\x17\xf6\xb1\xd3\x9c\xf8d\xe1b@s\xfd_\x86\xbf" +
	"\xf3\xcc\x0dCn\x07YAHq\x9cS$  \xbb" +
	"\xb6\x88\xb8M\x1c5\xfa\xc8\x8e\xaa\xc0?\x82\xec\x15m" +
	"f\x80\xac\xb7h=[VD\x9c\x96\x14]\xce\x1e\xa6" +
	"'\xf3\xce\xdd\x95/7\xde\xfc\xc4\xaf3\xe4\x14\x88j" +
	"u\xd1!\xb6\x96\xd3\xdfSD;\x9b\xb1W\x8f\xaak" +
	"\xf7\xdc\xd5\x9f\x96\xeb\xeat\xd1K\xcc\xed\x91@4\x8b" +
	"\xf6\xfdfg\xc9\xe3\xd5w\x83\xecu\xf5\xdb\xfd\xa3\xa2" +
	">v\x8c\xb8\x05>+\x121\xe0\xf2\x08\x08`\xae\x1e" +
	"\x91?\xf1\xc4\x92\x17\xee\xce\xa2'\x86\x9e>\xe6\xf1\xd0" +
	"\xd3 \x0f\x1d\xec\xc6\xf0|\xa5\xfe\xfb\xed\xf7d\xd3\xe9" +
	"\x18O\x09\xb2\x8b9\xf1\xcf8\xf1\xea\xdb*_\x9e\xb6" +
	"\xea\xe3{I\xa7B\xe6\xc9t\xcfK\xac\x9b\x88k\x83" +
	"\x9eJ\x044\xaf\xdd(<p\xef\xdag\xef\xcf&\xc6" +
	"\xb2\xe2>\xb6\xba\x98\x9eV\x15\x13\xe7u7\xbf\xbfe" +
	"\xcc;\x93\x1ep\x1a`sq\x01\x19`\x0b'\xd8=" +
	"\xe7\x90{\xeb\x05\xbf~`\x80\x0a\xf6\x17\xf7\xb1\xc3\xc4" +
	")\xf0a\xb1\x88\x81/\x8a\xb9\x0a\x12?w\xfd\xca\xac" +
	"\xa9^\x97\xe9W|\xf3\xf7\x8b\xfb\xd8\x11\xbe\xf9\xe1b" +
	"\xb2\xc1\xbd\xe7\xbcyQ\xcbI}\x03\xa8\xe5\x88\xc0\x95" +
	"_\xdb\xe8\x8d\xd1\xe63\xbd\xb4y\xc7\xb4\xce\xaf\xbeg" +
	"/<\x92\xed$\xdd\xde\x97X\xc2KO\x0b9\xed\xb9" +
	"\xbb\x87\xf6\xdc\xf0\xc1\x13\x8f\x0f\xf0\x945\xdeCl\x1d" +
	"'\\\xeb\xbd\x9c\xed\xa2'\xf3\xf8\x92\x99\xfe\xa9s\xde" +
	"x<\x9b\xf67y\xcb\x90=\xcf_\xd8\xc29o\xf9" +
	"\xfc\xc9H\xf3\x81\xdb6e\x93\xe2\x88w=;\xcei" +
	"\x8fqZ9\xda\xfeN\xd8\xbdqs6Z\x8f\xef+" +
	"6\xccGO\x83}D\xbb\xb4\xee\x17\xcb\xe7M\xfer" +
	"3\xe9J\xcc\x8c\xc1f\xdf^\xa6\x12q\xedL\xdf\\" +
	"\xb2j\xbco\xa2\xf9\xc5\xa1s\xfe-\x9b\x0f\xd4n\x91" +
	"\x05d\xbbd\x1e\x852\x85\xec\x86\x7f\xd9:\xea\xe5\xee" +
	"\xb1\xff\x0e\xaa\x8c\xa2\xb9\xff\xa1\xb7\x7f~\xef\x91\xf3\x8f" +
	"\xc2`\x94\x90B\xa0\xe41@vO\x09\x19\xe1\x93\x05" +
	"\xcb\x8f=\xd7\xfe\xdds \x9f\x83\xe6\x9c\xab\xb7o\xfb" +
	"\xed\xdf\x1e\xfd\"\xa5\x8a\xe3%U\xc8\x90\xf1\xa0(!" +
	"\x91kO\xac\xe9\xdb\xfc\xf4\xef\xb7\x82<\xcc2\xd8\x08" +
	"\xb6\x00\xc1e~\x8b\x87\xaf\xf8\xbb\x17^\xfbC\x12I" +
	"J\xe5a\xdc\x96\xc3\x18\x0f\xf5\xc2\xaf\xd6\x9f\xd4\x0f\xfc" +
	")\x9bfz\xd9cl\x19\xdff\x09\xa3m\xc6\xcd\xbc" +
	"\xf8\xf9\x8f\x1f\xff\xfb=\xd9\x02y\x1d\xebc\x8fr\xda" +
	"\x879\xdf\xad\xdf|\xf0\xd6\x0d\x8b\xde{%\x9b)Q" +
	")C&+\\\xf9\x0a1\xbeo\xe7\xa3\x85\x9f\xc8M" +
	"\xaff\x13\xe2\x12e+k\xe6\xb4\x8d\x9c\xf6\xc3\xf3'" +
	"\xcf\xff\xf8\xa9\xa7\xb3\xd2&\x94\xf5l\x09\xa7\xed\xe5\xb4" +
	"\xd3[\x0e\xed?\xf4D\xd3\x7fd5\xe5Z\xe5({" +
	"\x98\x88k\x7f\xa7pS\xee\xbeuGy\xdf\xd1\x07^" +
	"\xcf&\xf2\xe9\xc1%\xc8<Cx\xa2\x18B\xac\xb7\x1f" +
	"Xy|\xc3wuog\x13\xe3\xe2!\xf7\xb3FN" +
	"{\x09\xa7\xddv\xe5\x89/\xf3\x1b\xd4\xb7\x07\xc4\xc0\xbc" +
	"!},\xc8\x09\xf5!\x97\xb35C\x86\x02\x98k&" +
	"\xfd~~\xf8\xf5m\xef\x92\xcc\xaeL-/\x1b\xd2\xc7" +
	"V\xd3\x0b\xb5\xab\x86p\x99W\xbf\xb2\x7f\xf1\xca\xf9w" +
	"\xec\xcf&\xc6\xb1\xa1\xeb\xd9\xd7C\xe9\xe9\xf8P\x12\x83" +
	"-\xfa.\xd8\xd1\xf8\xe6\xfb\xd9\xcc'\x97\xaeg\xc3J" +
	"y\x10\x94\x92\xf9\xcaw\xb4\xe5\xff\xa6\xcc\x7f0Ss" +
	"I)J\xf7\xb2\xd5\xa5\\\x8aR.\xc5\xba\xd9s7" +
	"\xfd\xe1\x89\x96\x83\xd9J\xdc\xfb\xc3\x1ec\x87\x87\xd1\xd3" +
	"G\xc3\xfe\x15\xd0\xbc\xab\xfa\x91o\xfff\xdfo\x0ff" +
	"\xd3roY\x01\xb2UeD\xbc\xa2\x8cD\xde\xb4]" +
	"\x92\xdfzs\xfdG\xd9\x8e\xf7l\xd9V\xf6<\xa7\xdd" +
	"\xc2i\xb5@m\xc9\xae\xa3{\xb2\xd2~Tv?;" +
	"\xc2i\x0fs\xda\x13\xd7>\xf4\xcb\x07\xd7\xe7\x1f\xce&" +
	"\x84{x\x09\xb2\xc1\xc3\xb9V\x86\x13\xf1\xe6?\xcd9" +
	"\xf8\x84\xef\xca\xc3\x19\xa7kF\xc9E^9\xfc%6" +
	"\x9dS7\x0f\xa7\x10\x1fq\xd1\x89\xe1\xa7V\xcc#\xd6" +
	"B?c\x0f+\xdf\xcaF\x94\x13aE9)\xe2\xbd" +
	"\xbc\x93\xff\xb4|\xe9\xb2L\x19\xb8o.,\xefcK" +
	"8m/\xa7\xbd\xb6\xab\xec\xcfS>_\xfeI\xb6\xb3" +
	"5V\x1c`3+\xe8iz\x05/aom\xdf\xb0" +
	"\xa9l\xe1\xa7\x03J\xc3\xc2\x8a>\xb6\x84\x08\x03=\x15" +
	"\"\x06\x96W\xf0\xd2\x90NB\xfd-\xdd\x8c\xd2\x04\xda" +
	"\xbe\xe2v\xb6\x8c\xde\xa9]R\xf1B\x018RQ\x16" +
	"IF\xf8\xbfb\xe3\xfcC\xa9>\xfaI\x92\xf2\xfcy" +
	"S\x07m\xba\xeax6Z\xdd\x7f\x80-\xf4\xf3\x8a\xc1" +
	"i\xef\x1bVr\xfb_\xff\xe1\xb6\xafA.\xb7R\xd8" +
	":?Oa\xa7;.\xdf\xd3\xfc\x9e\xfb\x9b\x8c\x0c\xcb" +
	"\x9dk\x95\x7f/\xbb\x87sY\xe3'\xb7]P\x1a\xba" +
	"\\i2\xbf\xc9\x1a\x0e\xfe\xbd\xec$\xa7\xfd\x9a\xefx" +
	"p\xc6\xf6\xbbF\x1b\xff|*\x9b\xd3^<v/k" +
	"\x1e\xcb\xb5;\xb6\x1e\xc6\x99Z0\xd6\x16\xd3:\x0ca" +
	"|\x9b\x16\x0dG\xa7\x04\x0c\xad\xed\xc6`\xb8s*@" +
	"\x0b\xa2\xea\x12]\x00.\x04\x90=U\x00j\xbe\x88\xaa" +
	"\"\xa0\x14Nt\xa3\x0b\x04t\x91w\xa68`\x8a\xc3" +
	"\xa5\xf5\x91D\xd8\xd0c\xf4\xba/\xfd\xba\xe6\x07P\xaf" +
	"\x17Q\xed\x12\x10Q\xa1\xf2+\xeb5\x00\xea|\x11\xd5" +
	"\x90\x80\xb2\x80\x0a\x0a\x00r\xf0\x0a\x00\xb5KDu\xb9" +
	"\x80\xb2(((\x02\xc8\xcb\xa6\x02\xa8\xb7\x88\xa8\xde'" +
	"\xa07\x1e\xbcIG7\x08\xe8\x06\xac\\\x1c\x89\xb5\xc7" +
	"\xb1\x08\x04,\x024\xe9W(\x187\x00\x00\x8b\x01[" +
	"D\xe4P1\xe0\xd2\xd6\xa0A\x88\xb5\x8c\xc9\xe5\xb4\xf4" +
	"bJ\xfai\x91P{\xfcj=6{qd\xf6\xe2" +
	"HK(\x81\xf1\x0c=LI\xe9a\xa4\x80\xf5\xdd\xbd" +
	"N\x9e>;-\x03\xf6\xe3ni\xf7\xeaH\xb0}N" +
	"8\x18\x09'\xb5\x9b/\xba\x8aL\x93\xb3\x1dS\x02\xa0" +
	"\x8e\x14Q\xad\x16\xd0\x83\xdf\x9bI\x0d\x8d\xa3\xd5\xd1\"" +
	"\xaa\x13\x05D\x0d\xf2\xb0\x15\xf2\x06\x88\xdc\xdc\xd6\x15\x19" +
	"\xaf\xb7uEF\xb6h1\xad;\x0eNi\xcbl\xab" +
	"\x89\xc1pZQ\x99Fk\x96\xda\xba\"\xc9\x83\xba\x01" +
	"\xd2m2Z\xed\x9a,\xfbA\x90\xdd\x92\x97\xf6i\xc0" +
	"\x16\xc4\x9c\x9e3K\x8aD\x8c\xd4\xe9\x10]\x88(\x8f" +
	"Y`\x1f\xc3\x972\xfe\xc5t\xb4\x89\"\xaa\x0d\x02\x9a" +
	"\xda\xdc\xa0\xd1\xd5\xa4w\x80WK\x84\x0c\xf4\xd9m\x1d" +
	" \xfa\xb8\xb2\xd0\x0f\x80\xda\x00(\x8b\x8e\xf5Xsw" +
	"\xd4\xe8\x85lB\xb6E\xc2qc\x06\xf7\x10\xe2\x996" +
	"\\:\xcfs\xc3\x81\x8cC\xe5|\xf4~ \xe5\x0f\xa7" +
	"\x7f\xca\xb3mrUXo1b?\x18&Q#\x86" +
	">;\x1c3\x04\xce\xeer3\x82q4~\x82\xcb\xa5" +
	"\xdb\xb4\x1c.\xd7\xa4w\x90N\xe3\\N%\xc9\x13Q" +
	"^B\xf1\xd8\x93\x0a3\x1e\x90\x88\xf2\x0aZ\xbcUD" +
	"\xf5\x0e\x01QPP@\x94WS\x90\xae\x14Q\xbd\x9b" +
	"\xe2\x11\x15\x14\x11\xe55t\xca;\x92\xf1(\xbb\x04\x85" +
	"\xcc,\xdfCo\xdf)\xa2\xfa\xa0\x80^C\xef1R" +
	"\xde\x062VI\x1d\x91\x88\xb7]34\xf4\x80\x80\x1e" +
	"Z+\x93Z\xb5XeG(\xa2\x19X\x00\xc2\xf1\x82" +
	"?~=\xad\x01P\x0a\x86\x0d\xca-\xc7]+L\xd3" +
	"\x04\xf4&h!\x1f\x049\xdf\x9f\xe5xscZ4" +
	"i\xeeLC<\x05\xa0\xfaDT\xcb\x054\xbb\x83\x9d" +
	"]\xc6\x95\x11\x03\xa7\xea\xb3t-\x14\xea\xad\xe4\xef\xa0" +
	"\xcf\xbe\x96\xe50\x8e\x1d\\\xb3\xf48\xd7#\xe4\xb2v" +
	"$a\x0c\x88\xaf~~\xd7\x1cNt'\xfd\xcek\x17" +
	"S@\xb7\x17!w85\xa6SEj\xcf1Uv" +
	"\xa6\xb02\xa93O8\x933\xb6\xa2\xcf\xbe\xa6g\x1c" +
	"\xd1e%l-\x14\x0a\xe8\x0b\x13z\xb8M\x1f\xdf\xa9" +
	"\x1bW&\xba[\xf5\xd8\xc8Yz%?\xb0\xf3\xb8%" +
	"\xf6q1LF\xc1\xfc,\xa2\x93\xce\xa6jq=\xd3" +
	"\"~\xfbm\x9eGP\xb6\xaf\xdb\x80(ga\x95\x96" +
	"M\x0a\xb7\xe9v~\xb2j*Z7:Y\x9e\x05\x82" +
	"<H2-\xf9\x01c\xfd\xd3Tf\xb4]\x15\xd6\x9b" +
	"4C\x9b\x11\x14\xe3?%\xdc\x9c\xc1\\\x9c%\x91N" +
	"\x93\"F\xd7\x0f\x9c\xbbU\x8b\xeb\xe8\xb3/\x9a9\x92" +
	"\x18\xa5\xa8\x80\x11K\xb4U\x1a\x97j\xd1p\x8e\x1c3" +
	"R@i\x91\xdefK\x97\xeeKr$\x83Yzg" +
	"L\x8f\xc7\x83\x11\xe4,K\xd3,\xd7\x92\x8cw\x8b\xa8" +
	">d;\xd5:\xaa\x1d\xf7\x89\xa8np\x94\xe7\xdf\x11" +
	"\xe1\x83\"\xaa\xcf9\xca\xf3\xb3\xa4\xb1'ET_\xa5" +
	"t\x80\x0a\xba\x00\xe4=$\xe5N\x11\xd57\x04\x94\xdd" +
	"\x82\x82n\x00\xf95Z\xdc-\xa2\xba\xcf\xd6E\xfa^" +
	"\x90\xd4\x85\xd8Z\x8d\x85 `!\xa0\xb7U74\xeb" +
	"t\x85\xc9\x8a]\x1f\x0dia=n\x9f9\xdd\xc4&" +
	"\xcf,\xf5v'\xac\xf7\xa5\xdex\xbb\xf5<\xc0\x11\x92" +
	"\x19\x97|\x80\x0a\xbd\x11\x83\x8c\x86\xa5\xcanX\xe4t" +
	"\xc7Rew,<AR\xc3B\x1ai\x17Q\x8dZ" +
	"\x09\x12@\xee\xf6\xa7\xba\x18\x83L\xa4\x85P\x04\x01E" +
	"@\xa9=\x11\xb1z\x17o\xd4\x88M\x18X\x1fh\xb9" +
	"\xe6\x07\xca\x86\xe5i\xd7y\xc7w\xc6\xa2\x94\x18\xa8\xa4" +
	"\xfa)3\xd4\xd8\x99A&\xf1\xc6Rj\x98b\xa7\x86" +
	"\xca\x8e`,n\xe0 \x10p\x10`}\\o\x8b\x84" +
	"\xdb\xad\x9f\x03\x14\xd4\x18\x0aE\xda\xa6\xea\xe1\xb6\xaen" +
	"-v\xe3\xf8\xcb\x82\x92\x1ej\xcf\xf0\xc4V\x00\xb5H" +
	"D\xb5T@3n\xc4\x82\xe1\xce\xab5\x90B\x09}" +
	"@&\xb4\xb2MK0\xaa\x87\x82a=6>\xac/" +
	"N\xff\x18\xd9\xa2y\xa9w\xf9\xb1\xe4\xe9\xe4\xe4\xc8\x8b" +
	"\xfdNo%\xc6Y\x00\xea\x85\"\xaa\x93\x05\xac\xd4{" +
	"\x8c\x98\x86% `\x09\xa0\x19M1\x03\x8c\xa1l\xdf" +
	"d3\x12\x91\xadm\xaa^?\x10\xd8\x8e\xe2\x96\xb5'" +
	"I9Yf2\xf7g\x13\xdao\x9b\xec,\x9d$K" +
	"oq6\xd9.}C\xc9\x91\xed\xae\xab\x8f\xeb\xb1E" +
	"\xc9^?\x8bW\x8c\x16\xd0\\\xac\x05\x8d`\xb8s\x01" +
	"H\x91VG\xd4\xa6\xaf\xec98O\x95&\xd5N:" +
	"s\x1e\xcd\xc8\x1d9\x14?{q\xc4\xdb\x12J\xc43" +
	"r^\x95\x9d\xf3\xd2\xba_We'=+\xc2\xd39" +
	"\xef\x11G\x84?L\x8b\x0f\x89\xa8n\xb4Z \x00\xf9" +
	"Qz{\x83\x88\xea\x93\x8e\x9c\xb7\x89(\x1f\x11Q\xdd" +
	"y\xe6\\\xe0\xec\xe6\x1cf\xceX\x96\x8cX\xfa\x06\xe4" +
	"\x0d\xc5\x8dZK\xaf\xee3\xdfjZ\x8c\xd8Om1" +
	"\xd3\xd3\xb1\\\xb6\x12\xb5\xce\x0cvSmS-mK" +
	"\xde\x07\xd1g\x7f\x04\xc8a\xadt|[\xcd\x1c\xd5z" +
	"k\x04\x88\xd6\xc4O\x96\x17$k\xbd\x95\x11\xc0K\xef" +
	"4\xa0\xeaB\xc7X\x16` \x7f*\x1d\xbc3\x81\xdc" +
	"\xe5\xcfv\x85\x9a\x94+<c\xbb\xc2f\xd2\xd3F\xab" +
	"\xfc5d\x94\xbfm\x0eW\xd8B\xf7\xd8\xe7\x92V\x97" +
	"\xddb\xd2\x15v\xd0\xe2\x8b\xc9B\xe9\x0dk\xdd\xe94" +
	"Y\xd9\x15\xe9\xb6\x8bZ\xbf\xf6\x90\x17\xbd\x98FAd" +
	"\xd9\xbc\xbeM\x0b_\x16\xea\xe5\x97X\xea\x1d\xdb\xb4\xa8" +
	"\xd6\x16\xa4\x1e\x18,\x12\xb3[\xeb\x09Du\xbd\x9d\xd6" +
	"2K\xa0e\xb8F\xa9\xb6\xa6\xfa\xec\x83,\x9d\x05\xa4" +
	"\x05\x91\xd6\xdcM\xea\xc0\xbc\xd6$\xa0\xd4\xd6\xddn\x1d" +
	"\xde\xab\xc5:\xe3\x19\xf7\xf5\x01\xb6K\x17\"l\xfc\x11" +
	"\xad\xcb\x15\x8e\x88\xb5Z\x97\x87k\x1c\x11k\xb5.\x8f" +
	"^\x91\x0a\xceg\xc8v\xf3\x93\xb6\xebge+\x8c\x9f" +
	"\xad\xb1\xad\xdc\xcfvfk0ft5iN\xf5W" +
	"F\xbb\"a\x9b\"\x1el\x0d\x05\xc3\x9dq\xa2H\xb5" +
	"\xe6\xf5\xf1h$\x11\xd7-\x1bVvG\xc2zoN" +
	"K\xf1\xf2\xc3\x1b\xe0\xa2\xf4\xc1\x9b\xe9\xe0\x0d\"\xaa3" +
	"R\xe5\x9e\x16\xa7\x93\x94M\"\xaa-tr1y\xf2" +
	"\x99d\x8di\"\xaa\xb3\x05\xf4\xf6\xeaZ\xccJA\xb4" +
	"\xab\xd1\x85y `\x1e%$\xad\xd7z\xce\x99B\xf8" +
	"\xc5)}\x83\xfe\xb1)\xc4y\xcd\xca\x96B\xe6\xd6\xc7" +
	"\xb4hMO\xcdY\xdd\xe12\xb2\xe3\x00\xe6\x97\x89\x13" +
	"\xea\xce\xde\xcb\xb3\\\x1c\xce\"\x87\xa6?\xd5\xe5\xe8\xcc" +
	"\x1bS\xbf\xad.\xd4\x9a\x0b9\xe7f\xf6\\H\xf7\xdb" +
	"}\xa8G8m\x0e\xecD=\xe2)3\xd5\x8aV\xd9" +
	"\xad\xa8wQ$\xd8\x0ey\xde\xd6I\xb5\x93\xd0g\x7f" +
	"qHU\x1b\xad\xb6\xa6\x9ad\xb5F\xef\xa9j\xd31" +
	"\xa1\x0e}\xf6\x14:\x87\x96\x1b\xeb\x83\xb1h$\xc6\x95" +
	"R\x9et;?\xef\xa6\x9a\xab\x00P\x90/\xa1?\xa2" +
	"\xfc3\xfa\xe3\x92\xc7\xd1\x1f\xb7<\x8a\xfe\xe4\xc9\x15~" +
	"\x00o8\x12\xd6\xa5\x05\x1d7J!\xadG\x8awD" +
	"\xa4Pb\x91\xd4\xde\xb1\xd8k\xe8qc\x80\xc2\xb89" +
	"f\xeb=)?t\x84E\x953,R\x09azU" +
	"*,\xe6SX\xa4\x92\xf9<2\xd85\xc9\x19\x88d" +
	"\xa4\xe7\x15(\x85l\xcb\xa5\xd2Q}(n8V\xcf" +
	"\x90\xab\xe6&\x9d9\x1a\x12\x13\xf1\xb3\xf2h\xe7\x1c\xd1" +
	"\x97k\x9c\xd0\xa4\x19\xc9B\x961\xbf\xf2\x01\xf8\x92\xb3" +
	"\xab\x81i$\xa9\xac\x9di\xffb3\xdd~\x80\xc04" +
	"\xb7\x88\x81\xd9n\x87\x8b1\xd5]\x06\x10\x98A\xc05" +
	"n\x01+\x84\xd3f2\x8f\xb29\xee*\x80@\x0b!" +
	"\xd7\x13\"\x9e2\x93\xc9\x94]\xcb\x91\xd9\x84\xcc'\xc4" +
	"\xf5\x9d\x99\xbc\x0c\xb2y\x1c\xb9\x86\x90vB\xdc\xdf\x9a" +
	"\xc9\xb4\xca4\x8e\\OH\x17!y'M\x97\x82y" +
	"\x00L\xe7\xc8|BB\x84H'\xcc|\x85\x0f\xbc\x83" +
	"\\\xb6vB\xa2\x84\xe4\x7fC\xfb\xe4\x03\xb0n\xfeN" +
	"\x17!\x06!\x83\xfe\x97\xf6\x19\x04\xc0\x16r$DH" +
	"\x0f!\x05_\xd3>\x05\x00,\xc1\x91(!\xb7\x10R" +
	"\xf8W\xda\xa7\x10\x80\xf5\xf2}\x0cBn%\xa4\xe8/" +
	"f\x83\x82E\x00l\x09W[\x0f!\xcbIm\x9e\xaf" +
	"L\x05=\x00l\x19\x07n!`%\x01\xc5\xc7M\x05" +
	"\x8b\x01\xd8\x0a\x0e\xdcJ\xc0\x1d\x04x\xbf4\x15\xf4\x02" +
	"\xb0U\xee)\x00\x81\xe5\x04<D\x80\xef\xcf\xa6B6" +
	"d\xeb8p\x1f\x01\xcf\x10 \xff\x8f\xa9\xa0\x0c\xc06" +
	"s`#\x01\xbb\x09(9f*X\x02\xc0vq\xe0" +
	"E\x02\xde#\x80}a*\xc8\x00\xd8~\x0e\xec#\xe0" +
	"K\x02\x94\xcfM\x05\x15\x00v\xcc]\x03\x10\xf8\x8c\x00" +
	"W\x9e\x80\x9e\xc1GM\x05\x07\x030\xcc\xa37N\x11" +
	"PJ\xc0\x90#\xa6\x82C\x00\xd8`\x0e\xf8\xf2D\x0c" +
	"\\H\xc0\xd0\xcfL\x05\x87\x02\xb01\x1c\x18I@\x03" +
	"\x01\xa5\x9f\x9a\x0a\x96\x02\xb0K\xf2h\x8f\xc9\x04\xcc&" +
	"\xa0\xfc\x13S\xc1a\xe4by\xa4\x92\x19\x04t\x11P" +
	"q\xd8T\xb0\x8c,\x9f7\x95,O\xc0\x1d\x04\x9c\xf3" +
	"\xdf\xa6\x82\xc3IW\x9c\xd5r\x02\xee$\xa0\xf2cS" +
	"\xc1r\x00\xb6\x9a\x03+\x09\xb8\x9b\x80s\x0f\x99\x0aV" +
	"\x00\xb05y\xad\x00\x81;\x09\xd8H\xc0\x88\x8fL\x05" +
	"\xcf\x01`\x8f\xe6]\x01\x10x\x84\x80g\x08\xa8\xfa\xd0" +
	"T\xb0\x92\xb4\x9bw\x1d@\xe0I\x02\xb6\x11p\xde\x07" +
	"\xa6\x82\xe7\x02\xb0-y\xb3\x00\x02\xcf\x11\xb03O\xc0" +
	"\x8a\x91\x07\xc9\x83F\x00\xb0\x1d\\\xdem\x84\xec\xa6W" +
	"F\xbdo*XE\x06\xe1'|\x91\x80W\x098\xff" +
	"=S\xc1\xf3\x00\xd8\x1e\x0e\xec$\xe0\x0d\x02.\xf8/" +
	"S\xc1\x91\x00\xec\xb5<r\xc6\xdd\x04\xec#`\xf4\x01" +
	"S\xc1Q\x00\xecM.\xef\x1b\x04|A\xc0\x98\xfd\xa6" +
	"\x82\xe7\x03\xb0#\x1c\xf8\x8c\x00\x97$\xa0g\xd8\xbb\xa6" +
	"\x82\x17\x90\x09%\x92\xea\x14\x01\xa5\x04\x94\xbdc*8" +
	"\x9aL\xc8\x01\x9fD&$`\xf8\xdb\xa6\x82c\xc8\x84" +
	"\x1c\x18I@\x03\x01\xfe\xb7Lt|\xdag\x97HU" +
	" x\xc6\xee3\x15\xbc\x10\x80\x8d\x92\xe8\x10\xe7\xa6\xf9" +
	"\\\xf8\x9f\xa6\x82\xe38\x9f)\xfd\xf8\x8c\xdbk*8" +
	"\x9e\\\x81\x03\x93\x09h\"`\xfc\x9b\xa6\x82\x17\x01\xb0" +
	"F\x89t\xdb@\xc0\x0c\x02.z\xc3T\xb0\x1a\x80M" +
	"\xe7\"5\x11\xd0B@\xf5\xeb\xa6\x82\x13(qI1" +
	"r\x1e\x02\xae\x91\xd2\x95M\xbc\xe9&\xf4\xd9_\xfe\xac" +
	"\x02V71=\x12\xea\xa8\xad\xc1\x02\x10\xb0\x00P\x0a" +
	"\xd6M\xb4\x1a6)X[c\xb5fRpB\x9d\xd5" +
	"!\x89\xc1\xc9(\x80\x80\x02\xa0\x94\xa8\x9bh\x0dK\xa4" +
	"Dm\x8d5\xff\x94\x12\x13\xeaP\x02\x01%@11" +
	"\xd9\xea\xa0\xbc\xad\x91H\xc8j\xef\x9c\xf3p\xf4\xb6\x86" +
	"\"\xad\xd6\xac\xa0\xbe\xa3n\xa2c\x86gM\xb9:j" +
	"k\x1c\xab\x05\xa9\xd5`?Z\xb7\xb5\xda\x8f\xd6e\xad" +
	"N\xa8s\xac\x8a\xc9\xd5\xca\xe0d\xc7\xa2\x90\"M\xf4" +
	"c;\xc8Z\xed\xc76\xdfZ\xed\xc7VJ\xb1M8" +
	"\xd9\xe6%\x17\xbd7\xf5\x9bM:\x8dR\x0c\xb8\x94P" +
	"\x07A.\xba\xca\x9b\xa8\xf3\x1dP\xe2\x92\xeb\x1a\xfa\xec" +
	"\xff\xe7\x91Q+\xa1\xffh4cLh\x93\x01d\xa0" +
	"\xc4$\x96\x1a\x94\x82\x18\x09\xa3\xcf\xfe\x9f3)\x98\xcf" +
	" [\xb58`\x96\xceq\xa9\x96l\x842\xaeq^" +
	"2\xfc\xffC\xdf\xc5\xf5\xb1Hos|\xe3\xcc\xfc~" +
	"\x95$\xd22\x89\x9c\x9a\xe2\x9fD#\x91\x90CG\xa9" +
	"O\xa2KS\xafZ\xcb\x9e\xd42y\xb0c9\xd5\xfb" +
	"H\x9d\xb1h\x8ea~=-\xdb\x97\xda\xfe8\xb9\x92" +
	"\x16\xeem1b\xe9\x81\x9c\x16\xee\xe5#o@\x03K" +
	"\\\x08H\xabK\xb50\xbfm`\x89KH\xae\x10\xdd" +
	"\xa5ZTk\x85\xca`(h\xf4b\x89K\xb4\x90\xcc" +
	"\xa6\xda\x9a`V\xf2\x9b#\x9f\x0f\xd8\xff\xfd\x08k*" +
	"/\x0b\xea\xa1\xf6\\-|\x07\x81\x8e\x91U\xfa\xcd\x1c" +
	"-\xfc\x95z\xdc\xd0c\x13.\xd5\xc4\x01\x03{\xbf\xcd" +
	"\xd6\x1b7b9/\xbbg\xf8$\x939$\x152G" +
	"\xd9\xa8\xfd\x98kx\x95\xe3cQ\x8ey\xd4\xc0/\x07" +
	"sg\xebq\xe3R-\x8a\x99g\xbb.5\xec\x9b," +
	"\xa0\x19\xd6\xe3\xc6L\xcd\x88\x81\x18\xec\x19\x10\xd8g\xfa" +
	"8\x91\xfe(\x83\xda\x0f|Su\x08\xfc\x7f\x01\x00\x00" +
	"\xff\xffX\x17OX"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_832bcc6686a26d56,
		Nodes: []uint64{
			0x85257b30d6edf8c5,
			0x8748bc095e10cb5d,
			0x87c33f2330feb3d8,
			0x8821cdb23640783a,
			0x8a165fb4d71bf3a2,
			0x8e5322c1e9282534,
			0x8fae7b41c61fc890,
			0x93c99951eacc72ff,
			0x9430ab12c496d40c,
			0x94bf7df83408218d,
			0x95befe3f14606e6b,
			0x97e38948c61f878d,
			0x9ab599979b02ac59,
			0x9b37d729b9dd7b9d,
			0x9b8f27ba05e255c8,
			0x9d3032ff86043b75,
			0xa465f9502fd11e97,
			0xa8bf13fef2674866,
			0xabaedf5f7817c820,
			0xabd055422a4d7df1,
			0xad87da456fb0ebb9,
			0xb1ac056ed7647011,
			0xb1f0385d845e367f,
			0xb61ee2ecff34ca73,
			0xb72b6dc625baa6a4,
			0xb8fb64b8ed846ae6,
			0xbaa7b3b1ca91f833,
			0xbbcdbf4b4ae501fa,
			0xc7da65f9a2f20ba2,
			0xc95babe3bd394d2d,
			0xcbdc765fd5dff7ba,
			0xcc4411e60ba9c498,
			0xccb3b2e3603826e0,
			0xce44aee2d9e25049,
			0xcf9beaca1cc180c8,
			0xd636fba4f188dabe,
			0xd6514008f0f84ebc,
			0xd8bccf6e60a73791,
			0xd98c608877d9cb8d,
			0xddd1416669fb7613,
			0xde2a1a960863c11c,
			0xde50aebbad57549d,
			0xde9ed43cfaa83093,
			0xe1a2d1d51107bead,
			0xe1c9eac512335361,
			0xe508a29c83a059f8,
			0xe54e10aede55c7b1,
			0xe55d85fc1bf82f21,
			0xe5817f849ff906dc,
			0xe684eb3aef1a6859,
			0xe7711aada4bed56b,
			0xea26e9973bd6a0d9,
			0xecea3e9ebcbe5655,
			0xf14fad09425d081c,
			0xf58782f48a121998,
			0xf705dc45c94766fd,
			0xf7ff4414476c186a,
			0xfca3742893be4cde,
		},
		Compressed: true,
	})
}

var x_832bcc6686a26d56 = []byte{
	0, 0, 0, 0, 2, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 0, 0,
	223, 7, 8, 27, 0, 0, 0, 0,
	0, 0, 0, 0, 4, 0, 0, 0,
	1, 0, 0, 0, 23, 0, 0, 0,
	8, 0, 0, 0, 1, 0, 0, 0,
	223, 7, 8, 27, 0, 0, 0, 0,
	223, 7, 8, 28, 0, 0, 0, 0,
	0, 0, 0, 0, 3, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 1, 0,
	42, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 3, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 1, 0,
	42, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
}
